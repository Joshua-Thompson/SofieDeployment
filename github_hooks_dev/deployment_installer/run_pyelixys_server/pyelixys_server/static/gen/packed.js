//file generated by update_gui_config.py 

// -------- Elixys GUI Config 

var elixys_version = '1.3.0';

// --------- Elixys IP - for export sequences and logs ------------------------

var elixys_ip = 'http://192.168.100.101:5000';

// -------- Elixys Camera IPs - for systems calibration page -------------

var camera0_ip = 'http://192.168.100.101:8080/camera0.ogg';

var camera1_ip = 'http://192.168.100.101:8081/camera1.ogg';

var camera2_ip = 'http://192.168.100.101:8082/camera2.ogg';

// -------- Elixys Liquid Sensor Number - for systems calibration page -------------

var liquid_sensor_number = 0;
//file generated by calibration_manager.Cameras_Cal

var camera2_position = '-160px';

var camera0_position = '0px';

var camera1_position = '-100px';


/*! jQuery v2.0.0 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/
(function(e,undefined){var t,n,r=typeof undefined,i=e.location,o=e.document,s=o.documentElement,a=e.jQuery,u=e.$,l={},c=[],f="2.0.0",p=c.concat,h=c.push,d=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=f.trim,x=function(e,n){return new x.fn.init(e,n,t)},b=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^-ms-/,N=/-([\da-z])/gi,E=function(e,t){return t.toUpperCase()},S=function(){o.removeEventListener("DOMContentLoaded",S,!1),e.removeEventListener("load",S,!1),x.ready()};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,t,n){var r,i;if(!e)return this;if("string"==typeof e){if(r="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:T.exec(e),!r||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof x?t[0]:t,x.merge(this,x.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:o,!0)),C.test(r[1])&&x.isPlainObject(t))for(r in t)x.isFunction(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return i=o.getElementById(r[2]),i&&i.parentNode&&(this.length=1,this[0]=i),this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?n.ready(e):(e.selector!==undefined&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return d.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[1]||{},a=2),"object"==typeof s||x.isFunction(s)||(s={}),u===a&&(s=this,--a);u>a;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(x.isPlainObject(r)||(i=x.isArray(r)))?(i?(i=!1,o=n&&x.isArray(n)?n:[]):o=n&&x.isPlainObject(n)?n:{},s[t]=x.extend(l,o,r)):r!==undefined&&(s[t]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=a),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){(e===!0?--x.readyWait:x.isReady)||(x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(o,[x]),x.fn.trigger&&x(o).trigger("ready").off("ready")))},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if("object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(t){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:JSON.parse,parseXML:function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=undefined}return(!t||t.getElementsByTagName("parsererror").length)&&x.error("Invalid XML: "+e),t},noop:function(){},globalEval:function(e){var t,n=eval;e=x.trim(e),e&&(1===e.indexOf("use strict")?(t=o.createElement("script"),t.text=e,o.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(k,"ms-").replace(N,E)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,s=j(e);if(n){if(s){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(s){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:function(e){return null==e?"":v.call(e)},makeArray:function(e,t){var n=t||[];return null!=e&&(j(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:g.call(t,e,n)},merge:function(e,t){var n=t.length,r=e.length,i=0;if("number"==typeof n)for(;n>i;i++)e[r++]=t[i];else while(t[i]!==undefined)e[r++]=t[i++];return e.length=r,e},grep:function(e,t,n){var r,i=[],o=0,s=e.length;for(n=!!n;s>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,s=j(e),a=[];if(s)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(a[a.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(a[a.length]=r);return p.apply([],a)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),x.isFunction(e)?(r=d.call(arguments,2),i=function(){return e.apply(t||this,r.concat(d.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):undefined},access:function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===x.type(n)){i=!0;for(a in n)x.access(e,t,a,n[a],!0,o,s)}else if(r!==undefined&&(i=!0,x.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(x(e),n)})),t))for(;u>a;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o},now:Date.now,swap:function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i}}),x.ready.promise=function(t){return n||(n=x.Deferred(),"complete"===o.readyState?setTimeout(x.ready):(o.addEventListener("DOMContentLoaded",S,!1),e.addEventListener("load",S,!1))),n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function j(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}t=x(o),function(e,undefined){var t,n,r,i,o,s,a,u,l,c,f,p,h,d,g,m,y="sizzle"+-new Date,v=e.document,b={},w=0,T=0,C=ot(),k=ot(),N=ot(),E=!1,S=function(){return 0},j=typeof undefined,D=1<<31,A=[],L=A.pop,q=A.push,H=A.push,O=A.slice,F=A.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},P="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",R="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=M.replace("w","w#"),$="\\["+R+"*("+M+")"+R+"*(?:([*^$|!~]?=)"+R+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+R+"*\\]",B=":("+M+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",I=RegExp("^"+R+"+|((?:^|[^\\\\])(?:\\\\.)*)"+R+"+$","g"),z=RegExp("^"+R+"*,"+R+"*"),_=RegExp("^"+R+"*([>+~]|"+R+")"+R+"*"),X=RegExp(R+"*[+~]"),U=RegExp("="+R+"*([^\\]'\"]*)"+R+"*\\]","g"),Y=RegExp(B),V=RegExp("^"+W+"$"),G={ID:RegExp("^#("+M+")"),CLASS:RegExp("^\\.("+M+")"),TAG:RegExp("^("+M.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+B),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+R+"*(even|odd|(([+-]|)(\\d*)n|)"+R+"*(?:([+-]|)"+R+"*(\\d+)|))"+R+"*\\)|)","i"),"boolean":RegExp("^(?:"+P+")$","i"),needsContext:RegExp("^"+R+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+R+"*((?:-\\d)?\\d*)"+R+"*\\)|)(?=[^-]|$)","i")},J=/^[^{]+\{\s*\[native \w/,Q=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,K=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,et=/'|\\/g,tt=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,nt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{H.apply(A=O.call(v.childNodes),v.childNodes),A[v.childNodes.length].nodeType}catch(rt){H={apply:A.length?function(e,t){q.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function it(e){return J.test(e+"")}function ot(){var e,t=[];return e=function(n,i){return t.push(n+=" ")>r.cacheLength&&delete e[t.shift()],e[n]=i}}function st(e){return e[y]=!0,e}function at(e){var t=c.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ut(e,t,n,r){var i,o,s,a,u,f,d,g,x,w;if((t?t.ownerDocument||t:v)!==c&&l(t),t=t||c,n=n||[],!e||"string"!=typeof e)return n;if(1!==(a=t.nodeType)&&9!==a)return[];if(p&&!r){if(i=Q.exec(e))if(s=i[1]){if(9===a){if(o=t.getElementById(s),!o||!o.parentNode)return n;if(o.id===s)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(s))&&m(t,o)&&o.id===s)return n.push(o),n}else{if(i[2])return H.apply(n,t.getElementsByTagName(e)),n;if((s=i[3])&&b.getElementsByClassName&&t.getElementsByClassName)return H.apply(n,t.getElementsByClassName(s)),n}if(b.qsa&&(!h||!h.test(e))){if(g=d=y,x=t,w=9===a&&e,1===a&&"object"!==t.nodeName.toLowerCase()){f=gt(e),(d=t.getAttribute("id"))?g=d.replace(et,"\\$&"):t.setAttribute("id",g),g="[id='"+g+"'] ",u=f.length;while(u--)f[u]=g+mt(f[u]);x=X.test(e)&&t.parentNode||t,w=f.join(",")}if(w)try{return H.apply(n,x.querySelectorAll(w)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(I,"$1"),t,n,r)}o=ut.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},l=ut.setDocument=function(e){var t=e?e.ownerDocument||e:v;return t!==c&&9===t.nodeType&&t.documentElement?(c=t,f=t.documentElement,p=!o(t),b.getElementsByTagName=at(function(e){return e.appendChild(t.createComment("")),!e.getElementsByTagName("*").length}),b.attributes=at(function(e){return e.className="i",!e.getAttribute("className")}),b.getElementsByClassName=at(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),b.sortDetached=at(function(e){return 1&e.compareDocumentPosition(c.createElement("div"))}),b.getById=at(function(e){return f.appendChild(e).id=y,!t.getElementsByName||!t.getElementsByName(y).length}),b.getById?(r.find.ID=function(e,t){if(typeof t.getElementById!==j&&p){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},r.filter.ID=function(e){var t=e.replace(tt,nt);return function(e){return e.getAttribute("id")===t}}):(r.find.ID=function(e,t){if(typeof t.getElementById!==j&&p){var n=t.getElementById(e);return n?n.id===e||typeof n.getAttributeNode!==j&&n.getAttributeNode("id").value===e?[n]:undefined:[]}},r.filter.ID=function(e){var t=e.replace(tt,nt);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),r.find.TAG=b.getElementsByTagName?function(e,t){return typeof t.getElementsByTagName!==j?t.getElementsByTagName(e):undefined}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=b.getElementsByClassName&&function(e,t){return typeof t.getElementsByClassName!==j&&p?t.getElementsByClassName(e):undefined},d=[],h=[],(b.qsa=it(t.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||h.push("\\["+R+"*(?:value|"+P+")"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){var t=c.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&h.push("[*^$]="+R+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(b.matchesSelector=it(g=f.webkitMatchesSelector||f.mozMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){b.disconnectedMatch=g.call(e,"div"),g.call(e,"[s!='']:x"),d.push("!=",B)}),h=h.length&&RegExp(h.join("|")),d=d.length&&RegExp(d.join("|")),m=it(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},S=f.compareDocumentPosition?function(e,n){if(e===n)return E=!0,0;var r=n.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(n);return r?1&r||!b.sortDetached&&n.compareDocumentPosition(e)===r?e===t||m(v,e)?-1:n===t||m(v,n)?1:u?F.call(u,e)-F.call(u,n):0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,n){var r,i=0,o=e.parentNode,s=n.parentNode,a=[e],l=[n];if(e===n)return E=!0,0;if(!o||!s)return e===t?-1:n===t?1:o?-1:s?1:u?F.call(u,e)-F.call(u,n):0;if(o===s)return lt(e,n);r=e;while(r=r.parentNode)a.unshift(r);r=n;while(r=r.parentNode)l.unshift(r);while(a[i]===l[i])i++;return i?lt(a[i],l[i]):a[i]===v?-1:l[i]===v?1:0},c):c},ut.matches=function(e,t){return ut(e,null,null,t)},ut.matchesSelector=function(e,t){if((e.ownerDocument||e)!==c&&l(e),t=t.replace(U,"='$1']"),!(!b.matchesSelector||!p||d&&d.test(t)||h&&h.test(t)))try{var n=g.call(e,t);if(n||b.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return ut(t,c,null,[e]).length>0},ut.contains=function(e,t){return(e.ownerDocument||e)!==c&&l(e),m(e,t)},ut.attr=function(e,t){(e.ownerDocument||e)!==c&&l(e);var n=r.attrHandle[t.toLowerCase()],i=n&&n(e,t,!p);return i===undefined?b.attributes||!p?e.getAttribute(t):(i=e.getAttributeNode(t))&&i.specified?i.value:null:i},ut.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},ut.uniqueSort=function(e){var t,n=[],r=0,i=0;if(E=!b.detectDuplicates,u=!b.sortStable&&e.slice(0),e.sort(S),E){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return e};function lt(e,t){var n=t&&e,r=n&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ct(e,t,n){var r;return n?undefined:(r=e.getAttributeNode(t))&&r.specified?r.value:e[t]===!0?t.toLowerCase():null}function ft(e,t,n){var r;return n?undefined:r=e.getAttribute(t,"type"===t.toLowerCase()?1:2)}function pt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ht(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function dt(e){return st(function(t){return t=+t,st(function(n,r){var i,o=e([],n.length,t),s=o.length;while(s--)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}i=ut.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else for(;t=e[r];r++)n+=i(t);return n},r=ut.selectors={cacheLength:50,createPseudo:st,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(tt,nt),e[3]=(e[4]||e[5]||"").replace(tt,nt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||ut.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&ut.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return G.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&Y.test(n)&&(t=gt(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(tt,nt).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=C[e+" "];return t||(t=RegExp("(^|"+R+")"+e+"("+R+"|$)"))&&C(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=ut.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,h,d,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,v=a&&t.nodeName.toLowerCase(),x=!u&&!a;if(m){if(o){while(g){f=t;while(f=f[g])if(a?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;d=g="only"===e&&!d&&"nextSibling"}return!0}if(d=[s?m.firstChild:m.lastChild],s&&x){c=m[y]||(m[y]={}),l=c[e]||[],h=l[0]===w&&l[1],p=l[0]===w&&l[2],f=h&&m.childNodes[h];while(f=++h&&f&&f[g]||(p=h=0)||d.pop())if(1===f.nodeType&&++p&&f===t){c[e]=[w,h,p];break}}else if(x&&(l=(t[y]||(t[y]={}))[e])&&l[0]===w)p=l[1];else while(f=++h&&f&&f[g]||(p=h=0)||d.pop())if((a?f.nodeName.toLowerCase()===v:1===f.nodeType)&&++p&&(x&&((f[y]||(f[y]={}))[e]=[w,p]),f===t))break;return p-=i,p===r||0===p%r&&p/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||ut.error("unsupported pseudo: "+e);return i[y]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?st(function(e,n){var r,o=i(e,t),s=o.length;while(s--)r=F.call(e,o[s]),e[r]=!(n[r]=o[s])}):function(e){return i(e,0,n)}):i}},pseudos:{not:st(function(e){var t=[],n=[],r=s(e.replace(I,"$1"));return r[y]?st(function(e,t,n,i){var o,s=r(e,null,i,[]),a=e.length;while(a--)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:st(function(e){return function(t){return ut(e,t).length>0}}),contains:st(function(e){return function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:st(function(e){return V.test(e||"")||ut.error("unsupported lang: "+e),e=e.replace(tt,nt).toLowerCase(),function(t){var n;do if(n=p?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===c.activeElement&&(!c.hasFocus||c.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!r.pseudos.empty(e)},header:function(e){return Z.test(e.nodeName)},input:function(e){return K.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:dt(function(){return[0]}),last:dt(function(e,t){return[t-1]}),eq:dt(function(e,t,n){return[0>n?n+t:n]}),even:dt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:dt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:dt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:dt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(t in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=pt(t);for(t in{submit:!0,reset:!0})r.pseudos[t]=ht(t);function gt(e,t){var n,i,o,s,a,u,l,c=k[e+" "];if(c)return t?0:c.slice(0);a=e,u=[],l=r.preFilter;while(a){(!n||(i=z.exec(a)))&&(i&&(a=a.slice(i[0].length)||a),u.push(o=[])),n=!1,(i=_.exec(a))&&(n=i.shift(),o.push({value:n,type:i[0].replace(I," ")}),a=a.slice(n.length));for(s in r.filter)!(i=G[s].exec(a))||l[s]&&!(i=l[s](i))||(n=i.shift(),o.push({value:n,type:s,matches:i}),a=a.slice(n.length));if(!n)break}return t?a.length:a?ut.error(e):k(e,u).slice(0)}function mt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function yt(e,t,r){var i=t.dir,o=r&&"parentNode"===i,s=T++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,r,a){var u,l,c,f=w+" "+s;if(a){while(t=t[i])if((1===t.nodeType||o)&&e(t,r,a))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[y]||(t[y]={}),(l=c[i])&&l[0]===f){if((u=l[1])===!0||u===n)return u===!0}else if(l=c[i]=[f],l[1]=e(t,r,a)||n,l[1]===!0)return!0}}function vt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,s=[],a=0,u=e.length,l=null!=t;for(;u>a;a++)(o=e[a])&&(!n||n(o,r,i))&&(s.push(o),l&&t.push(a));return s}function bt(e,t,n,r,i,o){return r&&!r[y]&&(r=bt(r)),i&&!i[y]&&(i=bt(i,o)),st(function(o,s,a,u){var l,c,f,p=[],h=[],d=s.length,g=o||Ct(t||"*",a.nodeType?[a]:a,[]),m=!e||!o&&t?g:xt(g,p,e,a,u),y=n?i||(o?e:d||r)?[]:s:m;if(n&&n(m,y,a,u),r){l=xt(y,h),r(l,[],a,u),c=l.length;while(c--)(f=l[c])&&(y[h[c]]=!(m[h[c]]=f))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(f=y[c])&&l.push(m[c]=f);i(null,y=[],l,u)}c=y.length;while(c--)(f=y[c])&&(l=i?F.call(o,f):p[c])>-1&&(o[l]=!(s[l]=f))}}else y=xt(y===s?y.splice(d,y.length):y),i?i(null,s,y,u):H.apply(s,y)})}function wt(e){var t,n,i,o=e.length,s=r.relative[e[0].type],u=s||r.relative[" "],l=s?1:0,c=yt(function(e){return e===t},u,!0),f=yt(function(e){return F.call(t,e)>-1},u,!0),p=[function(e,n,r){return!s&&(r||n!==a)||((t=n).nodeType?c(e,n,r):f(e,n,r))}];for(;o>l;l++)if(n=r.relative[e[l].type])p=[yt(vt(p),n)];else{if(n=r.filter[e[l].type].apply(null,e[l].matches),n[y]){for(i=++l;o>i;i++)if(r.relative[e[i].type])break;return bt(l>1&&vt(p),l>1&&mt(e.slice(0,l-1)).replace(I,"$1"),n,i>l&&wt(e.slice(l,i)),o>i&&wt(e=e.slice(i)),o>i&&mt(e))}p.push(n)}return vt(p)}function Tt(e,t){var i=0,o=t.length>0,s=e.length>0,u=function(u,l,f,p,h){var d,g,m,y=[],v=0,x="0",b=u&&[],T=null!=h,C=a,k=u||s&&r.find.TAG("*",h&&l.parentNode||l),N=w+=null==C?1:Math.random()||.1;for(T&&(a=l!==c&&l,n=i);null!=(d=k[x]);x++){if(s&&d){g=0;while(m=e[g++])if(m(d,l,f)){p.push(d);break}T&&(w=N,n=++i)}o&&((d=!m&&d)&&v--,u&&b.push(d))}if(v+=x,o&&x!==v){g=0;while(m=t[g++])m(b,y,l,f);if(u){if(v>0)while(x--)b[x]||y[x]||(y[x]=L.call(p));y=xt(y)}H.apply(p,y),T&&!u&&y.length>0&&v+t.length>1&&ut.uniqueSort(p)}return T&&(w=N,a=C),b};return o?st(u):u}s=ut.compile=function(e,t){var n,r=[],i=[],o=N[e+" "];if(!o){t||(t=gt(e)),n=t.length;while(n--)o=wt(t[n]),o[y]?r.push(o):i.push(o);o=N(e,Tt(i,r))}return o};function Ct(e,t,n){var r=0,i=t.length;for(;i>r;r++)ut(e,t[r],n);return n}function kt(e,t,n,i){var o,a,u,l,c,f=gt(e);if(!i&&1===f.length){if(a=f[0]=f[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&p&&r.relative[a[1].type]){if(t=(r.find.ID(u.matches[0].replace(tt,nt),t)||[])[0],!t)return n;e=e.slice(a.shift().value.length)}o=G.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],r.relative[l=u.type])break;if((c=r.find[l])&&(i=c(u.matches[0].replace(tt,nt),X.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=i.length&&mt(a),!e)return H.apply(n,i),n;break}}}return s(e,f)(i,t,!p,n,X.test(e)),n}r.pseudos.nth=r.pseudos.eq;function Nt(){}Nt.prototype=r.filters=r.pseudos,r.setFilters=new Nt,b.sortStable=y.split("").sort(S).join("")===y,l(),[0,0].sort(S),b.detectDuplicates=E,at(function(e){if(e.innerHTML="<a href='#'></a>","#"!==e.firstChild.getAttribute("href")){var t="type|href|height|width".split("|"),n=t.length;while(n--)r.attrHandle[t[n]]=ft}}),at(function(e){if(null!=e.getAttribute("disabled")){var t=P.split("|"),n=t.length;while(n--)r.attrHandle[t[n]]=ct}}),x.find=ut,x.expr=ut.selectors,x.expr[":"]=x.expr.pseudos,x.unique=ut.uniqueSort,x.text=ut.getText,x.isXMLDoc=ut.isXML,x.contains=ut.contains}(e);var D={};function A(e){var t=D[e]={};return x.each(e.match(w)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?D[e]||A(e):x.extend({},e);var t,n,r,i,o,s,a=[],u=!e.once&&[],l=function(f){for(t=e.memory&&f,n=!0,s=i||0,i=0,o=a.length,r=!0;a&&o>s;s++)if(a[s].apply(f[0],f[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,a&&(u?u.length&&l(u.shift()):t?a=[]:c.disable())},c={add:function(){if(a){var n=a.length;(function s(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&c.has(n)||a.push(n):n&&n.length&&"string"!==r&&s(n)})})(arguments),r?o=a.length:t&&(i=n,l(t))}return this},remove:function(){return a&&x.each(arguments,function(e,t){var n;while((n=x.inArray(t,a,n))>-1)a.splice(n,1),r&&(o>=n&&o--,s>=n&&s--)}),this},has:function(e){return e?x.inArray(e,a)>-1:!(!a||!a.length)},empty:function(){return a=[],o=0,this},disable:function(){return a=u=t=undefined,this},disabled:function(){return!a},lock:function(){return u=undefined,t||c.disable(),this},locked:function(){return!u},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!a||n&&!u||(r?u.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!n}};return c},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var s=o[0],a=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=a&&a.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===r?n.promise():this,a?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=d.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),s=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?d.call(arguments):r,n===a?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},a,u,l;if(r>1)for(a=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(s(t,l,n)).fail(o.reject).progress(s(t,u,a)):--i;return i||o.resolveWith(l,n),o.promise()}}),x.support=function(t){var n=o.createElement("input"),r=o.createDocumentFragment(),i=o.createElement("div"),s=o.createElement("select"),a=s.appendChild(o.createElement("option"));return n.type?(n.type="checkbox",t.checkOn=""!==n.value,t.optSelected=a.selected,t.reliableMarginRight=!0,t.boxSizingReliable=!0,t.pixelPosition=!1,n.checked=!0,t.noCloneChecked=n.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!a.disabled,n=o.createElement("input"),n.value="t",n.type="radio",t.radioValue="t"===n.value,n.setAttribute("checked","t"),n.setAttribute("name","t"),r.appendChild(n),t.checkClone=r.cloneNode(!0).cloneNode(!0).lastChild.checked,t.focusinBubbles="onfocusin"in e,i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===i.style.backgroundClip,x(function(){var n,r,s="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",a=o.getElementsByTagName("body")[0];a&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",a.appendChild(n).appendChild(i),i.innerHTML="",i.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",x.swap(a,null!=a.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===i.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(i,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(i,null)||{width:"4px"}).width,r=i.appendChild(o.createElement("div")),r.style.cssText=i.style.cssText=s,r.style.marginRight=r.style.width="0",i.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),a.removeChild(n))}),t):t}({});var L,q,H=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,O=/([A-Z])/g;function F(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=x.expando+Math.random()}F.uid=1,F.accepts=function(e){return e.nodeType?1===e.nodeType||9===e.nodeType:!0},F.prototype={key:function(e){if(!F.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=F.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,x.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(x.isEmptyObject(o))this.cache[i]=t;else for(r in t)o[r]=t[r]},get:function(e,t){var n=this.cache[this.key(e)];return t===undefined?n:n[t]},access:function(e,t,n){return t===undefined||t&&"string"==typeof t&&n===undefined?this.get(e,t):(this.set(e,t,n),n!==undefined?n:t)},remove:function(e,t){var n,r,i=this.key(e),o=this.cache[i];if(t===undefined)this.cache[i]={};else{x.isArray(t)?r=t.concat(t.map(x.camelCase)):t in o?r=[t]:(r=x.camelCase(t),r=r in o?[r]:r.match(w)||[]),n=r.length;while(n--)delete o[r[n]]}},hasData:function(e){return!x.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){delete this.cache[this.key(e)]}},L=new F,q=new F,x.extend({acceptData:F.accepts,hasData:function(e){return L.hasData(e)||q.hasData(e)},data:function(e,t,n){return L.access(e,t,n)},removeData:function(e,t){L.remove(e,t)},_data:function(e,t,n){return q.access(e,t,n)},_removeData:function(e,t){q.remove(e,t)}}),x.fn.extend({data:function(e,t){var n,r,i=this[0],o=0,s=null;if(e===undefined){if(this.length&&(s=L.get(i),1===i.nodeType&&!q.get(i,"hasDataAttrs"))){for(n=i.attributes;n.length>o;o++)r=n[o].name,0===r.indexOf("data-")&&(r=x.camelCase(r.substring(5)),P(i,r,s[r]));q.set(i,"hasDataAttrs",!0)}return s}return"object"==typeof e?this.each(function(){L.set(this,e)}):x.access(this,function(t){var n,r=x.camelCase(e);if(i&&t===undefined){if(n=L.get(i,e),n!==undefined)return n;if(n=L.get(i,r),n!==undefined)return n;if(n=P(i,r,undefined),n!==undefined)return n}else this.each(function(){var n=L.get(this,r);L.set(this,r,t),-1!==e.indexOf("-")&&n!==undefined&&L.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){L.remove(this,e)})}});function P(e,t,n){var r;if(n===undefined&&1===e.nodeType)if(r="data-"+t.replace(O,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n?!0:"false"===n?!1:"null"===n?null:+n+""===n?+n:H.test(n)?JSON.parse(n):n}catch(i){}L.set(e,t,n)}else n=undefined;return n}x.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=q.get(e,t),n&&(!r||x.isArray(n)?r=q.access(e,t,x.makeArray(n)):r.push(n)),r||[]):undefined},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),s=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return q.get(e,n)||q.access(e,n,{empty:x.Callbacks("once memory").add(function(){q.remove(e,[t+"queue",n])})})}}),x.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),n>arguments.length?x.queue(this[0],e):t===undefined?this:this.each(function(){var n=x.queue(this,e,t);
x._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=x.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=undefined),e=e||"fx";while(s--)n=q.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var R,M,W=/[\t\r\n]/g,$=/\r/g,B=/^(?:input|select|textarea|button)$/i;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[x.propFix[e]||e]})},addClass:function(e){var t,n,r,i,o,s=0,a=this.length,u="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,s=0,a=this.length,u=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];a>s;s++)if(n=this[s],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(W," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,i="boolean"==typeof t;return x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,s=0,a=x(this),u=t,l=e.match(w)||[];while(o=l[s++])u=i?u:!a.hasClass(o),a[u?"addClass":"removeClass"](o)}else(n===r||"boolean"===n)&&(this.className&&q.set(this,"__className__",this.className),this.className=this.className||e===!1?"":q.get(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(W," ").indexOf(t)>=0)return!0;return!1},val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=x.isFunction(e),this.each(function(n){var i,o=x(this);1===this.nodeType&&(i=r?e.call(this,n,o.val()):e,null==i?i="":"number"==typeof i?i+="":x.isArray(i)&&(i=x.map(i,function(e){return null==e?"":e+""})),t=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&t.set(this,i,"value")!==undefined||(this.value=i))});if(i)return t=x.valHooks[i.type]||x.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&(n=t.get(i,"value"))!==undefined?n:(n=i.value,"string"==typeof n?n.replace($,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,s=o?null:[],a=o?i+1:r.length,u=0>i?a:o?i:0;for(;a>u;u++)if(n=r[u],!(!n.selected&&u!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),s=i.length;while(s--)r=i[s],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,t,n){var i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===r?x.prop(e,t,n):(1===s&&x.isXMLDoc(e)||(t=t.toLowerCase(),i=x.attrHooks[t]||(x.expr.match.boolean.test(t)?M:R)),n===undefined?i&&"get"in i&&null!==(o=i.get(e,t))?o:(o=x.find.attr(e,t),null==o?undefined:o):null!==n?i&&"set"in i&&(o=i.set(e,n,t))!==undefined?o:(e.setAttribute(t,n+""),n):(x.removeAttr(e,t),undefined))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.boolean.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return o=1!==s||!x.isXMLDoc(e),o&&(t=x.propFix[t]||t,i=x.propHooks[t]),n!==undefined?i&&"set"in i&&(r=i.set(e,n,t))!==undefined?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||B.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),M={set:function(e,t,n){return t===!1?x.removeAttr(e,n):e.setAttribute(n,n),n}},x.each(x.expr.match.boolean.source.match(/\w+/g),function(e,t){var n=x.expr.attrHandle[t]||x.find.attr;x.expr.attrHandle[t]=function(e,t,r){var i=x.expr.attrHandle[t],o=r?undefined:(x.expr.attrHandle[t]=undefined)!=n(e,t,r)?t.toLowerCase():null;return x.expr.attrHandle[t]=i,o}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,t){return x.isArray(t)?e.checked=x.inArray(x(e).val(),t)>=0:undefined}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var I=/^key/,z=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,X=/^([^.]*)(?:\.(.+)|)$/;function U(){return!0}function Y(){return!1}function V(){try{return o.activeElement}catch(e){}}x.event={global:{},add:function(e,t,n,i,o){var s,a,u,l,c,f,p,h,d,g,m,y=q.get(e);if(y){n.handler&&(s=n,n=s.handler,o=s.selector),n.guid||(n.guid=x.guid++),(l=y.events)||(l=y.events={}),(a=y.handle)||(a=y.handle=function(e){return typeof x===r||e&&x.event.triggered===e.type?undefined:x.event.dispatch.apply(a.elem,arguments)},a.elem=e),t=(t||"").match(w)||[""],c=t.length;while(c--)u=X.exec(t[c])||[],d=m=u[1],g=(u[2]||"").split(".").sort(),d&&(p=x.event.special[d]||{},d=(o?p.delegateType:p.bindType)||d,p=x.event.special[d]||{},f=x.extend({type:d,origType:m,data:i,handler:n,guid:n.guid,selector:o,needsContext:o&&x.expr.match.needsContext.test(o),namespace:g.join(".")},s),(h=l[d])||(h=l[d]=[],h.delegateCount=0,p.setup&&p.setup.call(e,i,g,a)!==!1||e.addEventListener&&e.addEventListener(d,a,!1)),p.add&&(p.add.call(e,f),f.handler.guid||(f.handler.guid=n.guid)),o?h.splice(h.delegateCount++,0,f):h.push(f),x.event.global[d]=!0);e=null}},remove:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,h,d,g,m=q.hasData(e)&&q.get(e);if(m&&(u=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(a=X.exec(t[l])||[],h=g=a[1],d=(a[2]||"").split(".").sort(),h){f=x.event.special[h]||{},h=(r?f.delegateType:f.bindType)||h,p=u[h]||[],a=a[2]&&RegExp("(^|\\.)"+d.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));s&&!p.length&&(f.teardown&&f.teardown.call(e,d,m.handle)!==!1||x.removeEvent(e,h,m.handle),delete u[h])}else for(h in u)x.event.remove(e,h+t[l],n,r,!0);x.isEmptyObject(u)&&(delete m.handle,q.remove(e,"events"))}},trigger:function(t,n,r,i){var s,a,u,l,c,f,p,h=[r||o],d=y.call(t,"type")?t.type:t,g=y.call(t,"namespace")?t.namespace.split("."):[];if(a=u=r=r||o,3!==r.nodeType&&8!==r.nodeType&&!_.test(d+x.event.triggered)&&(d.indexOf(".")>=0&&(g=d.split("."),d=g.shift(),g.sort()),c=0>d.indexOf(":")&&"on"+d,t=t[x.expando]?t:new x.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=g.join("."),t.namespace_re=t.namespace?RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=undefined,t.target||(t.target=r),n=null==n?[t]:x.makeArray(n,[t]),p=x.event.special[d]||{},i||!p.trigger||p.trigger.apply(r,n)!==!1)){if(!i&&!p.noBubble&&!x.isWindow(r)){for(l=p.delegateType||d,_.test(l+d)||(a=a.parentNode);a;a=a.parentNode)h.push(a),u=a;u===(r.ownerDocument||o)&&h.push(u.defaultView||u.parentWindow||e)}s=0;while((a=h[s++])&&!t.isPropagationStopped())t.type=s>1?l:p.bindType||d,f=(q.get(a,"events")||{})[t.type]&&q.get(a,"handle"),f&&f.apply(a,n),f=c&&a[c],f&&x.acceptData(a)&&f.apply&&f.apply(a,n)===!1&&t.preventDefault();return t.type=d,i||t.isDefaultPrevented()||p._default&&p._default.apply(h.pop(),n)!==!1||!x.acceptData(r)||c&&x.isFunction(r[d])&&!x.isWindow(r)&&(u=r[c],u&&(r[c]=null),x.event.triggered=d,r[d](),x.event.triggered=undefined,u&&(r[c]=u)),t.result}},dispatch:function(e){e=x.event.fix(e);var t,n,r,i,o,s=[],a=d.call(arguments),u=(q.get(this,"events")||{})[e.type]||[],l=x.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),t=0;while((i=s[t++])&&!e.isPropagationStopped()){e.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(o.namespace))&&(e.handleObj=o,e.data=o.data,r=((x.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),r!==undefined&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;a>n;n++)o=t[n],i=o.selector+" ",r[i]===undefined&&(r[i]=o.needsContext?x(i,this).index(u)>=0:x.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return t.length>a&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,s=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||o,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||s===undefined||(e.which=1&s?1:2&s?3:4&s?2:0),e}},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=z.test(i)?this.mouseHooks:I.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return 3===e.target.nodeType&&(e.target=e.target.parentNode),s.filter?s.filter(e,o):e},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==V()&&this.focus?(this.focus(),!1):undefined},delegateType:"focusin"},blur:{trigger:function(){return this===V()&&this.blur?(this.blur(),!1):undefined},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&x.nodeName(this,"input")?(this.click(),!1):undefined},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==undefined&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},x.Event=function(e,t){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.getPreventDefault&&e.getPreventDefault()?U:Y):this.type=e,t&&x.extend(this,t),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,undefined):new x.Event(e,t)},x.Event.prototype={isDefaultPrevented:Y,isPropagationStopped:Y,isImmediatePropagationStopped:Y,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=U,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=U,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=U,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=undefined);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=undefined):null==r&&("string"==typeof t?(r=n,n=undefined):(r=n,n=t,t=undefined)),r===!1)r=Y;else if(!r)return this;return 1===i&&(o=r,r=function(e){return x().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=x.guid++)),this.each(function(){x.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,x(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return(t===!1||"function"==typeof t)&&(n=t,t=undefined),n===!1&&(n=Y),this.each(function(){x.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?x.event.trigger(e,t,n,!0):undefined}});var G=/^.[^:#\[\.,]*$/,J=x.expr.match.needsContext,Q={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return t=this,this.pushStack(x(e).filter(function(){for(r=0;i>r;r++)if(x.contains(t[r],this))return!0}));for(n=[],r=0;i>r;r++)x.find(e,this[r],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t=x(e,this),n=t.length;return this.filter(function(){var e=0;for(;n>e;e++)if(x.contains(this,t[e]))return!0})},not:function(e){return this.pushStack(Z(this,e||[],!0))},filter:function(e){return this.pushStack(Z(this,e||[],!1))},is:function(e){return!!e&&("string"==typeof e?J.test(e)?x(e,this.context).index(this[0])>=0:x.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],s=J.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(s?s.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?g.call(x(e),this[0]):g.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function K(e,t){while((e=e[t])&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return K(e,"nextSibling")},prev:function(e){return K(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(Q[e]||x.unique(i),"p"===e[0]&&i.reverse()),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,t,n){var r=[],i=n!==undefined;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&x(e).is(n))break;r.push(e)}return r},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function Z(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(G.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return g.call(t,e)>=0!==n})}var et=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,tt=/<([\w:]+)/,nt=/<|&#?\w+;/,rt=/<(?:script|style|link)/i,it=/^(?:checkbox|radio)$/i,ot=/checked\s*(?:[^=]|=\s*.checked.)/i,st=/^$|\/(?:java|ecma)script/i,at=/^true\/(.*)/,ut=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,lt={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};lt.optgroup=lt.option,lt.tbody=lt.tfoot=lt.colgroup=lt.caption=lt.col=lt.thead,lt.th=lt.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===undefined?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=ct(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=ct(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(gt(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&ht(gt(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++)1===e.nodeType&&(x.cleanData(gt(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var t=this[0]||{},n=0,r=this.length;if(e===undefined&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!rt.test(e)&&!lt[(tt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(et,"<$1></$2>");try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(x.cleanData(gt(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=p.apply([],e);var r,i,o,s,a,u,l=0,c=this.length,f=this,h=c-1,d=e[0],g=x.isFunction(d);if(g||!(1>=c||"string"!=typeof d||x.support.checkClone)&&ot.test(d))return this.each(function(r){var i=f.eq(r);g&&(e[0]=d.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(r=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),i=r.firstChild,1===r.childNodes.length&&(r=i),i)){for(o=x.map(gt(r,"script"),ft),s=o.length;c>l;l++)a=r,l!==h&&(a=x.clone(a,!0,!0),s&&x.merge(o,gt(a,"script"))),t.call(this[l],a,l);if(s)for(u=o[o.length-1].ownerDocument,x.map(o,pt),l=0;s>l;l++)a=o[l],st.test(a.type||"")&&!q.access(a,"globalEval")&&x.contains(u,a)&&(a.src?x._evalUrl(a.src):x.globalEval(a.textContent.replace(ut,"")))}return this}}),x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=[],i=x(e),o=i.length-1,s=0;for(;o>=s;s++)n=s===o?this:this.clone(!0),x(i[s])[t](n),h.apply(r,n.get());return this.pushStack(r)}}),x.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=x.contains(e.ownerDocument,e);if(!(x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(s=gt(a),o=gt(e),r=0,i=o.length;i>r;r++)mt(o[r],s[r]);if(t)if(n)for(o=o||gt(e),s=s||gt(a),r=0,i=o.length;i>r;r++)dt(o[r],s[r]);else dt(e,a);return s=gt(a,"script"),s.length>0&&ht(s,!u&&gt(e,"script")),a},buildFragment:function(e,t,n,r){var i,o,s,a,u,l,c=0,f=e.length,p=t.createDocumentFragment(),h=[];for(;f>c;c++)if(i=e[c],i||0===i)if("object"===x.type(i))x.merge(h,i.nodeType?[i]:i);else if(nt.test(i)){o=o||p.appendChild(t.createElement("div")),s=(tt.exec(i)||["",""])[1].toLowerCase(),a=lt[s]||lt._default,o.innerHTML=a[1]+i.replace(et,"<$1></$2>")+a[2],l=a[0];while(l--)o=o.firstChild;x.merge(h,o.childNodes),o=p.firstChild,o.textContent=""}else h.push(t.createTextNode(i));p.textContent="",c=0;while(i=h[c++])if((!r||-1===x.inArray(i,r))&&(u=x.contains(i.ownerDocument,i),o=gt(p.appendChild(i),"script"),u&&ht(o),n)){l=0;while(i=o[l++])st.test(i.type||"")&&n.push(i)}return p},cleanData:function(e){var t,n,r,i=e.length,o=0,s=x.event.special;for(;i>o;o++){if(n=e[o],x.acceptData(n)&&(t=q.access(n)))for(r in t.events)s[r]?x.event.remove(n,r):x.removeEvent(n,r,t.handle);L.discard(n),q.discard(n)}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"text",async:!1,global:!1,success:x.globalEval})}});function ct(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function ft(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function pt(e){var t=at.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function ht(e,t){var n=e.length,r=0;for(;n>r;r++)q.set(e[r],"globalEval",!t||q.get(t[r],"globalEval"))}function dt(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(q.hasData(e)&&(o=q.access(e),s=x.extend({},o),l=o.events,q.set(t,s),l)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;r>n;n++)x.event.add(t,i,l[i][n])}L.hasData(e)&&(a=L.access(e),u=x.extend({},a),L.set(t,u))}}function gt(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return t===undefined||t&&x.nodeName(e,t)?x.merge([e],n):n}function mt(e,t){var n=t.nodeName.toLowerCase();"input"===n&&it.test(e.type)?t.checked=e.checked:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}x.fn.extend({wrapAll:function(e){var t;return x.isFunction(e)?this.each(function(t){x(this).wrapAll(e.call(this,t))}):(this[0]&&(t=x(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var yt,vt,xt=/^(none|table(?!-c[ea]).+)/,bt=/^margin/,wt=RegExp("^("+b+")(.*)$","i"),Tt=RegExp("^("+b+")(?!px)[a-z%]+$","i"),Ct=RegExp("^([+-])=("+b+")","i"),kt={BODY:"block"},Nt={position:"absolute",visibility:"hidden",display:"block"},Et={letterSpacing:0,fontWeight:400},St=["Top","Right","Bottom","Left"],jt=["Webkit","O","Moz","ms"];function Dt(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=jt.length;while(i--)if(t=jt[i]+n,t in e)return t;return r}function At(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function Lt(t){return e.getComputedStyle(t,null)}function qt(e,t){var n,r,i,o=[],s=0,a=e.length;for(;a>s;s++)r=e[s],r.style&&(o[s]=q.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&At(r)&&(o[s]=q.access(r,"olddisplay",Pt(r.nodeName)))):o[s]||(i=At(r),(n&&"none"!==n||!i)&&q.set(r,"olddisplay",i?n:x.css(r,"display"))));for(s=0;a>s;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}x.fn.extend({css:function(e,t){return x.access(this,function(e,t,n){var r,i,o={},s=0;if(x.isArray(t)){for(r=Lt(e),i=t.length;i>s;s++)o[t[s]]=x.css(e,t[s],!1,r);return o}return n!==undefined?x.style(e,t,n):x.css(e,t)},e,t,arguments.length>1)},show:function(){return qt(this,!0)},hide:function(){return qt(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:At(this))?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=yt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=x.camelCase(t),u=e.style;return t=x.cssProps[a]||(x.cssProps[a]=Dt(u,a)),s=x.cssHooks[t]||x.cssHooks[a],n===undefined?s&&"get"in s&&(i=s.get(e,!1,r))!==undefined?i:u[t]:(o=typeof n,"string"===o&&(i=Ct.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(x.css(e,t)),o="number"),null==n||"number"===o&&isNaN(n)||("number"!==o||x.cssNumber[a]||(n+="px"),x.support.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&(n=s.set(e,n,r))===undefined||(u[t]=n)),undefined)}},css:function(e,t,n,r){var i,o,s,a=x.camelCase(t);return t=x.cssProps[a]||(x.cssProps[a]=Dt(e.style,a)),s=x.cssHooks[t]||x.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),i===undefined&&(i=yt(e,t,r)),"normal"===i&&t in Et&&(i=Et[t]),""===n||n?(o=parseFloat(i),n===!0||x.isNumeric(o)?o||0:i):i}}),yt=function(e,t,n){var r,i,o,s=n||Lt(e),a=s?s.getPropertyValue(t)||s[t]:undefined,u=e.style;return s&&(""!==a||x.contains(e.ownerDocument,e)||(a=x.style(e,t)),Tt.test(a)&&bt.test(t)&&(r=u.width,i=u.minWidth,o=u.maxWidth,u.minWidth=u.maxWidth=u.width=a,a=s.width,u.width=r,u.minWidth=i,u.maxWidth=o)),a};function Ht(e,t,n){var r=wt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function Ot(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;for(;4>o;o+=2)"margin"===n&&(s+=x.css(e,n+St[o],!0,i)),r?("content"===n&&(s-=x.css(e,"padding"+St[o],!0,i)),"margin"!==n&&(s-=x.css(e,"border"+St[o]+"Width",!0,i))):(s+=x.css(e,"padding"+St[o],!0,i),"padding"!==n&&(s+=x.css(e,"border"+St[o]+"Width",!0,i)));return s}function Ft(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Lt(e),s=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=yt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Tt.test(i))return i;r=s&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+Ot(e,t,n||(s?"border":"content"),r,o)+"px"}function Pt(e){var t=o,n=kt[e];return n||(n=Rt(e,t),"none"!==n&&n||(vt=(vt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(vt[0].contentWindow||vt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=Rt(e,t),vt.detach()),kt[e]=n),n}function Rt(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,t){x.cssHooks[t]={get:function(e,n,r){return n?0===e.offsetWidth&&xt.test(x.css(e,"display"))?x.swap(e,Nt,function(){return Ft(e,t,r)}):Ft(e,t,r):undefined},set:function(e,n,r){var i=r&&Lt(e);return Ht(e,n,r?Ot(e,t,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,t){return t?x.swap(e,{display:"inline-block"},yt,[e,"marginRight"]):undefined}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,t){x.cssHooks[t]={get:function(e,n){return n?(n=yt(e,t),Tt.test(n)?x(e).position()[t]+"px":n):undefined}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+St[r]+t]=o[r]||o[r-2]||o[0];return i}},bt.test(e)||(x.cssHooks[e+t].set=Ht)});var Mt=/%20/g,Wt=/\[\]$/,$t=/\r?\n/g,Bt=/^(?:submit|button|image|reset|file)$/i,It=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&It.test(this.nodeName)&&!Bt.test(e)&&(this.checked||!it.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace($t,"\r\n")}}):{name:t.name,value:n.replace($t,"\r\n")}}).get()}}),x.param=function(e,t){var n,r=[],i=function(e,t){t=x.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(t===undefined&&(t=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){i(this.name,this.value)});else for(n in e)zt(n,e[n],t,i);return r.join("&").replace(Mt,"+")};function zt(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||Wt.test(e)?r(e,i):zt(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)zt(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var _t,Xt,Ut=x.now(),Yt=/\?/,Vt=/#.*$/,Gt=/([?&])_=[^&]*/,Jt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Qt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Kt=/^(?:GET|HEAD)$/,Zt=/^\/\//,en=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,tn=x.fn.load,nn={},rn={},on="*/".concat("*");try{Xt=i.href}catch(sn){Xt=o.createElement("a"),Xt.href="",Xt=Xt.href}_t=en.exec(Xt.toLowerCase())||[];function an(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];
if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function un(e,t,n,r){var i={},o=e===rn;function s(a){var u;return i[a]=!0,x.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||o||i[l]?o?!(u=l):undefined:(t.dataTypes.unshift(l),s(l),!1)}),u}return s(t.dataTypes[0])||!i["*"]&&s("*")}function ln(e,t){var n,r,i=x.ajaxSettings.flatOptions||{};for(n in t)t[n]!==undefined&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,t,n){if("string"!=typeof e&&tn)return tn.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=e.slice(a),e=e.slice(0,a)),x.isFunction(t)?(n=t,t=undefined):t&&"object"==typeof t&&(i="POST"),s.length>0&&x.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?x("<div>").append(x.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Xt,type:"GET",isLocal:Qt.test(_t[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":on,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?ln(ln(e,x.ajaxSettings),t):ln(x.ajaxSettings,e)},ajaxPrefilter:an(nn),ajaxTransport:an(rn),ajax:function(e,t){"object"==typeof e&&(t=e,e=undefined),t=t||{};var n,r,i,o,s,a,u,l,c=x.ajaxSetup({},t),f=c.context||c,p=c.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),d=x.Callbacks("once memory"),g=c.statusCode||{},m={},y={},v=0,b="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(2===v){if(!o){o={};while(t=Jt.exec(i))o[t[1].toLowerCase()]=t[2]}t=o[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===v?i:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return v||(e=y[n]=y[n]||e,m[e]=t),this},overrideMimeType:function(e){return v||(c.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>v)for(t in e)g[t]=[g[t],e[t]];else T.always(e[T.status]);return this},abort:function(e){var t=e||b;return n&&n.abort(t),k(0,t),this}};if(h.promise(T).complete=d.add,T.success=T.done,T.error=T.fail,c.url=((e||c.url||Xt)+"").replace(Vt,"").replace(Zt,_t[1]+"//"),c.type=t.method||t.type||c.method||c.type,c.dataTypes=x.trim(c.dataType||"*").toLowerCase().match(w)||[""],null==c.crossDomain&&(a=en.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===_t[1]&&a[2]===_t[2]&&(a[3]||("http:"===a[1]?"80":"443"))===(_t[3]||("http:"===_t[1]?"80":"443")))),c.data&&c.processData&&"string"!=typeof c.data&&(c.data=x.param(c.data,c.traditional)),un(nn,c,t,T),2===v)return T;u=c.global,u&&0===x.active++&&x.event.trigger("ajaxStart"),c.type=c.type.toUpperCase(),c.hasContent=!Kt.test(c.type),r=c.url,c.hasContent||(c.data&&(r=c.url+=(Yt.test(r)?"&":"?")+c.data,delete c.data),c.cache===!1&&(c.url=Gt.test(r)?r.replace(Gt,"$1_="+Ut++):r+(Yt.test(r)?"&":"?")+"_="+Ut++)),c.ifModified&&(x.lastModified[r]&&T.setRequestHeader("If-Modified-Since",x.lastModified[r]),x.etag[r]&&T.setRequestHeader("If-None-Match",x.etag[r])),(c.data&&c.hasContent&&c.contentType!==!1||t.contentType)&&T.setRequestHeader("Content-Type",c.contentType),T.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+("*"!==c.dataTypes[0]?", "+on+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)T.setRequestHeader(l,c.headers[l]);if(c.beforeSend&&(c.beforeSend.call(f,T,c)===!1||2===v))return T.abort();b="abort";for(l in{success:1,error:1,complete:1})T[l](c[l]);if(n=un(rn,c,t,T)){T.readyState=1,u&&p.trigger("ajaxSend",[T,c]),c.async&&c.timeout>0&&(s=setTimeout(function(){T.abort("timeout")},c.timeout));try{v=1,n.send(m,k)}catch(C){if(!(2>v))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,t,o,a){var l,m,y,b,w,C=t;2!==v&&(v=2,s&&clearTimeout(s),n=undefined,i=a||"",T.readyState=e>0?4:0,l=e>=200&&300>e||304===e,o&&(b=cn(c,T,o)),b=fn(c,b,T,l),l?(c.ifModified&&(w=T.getResponseHeader("Last-Modified"),w&&(x.lastModified[r]=w),w=T.getResponseHeader("etag"),w&&(x.etag[r]=w)),204===e?C="nocontent":304===e?C="notmodified":(C=b.state,m=b.data,y=b.error,l=!y)):(y=C,(e||!C)&&(C="error",0>e&&(e=0))),T.status=e,T.statusText=(t||C)+"",l?h.resolveWith(f,[m,C,T]):h.rejectWith(f,[T,C,y]),T.statusCode(g),g=undefined,u&&p.trigger(l?"ajaxSuccess":"ajaxError",[T,c,l?m:y]),d.fireWith(f,[T,C]),u&&(p.trigger("ajaxComplete",[T,c]),--x.active||x.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,t){return x.get(e,undefined,t,"script")}}),x.each(["get","post"],function(e,t){x[t]=function(e,n,r,i){return x.isFunction(n)&&(i=i||r,r=n,n=undefined),x.ajax({url:e,type:t,dataType:i,data:n,success:r})}});function cn(e,t,n){var r,i,o,s,a=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),r===undefined&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}return o?(o!==u[0]&&u.unshift(o),n[o]):undefined}function fn(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e["throws"])t=s(t);else try{t=s(t)}catch(f){return{state:"parsererror",error:s?f:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===undefined&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),x.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=x("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),o.head.appendChild(t[0])},abort:function(){n&&n()}}}});var pn=[],hn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=pn.pop()||x.expando+"_"+Ut++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(hn.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&hn.test(t.data)&&"data");return a||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=x.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(hn,"$1"+i):t.jsonp!==!1&&(t.url+=(Yt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||x.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,pn.push(i)),s&&x.isFunction(o)&&o(s[0]),s=o=undefined}),"script"):undefined}),x.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var dn=x.ajaxSettings.xhr(),gn={0:200,1223:204},mn=0,yn={};e.ActiveXObject&&x(e).on("unload",function(){for(var e in yn)yn[e]();yn=undefined}),x.support.cors=!!dn&&"withCredentials"in dn,x.support.ajax=dn=!!dn,x.ajaxTransport(function(e){var t;return x.support.cors||dn&&!e.crossDomain?{send:function(n,r){var i,o,s=e.xhr();if(s.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)s[i]=e.xhrFields[i];e.mimeType&&s.overrideMimeType&&s.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)s.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete yn[o],t=s.onload=s.onerror=null,"abort"===e?s.abort():"error"===e?r(s.status||404,s.statusText):r(gn[s.status]||s.status,s.statusText,"string"==typeof s.responseText?{text:s.responseText}:undefined,s.getAllResponseHeaders()))}},s.onload=t(),s.onerror=t("error"),t=yn[o=mn++]=t("abort"),s.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}:undefined});var vn,xn,bn=/^(?:toggle|show|hide)$/,wn=RegExp("^(?:([+-])=|)("+b+")([a-z%]*)$","i"),Tn=/queueHooks$/,Cn=[Dn],kn={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=wn.exec(t),s=i.cur(),a=+s||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(x.cssNumber[e]?"":"px"),"px"!==r&&a){a=x.css(i.elem,e,!0)||n||1;do u=u||".5",a/=u,x.style(i.elem,e,a+r);while(u!==(u=i.cur()/s)&&1!==u&&--l)}i.unit=r,i.start=a,i.end=o[1]?a+(o[1]+1)*n:n}return i}]};function Nn(){return setTimeout(function(){vn=undefined}),vn=x.now()}function En(e,t){x.each(t,function(t,n){var r=(kn[t]||[]).concat(kn["*"]),i=0,o=r.length;for(;o>i;i++)if(r[i].call(e,t,n))return})}function Sn(e,t,n){var r,i,o=0,s=Cn.length,a=x.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=vn||Nn(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;for(;u>s;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),1>o&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:vn||Nn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(jn(c,l.opts.specialEasing);s>o;o++)if(r=Cn[o].call(l,e,c,l.opts))return r;return En(l,c),x.isFunction(l.opts.start)&&l.opts.start.call(e,l),x.fx.timer(x.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function jn(e,t){var n,r,i,o,s;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=x.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(Sn,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],kn[n]=kn[n]||[],kn[n].unshift(t)},prefilter:function(e,t){t?Cn.unshift(e):Cn.push(e)}});function Dn(e,t,n){var r,i,o,s,a,u,l,c,f,p=this,h=e.style,d={},g=[],m=e.nodeType&&At(e);n.queue||(c=x._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,f=c.empty.fire,c.empty.fire=function(){c.unqueued||f()}),c.unqueued++,p.always(function(){p.always(function(){c.unqueued--,x.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),a=q.get(e,"fxshow");for(r in t)if(o=t[r],bn.exec(o)){if(delete t[r],u=u||"toggle"===o,o===(m?"hide":"show")){if("show"!==o||a===undefined||a[r]===undefined)continue;m=!0}g.push(r)}if(s=g.length){a=q.get(e,"fxshow")||q.access(e,"fxshow",{}),"hidden"in a&&(m=a.hidden),u&&(a.hidden=!m),m?x(e).show():p.done(function(){x(e).hide()}),p.done(function(){var t;q.remove(e,"fxshow");for(t in d)x.style(e,t,d[t])});for(r=0;s>r;r++)i=g[r],l=p.createTween(i,m?a[i]:0),d[i]=a[i]||x.style(e,i),i in a||(a[i]=l.start,m&&(l.end=l.start,l.start="width"===i||"height"===i?1:0))}}function An(e,t,n,r,i){return new An.prototype.init(e,t,n,r,i)}x.Tween=An,An.prototype={constructor:An,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=An.propHooks[this.prop];return e&&e.get?e.get(this):An.propHooks._default.get(this)},run:function(e){var t,n=An.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):An.propHooks._default.set(this),this}},An.prototype.init.prototype=An.prototype,An.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},An.propHooks.scrollTop=An.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(Ln(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(At).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),s=function(){var t=Sn(this,x.extend({},e),o);s.finish=function(){t.stop(!0)},(i||q.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=undefined),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=x.timers,s=q.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&Tn.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));(t||!n)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=q.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,s=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;s>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function Ln(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=St[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:Ln("show"),slideUp:Ln("hide"),slideToggle:Ln("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=An.prototype.init,x.fx.tick=function(){var e,t=x.timers,n=0;for(vn=x.now();t.length>n;n++)e=t[n],e()||t[n]!==e||t.splice(n--,1);t.length||x.fx.stop(),vn=undefined},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){xn||(xn=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(xn),xn=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===undefined?this:this.each(function(t){x.offset.setOffset(this,e,t)});var t,n,i=this[0],o={top:0,left:0},s=i&&i.ownerDocument;if(s)return t=s.documentElement,x.contains(t,i)?(typeof i.getBoundingClientRect!==r&&(o=i.getBoundingClientRect()),n=qn(s),{top:o.top+n.pageYOffset-t.clientTop,left:o.left+n.pageXOffset-t.clientLeft}):o},x.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=x.css(e,"position"),f=x(e),p={};"static"===c&&(e.style.position="relative"),a=f.offset(),o=x.css(e,"top"),u=x.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),x.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(p.top=t.top-a.top+s),null!=t.left&&(p.left=t.left-a.left+i),"using"in t?t.using.call(e,p):f.css(p)}},x.fn.extend({position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===x.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(r=e.offset()),r.top+=x.css(e[0],"borderTopWidth",!0),r.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-x.css(n,"marginTop",!0),left:t.left-r.left-x.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;x.fn[t]=function(i){return x.access(this,function(t,i,o){var s=qn(t);return o===undefined?s?s[n]:t[i]:(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o,undefined)},t,i,arguments.length,null)}});function qn(e){return x.isWindow(e)?e:9===e.nodeType&&e.defaultView}x.each({Height:"height",Width:"width"},function(e,t){x.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){x.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return x.access(this,function(t,n,r){var i;return x.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):r===undefined?x.css(t,n,s):x.style(t,n,r,s)},t,o?r:undefined,o,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&"object"==typeof module.exports?module.exports=x:"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}),"object"==typeof e&&"object"==typeof e.document&&(e.jQuery=e.$=x)})(window);
/*! 
 * jquery.event.drag - v 2.2
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
// Created: 2008-06-04 
// Updated: 2012-05-21
// REQUIRES: jquery 1.7.x

;(function( $ ){

// add the jquery instance method
$.fn.drag = function( str, arg, opts ){
	// figure out the event type
	var type = typeof str == "string" ? str : "",
	// figure out the event handler...
	fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
	// fix the event type
	if ( type.indexOf("drag") !== 0 ) 
		type = "drag"+ type;
	// were options passed
	opts = ( str == fn ? arg : opts ) || {};
	// trigger or bind event handler
	return fn ? this.bind( type, opts, fn ) : this.trigger( type );
};

// local refs (increase compression)
var $event = $.event, 
$special = $event.special,
// configure the drag special event 
drag = $special.drag = {
	
	// these are the default settings
	defaults: {
		which: 1, // mouse button pressed to start drag sequence
		distance: 0, // distance dragged before dragstart
		not: ':input', // selector to suppress dragging on target elements
		handle: null, // selector to match handle target elements
		relative: false, // true to use "position", false to use "offset"
		drop: true, // false to suppress drop events, true or selector to allow
		click: false // false to suppress click events after dragend (no proxy)
	},
	
	// the key name for stored drag data
	datakey: "dragdata",
	
	// prevent bubbling for better performance
	noBubble: true,
	
	// count bound related events
	add: function( obj ){ 
		// read the interaction data
		var data = $.data( this, drag.datakey ),
		// read any passed options 
		opts = obj.data || {};
		// count another realted event
		data.related += 1;
		// extend data options bound with this event
		// don't iterate "opts" in case it is a node 
		$.each( drag.defaults, function( key, def ){
			if ( opts[ key ] !== undefined )
				data[ key ] = opts[ key ];
		});
	},
	
	// forget unbound related events
	remove: function(){
		$.data( this, drag.datakey ).related -= 1;
	},
	
	// configure interaction, capture settings
	setup: function(){
		// check for related events
		if ( $.data( this, drag.datakey ) ) 
			return;
		// initialize the drag data with copied defaults
		var data = $.extend({ related:0 }, drag.defaults );
		// store the interaction data
		$.data( this, drag.datakey, data );
		// bind the mousedown event, which starts drag interactions
		$event.add( this, "touchstart mousedown", drag.init, data );
		// prevent image dragging in IE...
		if ( this.attachEvent ) 
			this.attachEvent("ondragstart", drag.dontstart ); 
	},
	
	// destroy configured interaction
	teardown: function(){
		var data = $.data( this, drag.datakey ) || {};
		// check for related events
		if ( data.related ) 
			return;
		// remove the stored data
		$.removeData( this, drag.datakey );
		// remove the mousedown event
		$event.remove( this, "touchstart mousedown", drag.init );
		// enable text selection
		drag.textselect( true ); 
		// un-prevent image dragging in IE...
		if ( this.detachEvent ) 
			this.detachEvent("ondragstart", drag.dontstart ); 
	},
		
	// initialize the interaction
	init: function( event ){ 
		// sorry, only one touch at a time
		if ( drag.touched ) 
			return;
		// the drag/drop interaction data
		var dd = event.data, results;
		// check the which directive
		if ( event.which != 0 && dd.which > 0 && event.which != dd.which ) 
			return; 
		// check for suppressed selector
		if ( $( event.target ).is( dd.not ) ) 
			return;
		// check for handle selector
		if ( dd.handle && !$( event.target ).closest( dd.handle, event.currentTarget ).length ) 
			return;

		drag.touched = event.type == 'touchstart' ? this : null;
		dd.propagates = 1;
		dd.mousedown = this;
		dd.interactions = [ drag.interaction( this, dd ) ];
		dd.target = event.target;
		dd.pageX = event.pageX;
		dd.pageY = event.pageY;
		dd.dragging = null;
		// handle draginit event... 
		results = drag.hijack( event, "draginit", dd );
		// early cancel
		if ( !dd.propagates )
			return;
		// flatten the result set
		results = drag.flatten( results );
		// insert new interaction elements
		if ( results && results.length ){
			dd.interactions = [];
			$.each( results, function(){
				dd.interactions.push( drag.interaction( this, dd ) );
			});
		}
		// remember how many interactions are propagating
		dd.propagates = dd.interactions.length;
		// locate and init the drop targets
		if ( dd.drop !== false && $special.drop ) 
			$special.drop.handler( event, dd );
		// disable text selection
		drag.textselect( false ); 
		// bind additional events...
		if ( drag.touched )
			$event.add( drag.touched, "touchmove touchend", drag.handler, dd );
		else 
			$event.add( document, "mousemove mouseup", drag.handler, dd );
		// helps prevent text selection or scrolling
		if ( !drag.touched || dd.live )
			return false;
	},	
	
	// returns an interaction object
	interaction: function( elem, dd ){
		var offset = $( elem )[ dd.relative ? "position" : "offset" ]() || { top:0, left:0 };
		return {
			drag: elem, 
			callback: new drag.callback(), 
			droppable: [],
			offset: offset
		};
	},
	
	// handle drag-releatd DOM events
	handler: function( event ){ 
		// read the data before hijacking anything
		var dd = event.data;	
		// handle various events
		switch ( event.type ){
			// mousemove, check distance, start dragging
			case !dd.dragging && 'touchmove': 
				event.preventDefault();
			case !dd.dragging && 'mousemove':
				//  drag tolerance, x� + y� = distance�
				if ( Math.pow(  event.pageX-dd.pageX, 2 ) + Math.pow(  event.pageY-dd.pageY, 2 ) < Math.pow( dd.distance, 2 ) ) 
					break; // distance tolerance not reached
				event.target = dd.target; // force target from "mousedown" event (fix distance issue)
				drag.hijack( event, "dragstart", dd ); // trigger "dragstart"
				if ( dd.propagates ) // "dragstart" not rejected
					dd.dragging = true; // activate interaction
			// mousemove, dragging
			case 'touchmove':
				event.preventDefault();
			case 'mousemove':
				if ( dd.dragging ){
					// trigger "drag"		
					drag.hijack( event, "drag", dd );
					if ( dd.propagates ){
						// manage drop events
						if ( dd.drop !== false && $special.drop )
							$special.drop.handler( event, dd ); // "dropstart", "dropend"							
						break; // "drag" not rejected, stop		
					}
					event.type = "mouseup"; // helps "drop" handler behave
				}
			// mouseup, stop dragging
			case 'touchend': 
			case 'mouseup': 
			default:
				if ( drag.touched )
					$event.remove( drag.touched, "touchmove touchend", drag.handler ); // remove touch events
				else 
					$event.remove( document, "mousemove mouseup", drag.handler ); // remove page events	
				if ( dd.dragging ){
					if ( dd.drop !== false && $special.drop )
						$special.drop.handler( event, dd ); // "drop"
					drag.hijack( event, "dragend", dd ); // trigger "dragend"	
				}
				drag.textselect( true ); // enable text selection
				// if suppressing click events...
				if ( dd.click === false && dd.dragging )
					$.data( dd.mousedown, "suppress.click", new Date().getTime() + 5 );
				dd.dragging = drag.touched = false; // deactivate element	
				break;
		}
	},
		
	// re-use event object for custom events
	hijack: function( event, type, dd, x, elem ){
		// not configured
		if ( !dd ) 
			return;
		// remember the original event and type
		var orig = { event:event.originalEvent, type:event.type },
		// is the event drag related or drog related?
		mode = type.indexOf("drop") ? "drag" : "drop",
		// iteration vars
		result, i = x || 0, ia, $elems, callback,
		len = !isNaN( x ) ? x : dd.interactions.length;
		// modify the event type
		event.type = type;
		// remove the original event
		event.originalEvent = null;
		// initialize the results
		dd.results = [];
		// handle each interacted element
		do if ( ia = dd.interactions[ i ] ){
			// validate the interaction
			if ( type !== "dragend" && ia.cancelled )
				continue;
			// set the dragdrop properties on the event object
			callback = drag.properties( event, dd, ia );
			// prepare for more results
			ia.results = [];
			// handle each element
			$( elem || ia[ mode ] || dd.droppable ).each(function( p, subject ){
				// identify drag or drop targets individually
				callback.target = subject;
				// force propagtion of the custom event
				event.isPropagationStopped = function(){ return false; };
				// handle the event	
				result = subject ? $event.dispatch.call( subject, event, callback ) : null;
				// stop the drag interaction for this element
				if ( result === false ){
					if ( mode == "drag" ){
						ia.cancelled = true;
						dd.propagates -= 1;
					}
					if ( type == "drop" ){
						ia[ mode ][p] = null;
					}
				}
				// assign any dropinit elements
				else if ( type == "dropinit" )
					ia.droppable.push( drag.element( result ) || subject );
				// accept a returned proxy element 
				if ( type == "dragstart" )
					ia.proxy = $( drag.element( result ) || ia.drag )[0];
				// remember this result	
				ia.results.push( result );
				// forget the event result, for recycling
				delete event.result;
				// break on cancelled handler
				if ( type !== "dropinit" )
					return result;
			});	
			// flatten the results	
			dd.results[ i ] = drag.flatten( ia.results );	
			// accept a set of valid drop targets
			if ( type == "dropinit" )
				ia.droppable = drag.flatten( ia.droppable );
			// locate drop targets
			if ( type == "dragstart" && !ia.cancelled )
				callback.update(); 
		}
		while ( ++i < len )
		// restore the original event & type
		event.type = orig.type;
		event.originalEvent = orig.event;
		// return all handler results
		return drag.flatten( dd.results );
	},
		
	// extend the callback object with drag/drop properties...
	properties: function( event, dd, ia ){		
		var obj = ia.callback;
		// elements
		obj.drag = ia.drag;
		obj.proxy = ia.proxy || ia.drag;
		// starting mouse position
		obj.startX = dd.pageX;
		obj.startY = dd.pageY;
		// current distance dragged
		obj.deltaX = event.pageX - dd.pageX;
		obj.deltaY = event.pageY - dd.pageY;
		// original element position
		obj.originalX = ia.offset.left;
		obj.originalY = ia.offset.top;
		// adjusted element position
		obj.offsetX = obj.originalX + obj.deltaX; 
		obj.offsetY = obj.originalY + obj.deltaY;
		// assign the drop targets information
		obj.drop = drag.flatten( ( ia.drop || [] ).slice() );
		obj.available = drag.flatten( ( ia.droppable || [] ).slice() );
		return obj;	
	},
	
	// determine is the argument is an element or jquery instance
	element: function( arg ){
		if ( arg && ( arg.jquery || arg.nodeType == 1 ) )
			return arg;
	},
	
	// flatten nested jquery objects and arrays into a single dimension array
	flatten: function( arr ){
		return $.map( arr, function( member ){
			return member && member.jquery ? $.makeArray( member ) : 
				member && member.length ? drag.flatten( member ) : member;
		});
	},
	
	// toggles text selection attributes ON (true) or OFF (false)
	textselect: function( bool ){ 
		$( document )[ bool ? "unbind" : "bind" ]("selectstart", drag.dontstart )
			.css("MozUserSelect", bool ? "" : "none" );
		// .attr("unselectable", bool ? "off" : "on" )
		document.unselectable = bool ? "off" : "on"; 
	},
	
	// suppress "selectstart" and "ondragstart" events
	dontstart: function(){ 
		return false; 
	},
	
	// a callback instance contructor
	callback: function(){}
	
};

// callback methods
drag.callback.prototype = {
	update: function(){
		if ( $special.drop && this.available.length )
			$.each( this.available, function( i ){
				$special.drop.locate( this, i );
			});
	}
};

// patch $.event.$dispatch to allow suppressing clicks
var $dispatch = $event.dispatch;
$event.dispatch = function( event ){
	if ( $.data( this, "suppress."+ event.type ) - new Date().getTime() > 0 ){
		$.removeData( this, "suppress."+ event.type );
		return;
	}
	return $dispatch.apply( this, arguments );
};

// event fix hooks for touch events...
var touchHooks = 
$event.fixHooks.touchstart = 
$event.fixHooks.touchmove = 
$event.fixHooks.touchend =
$event.fixHooks.touchcancel = {
	props: "clientX clientY pageX pageY screenX screenY".split( " " ),
	filter: function( event, orig ) {
		if ( orig ){
			var touched = ( orig.touches && orig.touches[0] )
				|| ( orig.changedTouches && orig.changedTouches[0] )
				|| null; 
			// iOS webkit: touchstart, touchmove, touchend
			if ( touched ) 
				$.each( touchHooks.props, function( i, prop ){
					event[ prop ] = touched[ prop ];
				});
		}
		return event;
	}
};

// share the same special event configuration with related events...
$special.draginit = $special.dragstart = $special.dragend = drag;

})( jQuery );
/*! 
 * jquery.event.drop - v 2.2
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
// Created: 2008-06-04 
// Updated: 2012-05-21
// REQUIRES: jquery 1.7.x, event.drag 2.2

;(function($){ // secure $ jQuery alias

// Events: drop, dropstart, dropend

// add the jquery instance method
$.fn.drop = function( str, arg, opts ){
	// figure out the event type
	var type = typeof str == "string" ? str : "",
	// figure out the event handler...
	fn = $.isFunction( str ) ? str : $.isFunction( arg ) ? arg : null;
	// fix the event type
	if ( type.indexOf("drop") !== 0 ) 
		type = "drop"+ type;
	// were options passed
	opts = ( str == fn ? arg : opts ) || {};
	// trigger or bind event handler
	return fn ? this.bind( type, opts, fn ) : this.trigger( type );
};

// DROP MANAGEMENT UTILITY
// returns filtered drop target elements, caches their positions
$.drop = function( opts ){ 
	opts = opts || {};
	// safely set new options...
	drop.multi = opts.multi === true ? Infinity : 
		opts.multi === false ? 1 : !isNaN( opts.multi ) ? opts.multi : drop.multi;
	drop.delay = opts.delay || drop.delay;
	drop.tolerance = $.isFunction( opts.tolerance ) ? opts.tolerance : 
		opts.tolerance === null ? null : drop.tolerance;
	drop.mode = opts.mode || drop.mode || 'intersect';
};

// local refs (increase compression)
var $event = $.event, 
$special = $event.special,
// configure the drop special event
drop = $.event.special.drop = {

	// these are the default settings
	multi: 1, // allow multiple drop winners per dragged element
	delay: 20, // async timeout delay
	mode: 'overlap', // drop tolerance mode
		
	// internal cache
	targets: [], 
	
	// the key name for stored drop data
	datakey: "dropdata",
		
	// prevent bubbling for better performance
	noBubble: true,
	
	// count bound related events
	add: function( obj ){ 
		// read the interaction data
		var data = $.data( this, drop.datakey );
		// count another realted event
		data.related += 1;
	},
	
	// forget unbound related events
	remove: function(){
		$.data( this, drop.datakey ).related -= 1;
	},
	
	// configure the interactions
	setup: function(){
		// check for related events
		if ( $.data( this, drop.datakey ) ) 
			return;
		// initialize the drop element data
		var data = { 
			related: 0,
			active: [],
			anyactive: 0,
			winner: 0,
			location: {}
		};
		// store the drop data on the element
		$.data( this, drop.datakey, data );
		// store the drop target in internal cache
		drop.targets.push( this );
	},
	
	// destroy the configure interaction	
	teardown: function(){ 
		var data = $.data( this, drop.datakey ) || {};
		// check for related events
		if ( data.related ) 
			return;
		// remove the stored data
		$.removeData( this, drop.datakey );
		// reference the targeted element
		var element = this;
		// remove from the internal cache
		drop.targets = $.grep( drop.targets, function( target ){ 
			return ( target !== element ); 
		});
	},
	
	// shared event handler
	handler: function( event, dd ){ 
		// local vars
		var results, $targets;
		// make sure the right data is available
		if ( !dd ) 
			return;
		// handle various events
		switch ( event.type ){
			// draginit, from $.event.special.drag
			case 'mousedown': // DROPINIT >>
			case 'touchstart': // DROPINIT >>
				// collect and assign the drop targets
				$targets =  $( drop.targets );
				if ( typeof dd.drop == "string" )
					$targets = $targets.filter( dd.drop );
				// reset drop data winner properties
				$targets.each(function(){
					var data = $.data( this, drop.datakey );
					data.active = [];
					data.anyactive = 0;
					data.winner = 0;
				});
				// set available target elements
				dd.droppable = $targets;
				// activate drop targets for the initial element being dragged
				$special.drag.hijack( event, "dropinit", dd ); 
				break;
			// drag, from $.event.special.drag
			case 'mousemove': // TOLERATE >>
			case 'touchmove': // TOLERATE >>
				drop.event = event; // store the mousemove event
				if ( !drop.timer )
					// monitor drop targets
					drop.tolerate( dd ); 
				break;
			// dragend, from $.event.special.drag
			case 'mouseup': // DROP >> DROPEND >>
			case 'touchend': // DROP >> DROPEND >>
				drop.timer = clearTimeout( drop.timer ); // delete timer	
				if ( dd.propagates ){
					$special.drag.hijack( event, "drop", dd ); 
					$special.drag.hijack( event, "dropend", dd ); 
				}
				break;
				
		}
	},
		
	// returns the location positions of an element
	locate: function( elem, index ){ 
		var data = $.data( elem, drop.datakey ),
		$elem = $( elem ), 
		posi = $elem.offset() || {}, 
		height = $elem.outerHeight(), 
		width = $elem.outerWidth(),
		location = { 
			elem: elem, 
			width: width, 
			height: height,
			top: posi.top, 
			left: posi.left, 
			right: posi.left + width, 
			bottom: posi.top + height
		};
		// drag elements might not have dropdata
		if ( data ){
			data.location = location;
			data.index = index;
			data.elem = elem;
		}
		return location;
	},
	
	// test the location positions of an element against another OR an X,Y coord
	contains: function( target, test ){ // target { location } contains test [x,y] or { location }
		return ( ( test[0] || test.left ) >= target.left && ( test[0] || test.right ) <= target.right
			&& ( test[1] || test.top ) >= target.top && ( test[1] || test.bottom ) <= target.bottom ); 
	},
	
	// stored tolerance modes
	modes: { // fn scope: "$.event.special.drop" object 
		// target with mouse wins, else target with most overlap wins
		'intersect': function( event, proxy, target ){
			return this.contains( target, [ event.pageX, event.pageY ] ) ? // check cursor
				1e9 : this.modes.overlap.apply( this, arguments ); // check overlap
		},
		// target with most overlap wins	
		'overlap': function( event, proxy, target ){
			// calculate the area of overlap...
			return Math.max( 0, Math.min( target.bottom, proxy.bottom ) - Math.max( target.top, proxy.top ) )
				* Math.max( 0, Math.min( target.right, proxy.right ) - Math.max( target.left, proxy.left ) );
		},
		// proxy is completely contained within target bounds	
		'fit': function( event, proxy, target ){
			return this.contains( target, proxy ) ? 1 : 0;
		},
		// center of the proxy is contained within target bounds	
		'middle': function( event, proxy, target ){
			return this.contains( target, [ proxy.left + proxy.width * .5, proxy.top + proxy.height * .5 ] ) ? 1 : 0;
		}
	},	
	
	// sort drop target cache by by winner (dsc), then index (asc)
	sort: function( a, b ){
		return ( b.winner - a.winner ) || ( a.index - b.index );
	},
		
	// async, recursive tolerance execution
	tolerate: function( dd ){		
		// declare local refs
		var i, drp, drg, data, arr, len, elem,
		// interaction iteration variables
		x = 0, ia, end = dd.interactions.length,
		// determine the mouse coords
		xy = [ drop.event.pageX, drop.event.pageY ],
		// custom or stored tolerance fn
		tolerance = drop.tolerance || drop.modes[ drop.mode ];
		// go through each passed interaction...
		do if ( ia = dd.interactions[x] ){
			// check valid interaction
			if ( !ia )
				return; 
			// initialize or clear the drop data
			ia.drop = [];
			// holds the drop elements
			arr = []; 
			len = ia.droppable.length;
			// determine the proxy location, if needed
			if ( tolerance )
				drg = drop.locate( ia.proxy ); 
			// reset the loop
			i = 0;
			// loop each stored drop target
			do if ( elem = ia.droppable[i] ){ 
				data = $.data( elem, drop.datakey );
				drp = data.location;
				if ( !drp ) continue;
				// find a winner: tolerance function is defined, call it
				data.winner = tolerance ? tolerance.call( drop, drop.event, drg, drp ) 
					// mouse position is always the fallback
					: drop.contains( drp, xy ) ? 1 : 0; 
				arr.push( data );	
			} while ( ++i < len ); // loop 
			// sort the drop targets
			arr.sort( drop.sort );			
			// reset the loop
			i = 0;
			// loop through all of the targets again
			do if ( data = arr[ i ] ){
				// winners...
				if ( data.winner && ia.drop.length < drop.multi ){
					// new winner... dropstart
					if ( !data.active[x] && !data.anyactive ){
						// check to make sure that this is not prevented
						if ( $special.drag.hijack( drop.event, "dropstart", dd, x, data.elem )[0] !== false ){ 	
							data.active[x] = 1;
							data.anyactive += 1;
						}
						// if false, it is not a winner
						else
							data.winner = 0;
					}
					// if it is still a winner
					if ( data.winner )
						ia.drop.push( data.elem );
				}
				// losers... 
				else if ( data.active[x] && data.anyactive == 1 ){
					// former winner... dropend
					$special.drag.hijack( drop.event, "dropend", dd, x, data.elem ); 
					data.active[x] = 0;
					data.anyactive -= 1;
				}
			} while ( ++i < len ); // loop 		
		} while ( ++x < end ) // loop
		// check if the mouse is still moving or is idle
		if ( drop.last && xy[0] == drop.last.pageX && xy[1] == drop.last.pageY ) 
			delete drop.timer; // idle, don't recurse
		else  // recurse
			drop.timer = setTimeout(function(){ 
				drop.tolerate( dd ); 
			}, drop.delay );
		// remember event, to compare idleness
		drop.last = drop.event; 
	}
	
};

// share the same special event configuration with related events...
$special.dropinit = $special.dropstart = $special.dropend = drop;

})(jQuery); // confine scope	
/* ============================================================================
 * jquery.clearsearch.js v1.0.3
 * https://github.com/waslos/jquery-clearsearch
 * ============================================================================
 * Copyright (c) 2012, Was los.de GmbH & Co. KG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the "Was los.de GmbH & Co. KG" nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ========================================================================= */
(function($) {
	$.fn.clearSearch = function(options) {
		var settings = $.extend({
			'clearClass' : 'clear_input',
			'focusAfterClear' : true,
			'linkText' : '&#10006;'
		}, options);
		return this.each(function() {
					var $this = $(this), btn,
						divClass = settings.clearClass + '_div';

					if (!$this.parent().hasClass(divClass)) {
						$this.wrap('<div style="position: relative;" class="'
							+ divClass + '">' + $this.html() + '</div>');
						$this.after('<a style="position: absolute; cursor: pointer;" class="'
							+ settings.clearClass + '">' + settings.linkText + '</a>');
					}
					btn = $this.next();

					function clearField() {
						$this.val('').change();
						triggerBtn();
						if (settings.focusAfterClear) {
							$this.focus();
						}
						if (typeof (settings.callback) === "function") {
							settings.callback();
						}
					}

					function triggerBtn() {
						if (hasText()) {
							btn.show();
						} else {
							btn.hide();
						}
						update();
					}

					function hasText() {
						return $this.val().replace(/^\s+|\s+$/g, '').length > 0;
					}

					function update() {
						var width = $this.outerWidth(), height = $this
								.outerHeight();
						btn.css({
							top : height / 2 - btn.height() / 2,
							left : width - height / 2 - btn.height() / 2
						});
					}

					btn.on('click', clearField);
					$this.on('keyup keydown change focus', triggerBtn);
					triggerBtn();
				});
	};
})(jQuery);

/*
 FastClick: polyfill to remove click delays on browsers with touch UIs.

 @version 1.0.3
 @codingstandard ftlabs-jsv2
 @copyright The Financial Times Limited [All Rights Reserved]
 @license MIT License (see license.txt)
*/
(function e$$0(g,m,b){function h(f,k){if(!m[f]){if(!g[f]){var a="function"==typeof require&&require;if(!k&&a)return a(f,!0);if(e)return e(f,!0);a=Error("Cannot find module '"+f+"'");throw a.code="MODULE_NOT_FOUND",a;}a=m[f]={exports:{}};g[f][0].call(a.exports,function(a){var d=g[f][1][a];return h(d?d:a)},a,a.exports,e$$0,g,m,b)}return m[f].exports}for(var e="function"==typeof require&&require,k=0;k<b.length;k++)h(b[k]);return h})({1:[function(n,g,m){function b(a,c){function d(a,c){return function(){return a.apply(c,
arguments)}}var l;c=c||{};this.trackingClick=!1;this.trackingClickStart=0;this.targetElement=null;this.lastTouchIdentifier=this.touchStartY=this.touchStartX=0;this.touchBoundary=c.touchBoundary||10;this.layer=a;this.tapDelay=c.tapDelay||200;if(!b.notNeeded(a)){for(var f="onMouse onClick onTouchStart onTouchMove onTouchEnd onTouchCancel".split(" "),e=0,g=f.length;e<g;e++)this[f[e]]=d(this[f[e]],this);h&&(a.addEventListener("mouseover",this.onMouse,!0),a.addEventListener("mousedown",this.onMouse,!0),
a.addEventListener("mouseup",this.onMouse,!0));a.addEventListener("click",this.onClick,!0);a.addEventListener("touchstart",this.onTouchStart,!1);a.addEventListener("touchmove",this.onTouchMove,!1);a.addEventListener("touchend",this.onTouchEnd,!1);a.addEventListener("touchcancel",this.onTouchCancel,!1);Event.prototype.stopImmediatePropagation||(a.removeEventListener=function(c,d,b){var l=Node.prototype.removeEventListener;"click"===c?l.call(a,c,d.hijacked||d,b):l.call(a,c,d,b)},a.addEventListener=
function(c,d,b){var l=Node.prototype.addEventListener;"click"===c?l.call(a,c,d.hijacked||(d.hijacked=function(a){a.propagationStopped||d(a)}),b):l.call(a,c,d,b)});"function"===typeof a.onclick&&(l=a.onclick,a.addEventListener("click",function(a){l(a)},!1),a.onclick=null)}}var h=0<navigator.userAgent.indexOf("Android"),e=/iP(ad|hone|od)/.test(navigator.userAgent),k=e&&/OS 4_\d(_\d)?/.test(navigator.userAgent),f=e&&/OS ([6-9]|\d{2})_\d/.test(navigator.userAgent),p=0<navigator.userAgent.indexOf("BB10");
b.prototype.needsClick=function(a){switch(a.nodeName.toLowerCase()){case "button":case "select":case "textarea":if(a.disabled)return!0;break;case "input":if(e&&"file"===a.type||a.disabled)return!0;break;case "label":case "video":return!0}return/\bneedsclick\b/.test(a.className)};b.prototype.needsFocus=function(a){switch(a.nodeName.toLowerCase()){case "textarea":return!0;case "select":return!h;case "input":switch(a.type){case "button":case "checkbox":case "file":case "image":case "radio":case "submit":return!1}return!a.disabled&&
!a.readOnly;default:return/\bneedsfocus\b/.test(a.className)}};b.prototype.sendClick=function(a,c){var d,b;document.activeElement&&document.activeElement!==a&&document.activeElement.blur();b=c.changedTouches[0];d=document.createEvent("MouseEvents");d.initMouseEvent(this.determineEventType(a),!0,!0,window,1,b.screenX,b.screenY,b.clientX,b.clientY,!1,!1,!1,!1,0,null);d.forwardedTouchEvent=!0;a.dispatchEvent(d)};b.prototype.determineEventType=function(a){return h&&"select"===a.tagName.toLowerCase()?
"mousedown":"click"};b.prototype.focus=function(a){var c;e&&a.setSelectionRange&&0!==a.type.indexOf("date")&&"time"!==a.type?(c=a.value.length,a.setSelectionRange(c,c)):a.focus()};b.prototype.updateScrollParent=function(a){var c,d;c=a.fastClickScrollParent;if(!c||!c.contains(a)){d=a;do{if(d.scrollHeight>d.offsetHeight){c=d;a.fastClickScrollParent=d;break}d=d.parentElement}while(d)}c&&(c.fastClickLastScrollTop=c.scrollTop)};b.prototype.getTargetElementFromEventTarget=function(a){return a.nodeType===
Node.TEXT_NODE?a.parentNode:a};b.prototype.onTouchStart=function(a){var c,d,b;if(1<a.targetTouches.length)return!0;c=this.getTargetElementFromEventTarget(a.target);d=a.targetTouches[0];if(e){b=window.getSelection();if(b.rangeCount&&!b.isCollapsed)return!0;if(!k){if(d.identifier&&d.identifier===this.lastTouchIdentifier)return a.preventDefault(),!1;this.lastTouchIdentifier=d.identifier;this.updateScrollParent(c)}}this.trackingClick=!0;this.trackingClickStart=a.timeStamp;this.targetElement=c;this.touchStartX=
d.pageX;this.touchStartY=d.pageY;a.timeStamp-this.lastClickTime<this.tapDelay&&a.preventDefault();return!0};b.prototype.touchHasMoved=function(a){a=a.changedTouches[0];var c=this.touchBoundary;return Math.abs(a.pageX-this.touchStartX)>c||Math.abs(a.pageY-this.touchStartY)>c?!0:!1};b.prototype.onTouchMove=function(a){if(!this.trackingClick)return!0;if(this.targetElement!==this.getTargetElementFromEventTarget(a.target)||this.touchHasMoved(a))this.trackingClick=!1,this.targetElement=null;return!0};b.prototype.findControl=
function(a){return void 0!==a.control?a.control:a.htmlFor?document.getElementById(a.htmlFor):a.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")};b.prototype.onTouchEnd=function(a){var c,d,b=this.targetElement;if(!this.trackingClick)return!0;if(a.timeStamp-this.lastClickTime<this.tapDelay)return this.cancelNextClick=!0;this.cancelNextClick=!1;this.lastClickTime=a.timeStamp;c=this.trackingClickStart;this.trackingClick=!1;this.trackingClickStart=0;
f&&(d=a.changedTouches[0],b=document.elementFromPoint(d.pageX-window.pageXOffset,d.pageY-window.pageYOffset)||b,b.fastClickScrollParent=this.targetElement.fastClickScrollParent);d=b.tagName.toLowerCase();if("label"===d){if(c=this.findControl(b)){this.focus(b);if(h)return!1;b=c}}else if(this.needsFocus(b)){if(100<a.timeStamp-c||e&&window.top!==window&&"input"===d)return this.targetElement=null,!1;this.focus(b);this.sendClick(b,a);e&&"select"===d||(this.targetElement=null,a.preventDefault());return!1}if(e&&
!k&&(c=b.fastClickScrollParent)&&c.fastClickLastScrollTop!==c.scrollTop)return!0;this.needsClick(b)||(a.preventDefault(),this.sendClick(b,a));return!1};b.prototype.onTouchCancel=function(){this.trackingClick=!1;this.targetElement=null};b.prototype.onMouse=function(a){return this.targetElement&&!a.forwardedTouchEvent&&a.cancelable?!this.needsClick(this.targetElement)||this.cancelNextClick?(a.stopImmediatePropagation?a.stopImmediatePropagation():a.propagationStopped=!0,a.stopPropagation(),a.preventDefault(),
!1):!0:!0};b.prototype.onClick=function(a){if(this.trackingClick)return this.targetElement=null,this.trackingClick=!1,!0;if("submit"===a.target.type&&0===a.detail)return!0;a=this.onMouse(a);a||(this.targetElement=null);return a};b.prototype.destroy=function(){var a=this.layer;h&&(a.removeEventListener("mouseover",this.onMouse,!0),a.removeEventListener("mousedown",this.onMouse,!0),a.removeEventListener("mouseup",this.onMouse,!0));a.removeEventListener("click",this.onClick,!0);a.removeEventListener("touchstart",
this.onTouchStart,!1);a.removeEventListener("touchmove",this.onTouchMove,!1);a.removeEventListener("touchend",this.onTouchEnd,!1);a.removeEventListener("touchcancel",this.onTouchCancel,!1)};b.notNeeded=function(a){var b,d;if("undefined"===typeof window.ontouchstart)return!0;if(d=+(/Chrome\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1])if(h){if((b=document.querySelector("meta[name=viewport]"))&&(-1!==b.content.indexOf("user-scalable=no")||31<d&&document.documentElement.scrollWidth<=window.outerWidth))return!0}else return!0;
return p&&(b=navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/),10<=b[1]&&3<=b[2]&&(b=document.querySelector("meta[name=viewport]"))&&(-1!==b.content.indexOf("user-scalable=no")||document.documentElement.scrollWidth<=window.outerWidth))?!0:"none"===a.style.msTouchAction?!0:!1};b.attach=function(a,c){return new b(a,c)};"function"==typeof define&&"object"==typeof define.amd&&define.amd?define(function(){return b}):"undefined"!==typeof g&&g.exports?(g.exports=b.attach,g.exports.FastClick=b):window.FastClick=
b},{}],2:[function(n,g,m){window.Origami={fastclick:n("./bower_components/fastclick/lib/fastclick.js")}},{"./bower_components/fastclick/lib/fastclick.js":1}]},{},[2]);
;document.addEventListener('load',function(){document.dispatchEvent(new CustomEvent('o.load'))});document.addEventListener('DOMContentLoaded',function(){document.dispatchEvent(new CustomEvent('o.DOMContentLoaded'))})

/*!
 * Bootstrap v3.2.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.2.0",d.prototype.close=function(b){function c(){f.detach().trigger("closed.bs.alert").remove()}var d=a(this),e=d.attr("data-target");e||(e=d.attr("href"),e=e&&e.replace(/.*(?=#[^\s]*$)/,""));var f=a(e);b&&b.preventDefault(),f.length||(f=d.hasClass("alert")?d:d.parent()),f.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",c).emulateTransitionEnd(150):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.2.0",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),d[e](null==f[b]?this.options[b]:f[b]),setTimeout(a.proxy(function(){"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}a&&this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),c.preventDefault()})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b).on("keydown.bs.carousel",a.proxy(this.keydown,this)),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=this.sliding=this.interval=this.$active=this.$items=null,"hover"==this.options.pause&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.2.0",c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0},c.prototype.keydown=function(a){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.to=function(b){var c=this,d=this.getItemIndex(this.$active=this.$element.find(".item.active"));return b>this.$items.length-1||0>b?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){c.to(b)}):d==b?this.pause().cycle():this.slide(b>d?"next":"prev",a(this.$items[b]))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,c){var d=this.$element.find(".item.active"),e=c||d[b](),f=this.interval,g="next"==b?"left":"right",h="next"==b?"first":"last",i=this;if(!e.length){if(!this.options.wrap)return;e=this.$element.find(".item")[h]()}if(e.hasClass("active"))return this.sliding=!1;var j=e[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:g});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,f&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(e)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:g});return a.support.transition&&this.$element.hasClass("slide")?(e.addClass(b),e[0].offsetWidth,d.addClass(g),e.addClass(g),d.one("bsTransitionEnd",function(){e.removeClass([b,g].join(" ")).addClass("active"),d.removeClass(["active",g].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(1e3*d.css("transition-duration").slice(0,-1))):(d.removeClass("active"),e.addClass("active"),this.sliding=!1,this.$element.trigger(m)),f&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this},a(document).on("click.bs.carousel.data-api","[data-slide], [data-slide-to]",function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}}),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.collapse"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b);!e&&f.toggle&&"show"==b&&(b=!b),e||d.data("bs.collapse",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.transitioning=null,this.options.parent&&(this.$parent=a(this.options.parent)),this.options.toggle&&this.toggle()};c.VERSION="3.2.0",c.DEFAULTS={toggle:!0},c.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},c.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var c=a.Event("show.bs.collapse");if(this.$element.trigger(c),!c.isDefaultPrevented()){var d=this.$parent&&this.$parent.find("> .panel > .in");if(d&&d.length){var e=d.data("bs.collapse");if(e&&e.transitioning)return;b.call(d,"hide"),e||d.data("bs.collapse",null)}var f=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[f](0),this.transitioning=1;var g=function(){this.$element.removeClass("collapsing").addClass("collapse in")[f](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return g.call(this);var h=a.camelCase(["scroll",f].join("-"));this.$element.one("bsTransitionEnd",a.proxy(g,this)).emulateTransitionEnd(350)[f](this.$element[0][h])}}},c.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse").removeClass("in"),this.transitioning=1;var d=function(){this.transitioning=0,this.$element.trigger("hidden.bs.collapse").removeClass("collapsing").addClass("collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(d,this)).emulateTransitionEnd(350):d.call(this)}}},c.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()};var d=a.fn.collapse;a.fn.collapse=b,a.fn.collapse.Constructor=c,a.fn.collapse.noConflict=function(){return a.fn.collapse=d,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(c){var d,e=a(this),f=e.attr("data-target")||c.preventDefault()||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""),g=a(f),h=g.data("bs.collapse"),i=h?"toggle":e.data(),j=e.attr("data-parent"),k=j&&a(j);h&&h.transitioning||(k&&k.find('[data-toggle="collapse"][data-parent="'+j+'"]').not(e).addClass("collapsed"),e[g.hasClass("in")?"addClass":"removeClass"]("collapsed")),b.call(g,i)})}(jQuery),+function(a){"use strict";function b(b){b&&3===b.which||(a(e).remove(),a(f).each(function(){var d=c(a(this)),e={relatedTarget:this};d.hasClass("open")&&(d.trigger(b=a.Event("hide.bs.dropdown",e)),b.isDefaultPrevented()||d.removeClass("open").trigger("hidden.bs.dropdown",e))}))}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.2.0",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(b){if(/(38|40|27)/.test(b.keyCode)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var e=c(d),g=e.hasClass("open");if(!g||g&&27==b.keyCode)return 27==b.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.divider):visible a",i=e.find('[role="menu"]'+h+', [role="listbox"]'+h);if(i.length){var j=i.index(i.filter(":focus"));38==b.keyCode&&j>0&&j--,40==b.keyCode&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f+', [role="menu"], [role="listbox"]',g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$backdrop=this.isShown=null,this.scrollbarWidth=0,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.2.0",c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var c=this,d=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(d),this.isShown||d.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.$body.addClass("modal-open"),this.setScrollbar(),this.escape(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.backdrop(function(){var d=a.support.transition&&c.$element.hasClass("fade");c.$element.parent().length||c.$element.appendTo(c.$body),c.$element.show().scrollTop(0),d&&c.$element[0].offsetWidth,c.$element.addClass("in").attr("aria-hidden",!1),c.enforceFocus();var e=a.Event("shown.bs.modal",{relatedTarget:b});d?c.$element.find(".modal-dialog").one("bsTransitionEnd",function(){c.$element.trigger("focus").trigger(e)}).emulateTransitionEnd(300):c.$element.trigger("focus").trigger(e)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.$body.removeClass("modal-open"),this.resetScrollbar(),this.escape(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(300):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keyup.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keyup.dismiss.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var c=this,d=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var e=a.support.transition&&d;if(this.$backdrop=a('<div class="modal-backdrop '+d+'" />').appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus.call(this.$element[0]):this.hide.call(this))},this)),e&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;e?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(150):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var f=function(){c.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",f).emulateTransitionEnd(150):f()}else b&&b()},c.prototype.checkScrollbar=function(){document.body.clientWidth>=window.innerWidth||(this.scrollbarWidth=this.scrollbarWidth||this.measureScrollbar())},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.scrollbarWidth&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right","")},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||"destroy"!=b)&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=this.options=this.enabled=this.timeout=this.hoverState=this.$element=null,this.init("tooltip",a,b)};c.VERSION="3.2.0",c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(this.options.viewport.selector||this.options.viewport);for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show()},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var c=a.contains(document.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!c)return;var d=this,e=this.tip(),f=this.getUID(this.type);this.setContent(),e.attr("id",f),this.$element.attr("aria-describedby",f),this.options.animation&&e.addClass("fade");var g="function"==typeof this.options.placement?this.options.placement.call(this,e[0],this.$element[0]):this.options.placement,h=/\s?auto?\s?/i,i=h.test(g);i&&(g=g.replace(h,"")||"top"),e.detach().css({top:0,left:0,display:"block"}).addClass(g).data("bs."+this.type,this),this.options.container?e.appendTo(this.options.container):e.insertAfter(this.$element);var j=this.getPosition(),k=e[0].offsetWidth,l=e[0].offsetHeight;if(i){var m=g,n=this.$element.parent(),o=this.getPosition(n);g="bottom"==g&&j.top+j.height+l-o.scroll>o.height?"top":"top"==g&&j.top-o.scroll-l<0?"bottom":"right"==g&&j.right+k>o.width?"left":"left"==g&&j.left-k<o.left?"right":g,e.removeClass(m).addClass(g)}var p=this.getCalculatedOffset(g,j,k,l);this.applyPlacement(p,g);var q=function(){d.$element.trigger("shown.bs."+d.type),d.hoverState=null};a.support.transition&&this.$tip.hasClass("fade")?e.one("bsTransitionEnd",q).emulateTransitionEnd(150):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top=b.top+g,b.left=b.left+h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=k.left?2*k.left-e+i:2*k.top-f+j,m=k.left?"left":"top",n=k.left?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(l,d[0][n],m)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c,a?50*(1-a/b)+"%":"")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(){function b(){"in"!=c.hoverState&&d.detach(),c.$element.trigger("hidden.bs."+c.type)}var c=this,d=this.tip(),e=a.Event("hide.bs."+this.type);return this.$element.removeAttr("aria-describedby"),this.$element.trigger(e),e.isDefaultPrevented()?void 0:(d.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?d.one("bsTransitionEnd",b).emulateTransitionEnd(150):b(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName;return a.extend({},"function"==typeof c.getBoundingClientRect?c.getBoundingClientRect():null,{scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop(),width:d?a(window).width():b.outerWidth(),height:d?a(window).height():b.outerHeight()},d?{top:0,left:0}:b.offset())},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.width&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.validate=function(){this.$element[0].parentNode||(this.hide(),this.$element=null,this.options=null)},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){clearTimeout(this.timeout),this.hide().$element.off("."+this.type).removeData("bs."+this.type)};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||"destroy"!=b)&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.2.0",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").empty()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")},c.prototype.tip=function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){var e=a.proxy(this.process,this);this.$body=a("body"),this.$scrollElement=a(a(c).is("body")?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",e),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.2.0",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b="offset",c=0;a.isWindow(this.$scrollElement[0])||(b="position",c=this.$scrollElement.scrollTop()),this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight();var d=this;this.$body.find(this.selector).map(function(){var d=a(this),e=d.data("target")||d.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[b]().top+c,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){d.offsets.push(this[0]),d.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<=e[0])return g!=(a=f[0])&&this.activate(a);for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(!e[a+1]||b<=e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,a(this.selector).parentsUntil(this.options.target,".active").removeClass("active");var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.2.0",c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a")[0],f=a.Event("show.bs.tab",{relatedTarget:e});if(b.trigger(f),!f.isDefaultPrevented()){var g=a(d);this.activate(b.closest("li"),c),this.activate(g,g.parent(),function(){b.trigger({type:"shown.bs.tab",relatedTarget:e})})}}},c.prototype.activate=function(b,c,d){function e(){f.removeClass("active").find("> .dropdown-menu > .active").removeClass("active"),b.addClass("active"),g?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu")&&b.closest("li.dropdown").addClass("active"),d&&d()}var f=c.find("> .active"),g=d&&a.support.transition&&f.hasClass("fade");g?f.one("bsTransitionEnd",e).emulateTransitionEnd(150):e(),f.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this},a(document).on("click.bs.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"]',function(c){c.preventDefault(),b.call(a(this),"show")})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=this.unpin=this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.2.0",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=a(document).height(),d=this.$target.scrollTop(),e=this.$element.offset(),f=this.options.offset,g=f.top,h=f.bottom;"object"!=typeof f&&(h=g=f),"function"==typeof g&&(g=f.top(this.$element)),"function"==typeof h&&(h=f.bottom(this.$element));var i=null!=this.unpin&&d+this.unpin<=e.top?!1:null!=h&&e.top+this.$element.height()>=b-h?"bottom":null!=g&&g>=d?"top":!1;if(this.affixed!==i){null!=this.unpin&&this.$element.css("top","");var j="affix"+(i?"-"+i:""),k=a.Event(j+".bs.affix");this.$element.trigger(k),k.isDefaultPrevented()||(this.affixed=i,this.unpin="bottom"==i?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(j).trigger(a.Event(j.replace("affix","affixed"))),"bottom"==i&&this.$element.offset({top:b-this.$element.height()-h}))}}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},d.offsetBottom&&(d.offset.bottom=d.offsetBottom),d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
/* =========================================================
 * bootstrap-datepicker.js
 * Repo: https://github.com/eternicode/bootstrap-datepicker/
 * Demo: http://eternicode.github.io/bootstrap-datepicker/
 * Docs: http://bootstrap-datepicker.readthedocs.org/
 * Forked from http://www.eyecon.ro/bootstrap-datepicker
 * =========================================================
 * Started by Stefan Petre; improvements by Andrew Rowls + contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

(function($, undefined){

	var $window = $(window);

	function UTCDate(){
		return new Date(Date.UTC.apply(Date, arguments));
	}
	function UTCToday(){
		var today = new Date();
		return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
	}
	function alias(method){
		return function(){
			return this[method].apply(this, arguments);
		};
	}

	var DateArray = (function(){
		var extras = {
			get: function(i){
				return this.slice(i)[0];
			},
			contains: function(d){
				// Array.indexOf is not cross-browser;
				// $.inArray doesn't work with Dates
				var val = d && d.valueOf();
				for (var i=0, l=this.length; i < l; i++)
					if (this[i].valueOf() === val)
						return i;
				return -1;
			},
			remove: function(i){
				this.splice(i,1);
			},
			replace: function(new_array){
				if (!new_array)
					return;
				if (!$.isArray(new_array))
					new_array = [new_array];
				this.clear();
				this.push.apply(this, new_array);
			},
			clear: function(){
				this.length = 0;
			},
			copy: function(){
				var a = new DateArray();
				a.replace(this);
				return a;
			}
		};

		return function(){
			var a = [];
			a.push.apply(a, arguments);
			$.extend(a, extras);
			return a;
		};
	})();


	// Picker object

	var Datepicker = function(element, options){
		this.dates = new DateArray();
		this.viewDate = UTCToday();
		this.focusDate = null;

		this._process_options(options);

		this.element = $(element);
		this.isInline = false;
		this.isInput = this.element.is('input');
		this.component = this.element.is('.date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
		this.hasInput = this.component && this.element.find('input').length;
		if (this.component && this.component.length === 0)
			this.component = false;

		this.picker = $(DPGlobal.template);
		this._buildEvents();
		this._attachEvents();

		if (this.isInline){
			this.picker.addClass('datepicker-inline').appendTo(this.element);
		}
		else {
			this.picker.addClass('datepicker-dropdown dropdown-menu');
		}

		if (this.o.rtl){
			this.picker.addClass('datepicker-rtl');
		}

		this.viewMode = this.o.startView;

		if (this.o.calendarWeeks)
			this.picker.find('tfoot th.today')
						.attr('colspan', function(i, val){
							return parseInt(val) + 1;
						});

		this._allow_update = false;

		this.setStartDate(this._o.startDate);
		this.setEndDate(this._o.endDate);
		this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);

		this.fillDow();
		this.fillMonths();

		this._allow_update = true;

		this.update();
		this.showMode();

		if (this.isInline){
			this.show();
		}
	};

	Datepicker.prototype = {
		constructor: Datepicker,

		_process_options: function(opts){
			// Store raw options for reference
			this._o = $.extend({}, this._o, opts);
			// Processed options
			var o = this.o = $.extend({}, this._o);

			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			var lang = o.language;
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					lang = defaults.language;
			}
			o.language = lang;

			switch (o.startView){
				case 2:
				case 'decade':
					o.startView = 2;
					break;
				case 1:
				case 'year':
					o.startView = 1;
					break;
				default:
					o.startView = 0;
			}

			switch (o.minViewMode){
				case 1:
				case 'months':
					o.minViewMode = 1;
					break;
				case 2:
				case 'years':
					o.minViewMode = 2;
					break;
				default:
					o.minViewMode = 0;
			}

			o.startView = Math.max(o.startView, o.minViewMode);

			// true, false, or Number > 0
			if (o.multidate !== true){
				o.multidate = Number(o.multidate) || false;
				if (o.multidate !== false)
					o.multidate = Math.max(0, o.multidate);
				else
					o.multidate = 1;
			}
			o.multidateSeparator = String(o.multidateSeparator);

			o.weekStart %= 7;
			o.weekEnd = ((o.weekStart + 6) % 7);

			var format = DPGlobal.parseFormat(o.format);
			if (o.startDate !== -Infinity){
				if (!!o.startDate){
					if (o.startDate instanceof Date)
						o.startDate = this._local_to_utc(this._zero_time(o.startDate));
					else
						o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
				}
				else {
					o.startDate = -Infinity;
				}
			}
			if (o.endDate !== Infinity){
				if (!!o.endDate){
					if (o.endDate instanceof Date)
						o.endDate = this._local_to_utc(this._zero_time(o.endDate));
					else
						o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
				}
				else {
					o.endDate = Infinity;
				}
			}

			o.daysOfWeekDisabled = o.daysOfWeekDisabled||[];
			if (!$.isArray(o.daysOfWeekDisabled))
				o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
			o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function(d){
				return parseInt(d, 10);
			});

			var plc = String(o.orientation).toLowerCase().split(/\s+/g),
				_plc = o.orientation.toLowerCase();
			plc = $.grep(plc, function(word){
				return (/^auto|left|right|top|bottom$/).test(word);
			});
			o.orientation = {x: 'auto', y: 'auto'};
			if (!_plc || _plc === 'auto')
				; // no action
			else if (plc.length === 1){
				switch (plc[0]){
					case 'top':
					case 'bottom':
						o.orientation.y = plc[0];
						break;
					case 'left':
					case 'right':
						o.orientation.x = plc[0];
						break;
				}
			}
			else {
				_plc = $.grep(plc, function(word){
					return (/^left|right$/).test(word);
				});
				o.orientation.x = _plc[0] || 'auto';

				_plc = $.grep(plc, function(word){
					return (/^top|bottom$/).test(word);
				});
				o.orientation.y = _plc[0] || 'auto';
			}
		},
		_events: [],
		_secondaryEvents: [],
		_applyEvents: function(evs){
			for (var i=0, el, ch, ev; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.on(ev, ch);
			}
		},
		_unapplyEvents: function(evs){
			for (var i=0, el, ev, ch; i < evs.length; i++){
				el = evs[i][0];
				if (evs[i].length === 2){
					ch = undefined;
					ev = evs[i][1];
				}
				else if (evs[i].length === 3){
					ch = evs[i][1];
					ev = evs[i][2];
				}
				el.off(ev, ch);
			}
		},
		_buildEvents: function(){
			if (this.isInput){ // single input
				this._events = [
					[this.element, {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update();
						}, this),
						keydown: $.proxy(this.keydown, this)
					}]
				];
			}
			else if (this.component && this.hasInput){ // component: input + button
				this._events = [
					// For components that are not readonly, allow keyboard nav
					[this.element.find('input'), {
						focus: $.proxy(this.show, this),
						keyup: $.proxy(function(e){
							if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
								this.update();
						}, this),
						keydown: $.proxy(this.keydown, this)
					}],
					[this.component, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			else if (this.element.is('div')){  // inline datepicker
				this.isInline = true;
			}
			else {
				this._events = [
					[this.element, {
						click: $.proxy(this.show, this)
					}]
				];
			}
			this._events.push(
				// Component: listen for blur on element descendants
				[this.element, '*', {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}],
				// Input: listen for blur on element
				[this.element, {
					blur: $.proxy(function(e){
						this._focused_from = e.target;
					}, this)
				}]
			);

			this._secondaryEvents = [
				[this.picker, {
					click: $.proxy(this.click, this)
				}],
				[$(window), {
					resize: $.proxy(this.place, this)
				}],
				[$(document), {
					'mousedown touchstart': $.proxy(function(e){
						// Clicked outside the datepicker, hide it
						if (!(
							this.element.is(e.target) ||
							this.element.find(e.target).length ||
							this.picker.is(e.target) ||
							this.picker.find(e.target).length
						)){
							this.hide();
						}
					}, this)
				}]
			];
		},
		_attachEvents: function(){
			this._detachEvents();
			this._applyEvents(this._events);
		},
		_detachEvents: function(){
			this._unapplyEvents(this._events);
		},
		_attachSecondaryEvents: function(){
			this._detachSecondaryEvents();
			this._applyEvents(this._secondaryEvents);
		},
		_detachSecondaryEvents: function(){
			this._unapplyEvents(this._secondaryEvents);
		},
		_trigger: function(event, altdate){
			var date = altdate || this.dates.get(-1),
				local_date = this._utc_to_local(date);

			this.element.trigger({
				type: event,
				date: local_date,
				dates: $.map(this.dates, this._utc_to_local),
				format: $.proxy(function(ix, format){
					if (arguments.length === 0){
						ix = this.dates.length - 1;
						format = this.o.format;
					}
					else if (typeof ix === 'string'){
						format = ix;
						ix = this.dates.length - 1;
					}
					format = format || this.o.format;
					var date = this.dates.get(ix);
					return DPGlobal.formatDate(date, format, this.o.language);
				}, this)
			});
		},

		show: function(){
			if (!this.isInline)
				this.picker.appendTo('body');
			this.picker.show();
			this.place();
			this._attachSecondaryEvents();
			this._trigger('show');
		},

		hide: function(){
			if (this.isInline)
				return;
			if (!this.picker.is(':visible'))
				return;
			this.focusDate = null;
			this.picker.hide().detach();
			this._detachSecondaryEvents();
			this.viewMode = this.o.startView;
			this.showMode();

			if (
				this.o.forceParse &&
				(
					this.isInput && this.element.val() ||
					this.hasInput && this.element.find('input').val()
				)
			)
				this.setValue();
			this._trigger('hide');
		},

		remove: function(){
			this.hide();
			this._detachEvents();
			this._detachSecondaryEvents();
			this.picker.remove();
			delete this.element.data().datepicker;
			if (!this.isInput){
				delete this.element.data().date;
			}
		},

		_utc_to_local: function(utc){
			return utc && new Date(utc.getTime() + (utc.getTimezoneOffset()*60000));
		},
		_local_to_utc: function(local){
			return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
		},
		_zero_time: function(local){
			return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
		},
		_zero_utc_time: function(utc){
			return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
		},

		getDates: function(){
			return $.map(this.dates, this._utc_to_local);
		},

		getUTCDates: function(){
			return $.map(this.dates, function(d){
				return new Date(d);
			});
		},

		getDate: function(){
			return this._utc_to_local(this.getUTCDate());
		},

		getUTCDate: function(){
			return new Date(this.dates.get(-1));
		},

		setDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, args);
			this._trigger('changeDate');
			this.setValue();
		},

		setUTCDates: function(){
			var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
			this.update.apply(this, $.map(args, this._utc_to_local));
			this._trigger('changeDate');
			this.setValue();
		},

		setDate: alias('setDates'),
		setUTCDate: alias('setUTCDates'),

		setValue: function(){
			var formatted = this.getFormattedDate();
			if (!this.isInput){
				if (this.component){
					this.element.find('input').val(formatted).change();
				}
			}
			else {
				this.element.val(formatted).change();
			}
		},

		getFormattedDate: function(format){
			if (format === undefined)
				format = this.o.format;

			var lang = this.o.language;
			return $.map(this.dates, function(d){
				return DPGlobal.formatDate(d, format, lang);
			}).join(this.o.multidateSeparator);
		},

		setStartDate: function(startDate){
			this._process_options({startDate: startDate});
			this.update();
			this.updateNavArrows();
		},

		setEndDate: function(endDate){
			this._process_options({endDate: endDate});
			this.update();
			this.updateNavArrows();
		},

		setDaysOfWeekDisabled: function(daysOfWeekDisabled){
			this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
			this.update();
			this.updateNavArrows();
		},

		place: function(){
			if (this.isInline)
				return;
			var calendarWidth = this.picker.outerWidth(),
				calendarHeight = this.picker.outerHeight(),
				visualPadding = 10,
				windowWidth = $window.width(),
				windowHeight = $window.height(),
				scrollTop = $window.scrollTop();

			var zIndex = parseInt(this.element.parents().filter(function(){
					return $(this).css('z-index') !== 'auto';
				}).first().css('z-index'))+10;
			var offset = this.component ? this.component.parent().offset() : this.element.offset();
			var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
			var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
			var left = offset.left,
				top = offset.top;

			this.picker.removeClass(
				'datepicker-orient-top datepicker-orient-bottom '+
				'datepicker-orient-right datepicker-orient-left'
			);

			if (this.o.orientation.x !== 'auto'){
				this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
				if (this.o.orientation.x === 'right')
					left -= calendarWidth - width;
			}
			// auto x orientation is best-placement: if it crosses a window
			// edge, fudge it sideways
			else {
				// Default to left
				this.picker.addClass('datepicker-orient-left');
				if (offset.left < 0)
					left -= offset.left - visualPadding;
				else if (offset.left + calendarWidth > windowWidth)
					left = windowWidth - calendarWidth - visualPadding;
			}

			// auto y orientation is best-situation: top or bottom, no fudging,
			// decision based on which shows more of the calendar
			var yorient = this.o.orientation.y,
				top_overflow, bottom_overflow;
			if (yorient === 'auto'){
				top_overflow = -scrollTop + offset.top - calendarHeight;
				bottom_overflow = scrollTop + windowHeight - (offset.top + height + calendarHeight);
				if (Math.max(top_overflow, bottom_overflow) === bottom_overflow)
					yorient = 'top';
				else
					yorient = 'bottom';
			}
			this.picker.addClass('datepicker-orient-' + yorient);
			if (yorient === 'top')
				top += height;
			else
				top -= calendarHeight + parseInt(this.picker.css('padding-top'));

			this.picker.css({
				top: top,
				left: left,
				zIndex: zIndex
			});
		},

		_allow_update: true,
		update: function(){
			if (!this._allow_update)
				return;

			var oldDates = this.dates.copy(),
				dates = [],
				fromArgs = false;
			if (arguments.length){
				$.each(arguments, $.proxy(function(i, date){
					if (date instanceof Date)
						date = this._local_to_utc(date);
					dates.push(date);
				}, this));
				fromArgs = true;
			}
			else {
				dates = this.isInput
						? this.element.val()
						: this.element.data('date') || this.element.find('input').val();
				if (dates && this.o.multidate)
					dates = dates.split(this.o.multidateSeparator);
				else
					dates = [dates];
				delete this.element.data().date;
			}

			dates = $.map(dates, $.proxy(function(date){
				return DPGlobal.parseDate(date, this.o.format, this.o.language);
			}, this));
			dates = $.grep(dates, $.proxy(function(date){
				return (
					date < this.o.startDate ||
					date > this.o.endDate ||
					!date
				);
			}, this), true);
			this.dates.replace(dates);

			if (this.dates.length)
				this.viewDate = new Date(this.dates.get(-1));
			else if (this.viewDate < this.o.startDate)
				this.viewDate = new Date(this.o.startDate);
			else if (this.viewDate > this.o.endDate)
				this.viewDate = new Date(this.o.endDate);

			if (fromArgs){
				// setting date by clicking
				this.setValue();
			}
			else if (dates.length){
				// setting date by typing
				if (String(oldDates) !== String(this.dates))
					this._trigger('changeDate');
			}
			if (!this.dates.length && oldDates.length)
				this._trigger('clearDate');

			this.fill();
		},

		fillDow: function(){
			var dowCnt = this.o.weekStart,
				html = '<tr>';
			if (this.o.calendarWeeks){
				var cell = '<th class="cw">&nbsp;</th>';
				html += cell;
				this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);
			}
			while (dowCnt < this.o.weekStart + 7){
				html += '<th class="dow">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
			}
			html += '</tr>';
			this.picker.find('.datepicker-days thead').append(html);
		},

		fillMonths: function(){
			var html = '',
			i = 0;
			while (i < 12){
				html += '<span class="month">'+dates[this.o.language].monthsShort[i++]+'</span>';
			}
			this.picker.find('.datepicker-months td').html(html);
		},

		setRange: function(range){
			if (!range || !range.length)
				delete this.range;
			else
				this.range = $.map(range, function(d){
					return d.valueOf();
				});
			this.fill();
		},

		getClassNames: function(date){
			var cls = [],
				year = this.viewDate.getUTCFullYear(),
				month = this.viewDate.getUTCMonth(),
				today = new Date();
			if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
				cls.push('old');
			}
			else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
				cls.push('new');
			}
			if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
				cls.push('focused');
			// Compare internal UTC date with local today, not UTC today
			if (this.o.todayHighlight &&
				date.getUTCFullYear() === today.getFullYear() &&
				date.getUTCMonth() === today.getMonth() &&
				date.getUTCDate() === today.getDate()){
				cls.push('today');
			}
			if (this.dates.contains(date) !== -1)
				cls.push('active');
			if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||
				$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1){
				cls.push('disabled');
			}
			if (this.range){
				if (date > this.range[0] && date < this.range[this.range.length-1]){
					cls.push('range');
				}
				if ($.inArray(date.valueOf(), this.range) !== -1){
					cls.push('selected');
				}
			}
			return cls;
		},

		fill: function(){
			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth(),
				startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
				startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
				endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
				endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
				todaytxt = dates[this.o.language].today || dates['en'].today || '',
				cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
				tooltip;
			this.picker.find('.datepicker-days thead th.datepicker-switch')
						.text(dates[this.o.language].months[month]+' '+year);
			this.picker.find('tfoot th.today')
						.text(todaytxt)
						.toggle(this.o.todayBtn !== false);
			this.picker.find('tfoot th.clear')
						.text(cleartxt)
						.toggle(this.o.clearBtn !== false);
			this.updateNavArrows();
			this.fillMonths();
			var prevMonth = UTCDate(year, month-1, 28),
				day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
			prevMonth.setUTCDate(day);
			prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
			var nextMonth = new Date(prevMonth);
			nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
			nextMonth = nextMonth.valueOf();
			var html = [];
			var clsName;
			while (prevMonth.valueOf() < nextMonth){
				if (prevMonth.getUTCDay() === this.o.weekStart){
					html.push('<tr>');
					if (this.o.calendarWeeks){
						// ISO 8601: First week contains first thursday.
						// ISO also states week starts on Monday, but we can be more abstract here.
						var
							// Start of current week: based on weekstart/current date
							ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
							// Thursday of this week
							th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
							// First Thursday of year, year from thursday
							yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),
							// Calendar week: ms between thursdays, div ms per day, div 7 days
							calWeek =  (th - yth) / 864e5 / 7 + 1;
						html.push('<td class="cw">'+ calWeek +'</td>');

					}
				}
				clsName = this.getClassNames(prevMonth);
				clsName.push('day');

				if (this.o.beforeShowDay !== $.noop){
					var before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
					if (before === undefined)
						before = {};
					else if (typeof(before) === 'boolean')
						before = {enabled: before};
					else if (typeof(before) === 'string')
						before = {classes: before};
					if (before.enabled === false)
						clsName.push('disabled');
					if (before.classes)
						clsName = clsName.concat(before.classes.split(/\s+/));
					if (before.tooltip)
						tooltip = before.tooltip;
				}

				clsName = $.unique(clsName);
				html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + '>'+prevMonth.getUTCDate() + '</td>');
				if (prevMonth.getUTCDay() === this.o.weekEnd){
					html.push('</tr>');
				}
				prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
			}
			this.picker.find('.datepicker-days tbody').empty().append(html.join(''));

			var months = this.picker.find('.datepicker-months')
						.find('th:eq(1)')
							.text(year)
							.end()
						.find('span').removeClass('active');

			$.each(this.dates, function(i, d){
				if (d.getUTCFullYear() === year)
					months.eq(d.getUTCMonth()).addClass('active');
			});

			if (year < startYear || year > endYear){
				months.addClass('disabled');
			}
			if (year === startYear){
				months.slice(0, startMonth).addClass('disabled');
			}
			if (year === endYear){
				months.slice(endMonth+1).addClass('disabled');
			}

			html = '';
			year = parseInt(year/10, 10) * 10;
			var yearCont = this.picker.find('.datepicker-years')
								.find('th:eq(1)')
									.text(year + '-' + (year + 9))
									.end()
								.find('td');
			year -= 1;
			var years = $.map(this.dates, function(d){
					return d.getUTCFullYear();
				}),
				classes;
			for (var i = -1; i < 11; i++){
				classes = ['year'];
				if (i === -1)
					classes.push('old');
				else if (i === 10)
					classes.push('new');
				if ($.inArray(year, years) !== -1)
					classes.push('active');
				if (year < startYear || year > endYear)
					classes.push('disabled');
				html += '<span class="' + classes.join(' ') + '">'+year+'</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		updateNavArrows: function(){
			if (!this._allow_update)
				return;

			var d = new Date(this.viewDate),
				year = d.getUTCFullYear(),
				month = d.getUTCMonth();
			switch (this.viewMode){
				case 0:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()){
						this.picker.find('.prev').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()){
						this.picker.find('.next').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
				case 1:
				case 2:
					if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()){
						this.picker.find('.prev').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.prev').css({visibility: 'visible'});
					}
					if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()){
						this.picker.find('.next').css({visibility: 'hidden'});
					}
					else {
						this.picker.find('.next').css({visibility: 'visible'});
					}
					break;
			}
		},

		click: function(e){
			e.preventDefault();
			var target = $(e.target).closest('span, td, th'),
				year, month, day;
			if (target.length === 1){
				switch (target[0].nodeName.toLowerCase()){
					case 'th':
						switch (target[0].className){
							case 'datepicker-switch':
								this.showMode(1);
								break;
							case 'prev':
							case 'next':
								var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1);
								switch (this.viewMode){
									case 0:
										this.viewDate = this.moveMonth(this.viewDate, dir);
										this._trigger('changeMonth', this.viewDate);
										break;
									case 1:
									case 2:
										this.viewDate = this.moveYear(this.viewDate, dir);
										if (this.viewMode === 1)
											this._trigger('changeYear', this.viewDate);
										break;
								}
								this.fill();
								break;
							case 'today':
								var date = new Date();
								date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);

								this.showMode(-2);
								var which = this.o.todayBtn === 'linked' ? null : 'view';
								this._setDate(date, which);
								break;
							case 'clear':
								var element;
								if (this.isInput)
									element = this.element;
								else if (this.component)
									element = this.element.find('input');
								if (element)
									element.val("").change();
								this.update();
								this._trigger('changeDate');
								if (this.o.autoclose)
									this.hide();
								break;
						}
						break;
					case 'span':
						if (!target.is('.disabled')){
							this.viewDate.setUTCDate(1);
							if (target.is('.month')){
								day = 1;
								month = target.parent().find('span').index(target);
								year = this.viewDate.getUTCFullYear();
								this.viewDate.setUTCMonth(month);
								this._trigger('changeMonth', this.viewDate);
								if (this.o.minViewMode === 1){
									this._setDate(UTCDate(year, month, day));
								}
							}
							else {
								day = 1;
								month = 0;
								year = parseInt(target.text(), 10)||0;
								this.viewDate.setUTCFullYear(year);
								this._trigger('changeYear', this.viewDate);
								if (this.o.minViewMode === 2){
									this._setDate(UTCDate(year, month, day));
								}
							}
							this.showMode(-1);
							this.fill();
						}
						break;
					case 'td':
						if (target.is('.day') && !target.is('.disabled')){
							day = parseInt(target.text(), 10)||1;
							year = this.viewDate.getUTCFullYear();
							month = this.viewDate.getUTCMonth();
							if (target.is('.old')){
								if (month === 0){
									month = 11;
									year -= 1;
								}
								else {
									month -= 1;
								}
							}
							else if (target.is('.new')){
								if (month === 11){
									month = 0;
									year += 1;
								}
								else {
									month += 1;
								}
							}
							this._setDate(UTCDate(year, month, day));
						}
						break;
				}
			}
			if (this.picker.is(':visible') && this._focused_from){
				$(this._focused_from).focus();
			}
			delete this._focused_from;
		},

		_toggle_multidate: function(date){
			var ix = this.dates.contains(date);
			if (!date){
				this.dates.clear();
			}
			else if (ix !== -1){
				this.dates.remove(ix);
			}
			else {
				this.dates.push(date);
			}
			if (typeof this.o.multidate === 'number')
				while (this.dates.length > this.o.multidate)
					this.dates.remove(0);
		},

		_setDate: function(date, which){
			if (!which || which === 'date')
				this._toggle_multidate(date && new Date(date));
			if (!which || which  === 'view')
				this.viewDate = date && new Date(date);

			this.fill();
			this.setValue();
			this._trigger('changeDate');
			var element;
			if (this.isInput){
				element = this.element;
			}
			else if (this.component){
				element = this.element.find('input');
			}
			if (element){
				element.change();
			}
			if (this.o.autoclose && (!which || which === 'date')){
				this.hide();
			}
		},

		moveMonth: function(date, dir){
			if (!date)
				return undefined;
			if (!dir)
				return date;
			var new_date = new Date(date.valueOf()),
				day = new_date.getUTCDate(),
				month = new_date.getUTCMonth(),
				mag = Math.abs(dir),
				new_month, test;
			dir = dir > 0 ? 1 : -1;
			if (mag === 1){
				test = dir === -1
					// If going back one month, make sure month is not current month
					// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
					? function(){
						return new_date.getUTCMonth() === month;
					}
					// If going forward one month, make sure month is as expected
					// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
					: function(){
						return new_date.getUTCMonth() !== new_month;
					};
				new_month = month + dir;
				new_date.setUTCMonth(new_month);
				// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
				if (new_month < 0 || new_month > 11)
					new_month = (new_month + 12) % 12;
			}
			else {
				// For magnitudes >1, move one month at a time...
				for (var i=0; i < mag; i++)
					// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
					new_date = this.moveMonth(new_date, dir);
				// ...then reset the day, keeping it in the new month
				new_month = new_date.getUTCMonth();
				new_date.setUTCDate(day);
				test = function(){
					return new_month !== new_date.getUTCMonth();
				};
			}
			// Common date-resetting loop -- if date is beyond end of month, make it
			// end of month
			while (test()){
				new_date.setUTCDate(--day);
				new_date.setUTCMonth(new_month);
			}
			return new_date;
		},

		moveYear: function(date, dir){
			return this.moveMonth(date, dir*12);
		},

		dateWithinRange: function(date){
			return date >= this.o.startDate && date <= this.o.endDate;
		},

		keydown: function(e){
			if (this.picker.is(':not(:visible)')){
				if (e.keyCode === 27) // allow escape to hide and re-show picker
					this.show();
				return;
			}
			var dateChanged = false,
				dir, newDate, newViewDate,
				focusDate = this.focusDate || this.viewDate;
			switch (e.keyCode){
				case 27: // escape
					if (this.focusDate){
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
					}
					else
						this.hide();
					e.preventDefault();
					break;
				case 37: // left
				case 39: // right
					if (!this.o.keyboardNavigation)
						break;
					dir = e.keyCode === 37 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					}
					else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					}
					else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 38: // up
				case 40: // down
					if (!this.o.keyboardNavigation)
						break;
					dir = e.keyCode === 38 ? -1 : 1;
					if (e.ctrlKey){
						newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveYear(focusDate, dir);
						this._trigger('changeYear', this.viewDate);
					}
					else if (e.shiftKey){
						newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
						newViewDate = this.moveMonth(focusDate, dir);
						this._trigger('changeMonth', this.viewDate);
					}
					else {
						newDate = new Date(this.dates.get(-1) || UTCToday());
						newDate.setUTCDate(newDate.getUTCDate() + dir * 7);
						newViewDate = new Date(focusDate);
						newViewDate.setUTCDate(focusDate.getUTCDate() + dir * 7);
					}
					if (this.dateWithinRange(newDate)){
						this.focusDate = this.viewDate = newViewDate;
						this.setValue();
						this.fill();
						e.preventDefault();
					}
					break;
				case 32: // spacebar
					// Spacebar is used in manually typing dates in some formats.
					// As such, its behavior should not be hijacked.
					break;
				case 13: // enter
					focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
					this._toggle_multidate(focusDate);
					dateChanged = true;
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.setValue();
					this.fill();
					if (this.picker.is(':visible')){
						e.preventDefault();
						if (this.o.autoclose)
							this.hide();
					}
					break;
				case 9: // tab
					this.focusDate = null;
					this.viewDate = this.dates.get(-1) || this.viewDate;
					this.fill();
					this.hide();
					break;
			}
			if (dateChanged){
				if (this.dates.length)
					this._trigger('changeDate');
				else
					this._trigger('clearDate');
				var element;
				if (this.isInput){
					element = this.element;
				}
				else if (this.component){
					element = this.element.find('input');
				}
				if (element){
					element.change();
				}
			}
		},

		showMode: function(dir){
			if (dir){
				this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
			}
			this.picker
				.find('>div')
				.hide()
				.filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName)
					.css('display', 'block');
			this.updateNavArrows();
		}
	};

	var DateRangePicker = function(element, options){
		this.element = $(element);
		this.inputs = $.map(options.inputs, function(i){
			return i.jquery ? i[0] : i;
		});
		delete options.inputs;

		$(this.inputs)
			.datepicker(options)
			.bind('changeDate', $.proxy(this.dateUpdated, this));

		this.pickers = $.map(this.inputs, function(i){
			return $(i).data('datepicker');
		});
		this.updateDates();
	};
	DateRangePicker.prototype = {
		updateDates: function(){
			this.dates = $.map(this.pickers, function(i){
				return i.getUTCDate();
			});
			this.updateRanges();
		},
		updateRanges: function(){
			var range = $.map(this.dates, function(d){
				return d.valueOf();
			});
			$.each(this.pickers, function(i, p){
				p.setRange(range);
			});
		},
		dateUpdated: function(e){
			// `this.updating` is a workaround for preventing infinite recursion
			// between `changeDate` triggering and `setUTCDate` calling.  Until
			// there is a better mechanism.
			if (this.updating)
				return;
			this.updating = true;

			var dp = $(e.target).data('datepicker'),
				new_date = dp.getUTCDate(),
				i = $.inArray(e.target, this.inputs),
				l = this.inputs.length;
			if (i === -1)
				return;

			$.each(this.pickers, function(i, p){
				if (!p.getUTCDate())
					p.setUTCDate(new_date);
			});

			if (new_date < this.dates[i]){
				// Date being moved earlier/left
				while (i >= 0 && new_date < this.dates[i]){
					this.pickers[i--].setUTCDate(new_date);
				}
			}
			else if (new_date > this.dates[i]){
				// Date being moved later/right
				while (i < l && new_date > this.dates[i]){
					this.pickers[i++].setUTCDate(new_date);
				}
			}
			this.updateDates();

			delete this.updating;
		},
		remove: function(){
			$.map(this.pickers, function(p){ p.remove(); });
			delete this.element.data().datepicker;
		}
	};

	function opts_from_el(el, prefix){
		// Derive options from element data-attrs
		var data = $(el).data(),
			out = {}, inkey,
			replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
		prefix = new RegExp('^' + prefix.toLowerCase());
		function re_lower(_,a){
			return a.toLowerCase();
		}
		for (var key in data)
			if (prefix.test(key)){
				inkey = key.replace(replace, re_lower);
				out[inkey] = data[key];
			}
		return out;
	}

	function opts_from_locale(lang){
		// Derive options from locale plugins
		var out = {};
		// Check if "de-DE" style date is available, if not language should
		// fallback to 2 letter code eg "de"
		if (!dates[lang]){
			lang = lang.split('-')[0];
			if (!dates[lang])
				return;
		}
		var d = dates[lang];
		$.each(locale_opts, function(i,k){
			if (k in d)
				out[k] = d[k];
		});
		return out;
	}

	var old = $.fn.datepicker;
	$.fn.datepicker = function(option){
		var args = Array.apply(null, arguments);
		args.shift();
		var internal_return;
		this.each(function(){
			var $this = $(this),
				data = $this.data('datepicker'),
				options = typeof option === 'object' && option;
			if (!data){
				var elopts = opts_from_el(this, 'date'),
					// Preliminary otions
					xopts = $.extend({}, defaults, elopts, options),
					locopts = opts_from_locale(xopts.language),
					// Options priority: js args, data-attrs, locales, defaults
					opts = $.extend({}, defaults, locopts, elopts, options);
				if ($this.is('.input-daterange') || opts.inputs){
					var ropts = {
						inputs: opts.inputs || $this.find('input').toArray()
					};
					$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));
				}
				else {
					$this.data('datepicker', (data = new Datepicker(this, opts)));
				}
			}
			if (typeof option === 'string' && typeof data[option] === 'function'){
				internal_return = data[option].apply(data, args);
				if (internal_return !== undefined)
					return false;
			}
		});
		if (internal_return !== undefined)
			return internal_return;
		else
			return this;
	};

	var defaults = $.fn.datepicker.defaults = {
		autoclose: false,
		beforeShowDay: $.noop,
		calendarWeeks: false,
		clearBtn: false,
		daysOfWeekDisabled: [],
		endDate: Infinity,
		forceParse: true,
		format: 'mm/dd/yyyy',
		keyboardNavigation: true,
		language: 'en',
		minViewMode: 0,
		multidate: false,
		multidateSeparator: ',',
		orientation: "auto",
		rtl: false,
		startDate: -Infinity,
		startView: 0,
		todayBtn: false,
		todayHighlight: false,
		weekStart: 0
	};
	var locale_opts = $.fn.datepicker.locale_opts = [
		'format',
		'rtl',
		'weekStart'
	];
	$.fn.datepicker.Constructor = Datepicker;
	var dates = $.fn.datepicker.dates = {
		en: {
			days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
			daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
			daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
			months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
			monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			today: "Today",
			clear: "Clear"
		}
	};

	var DPGlobal = {
		modes: [
			{
				clsName: 'days',
				navFnc: 'Month',
				navStep: 1
			},
			{
				clsName: 'months',
				navFnc: 'FullYear',
				navStep: 1
			},
			{
				clsName: 'years',
				navFnc: 'FullYear',
				navStep: 10
		}],
		isLeapYear: function(year){
			return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
		},
		getDaysInMonth: function(year, month){
			return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
		},
		validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
		nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
		parseFormat: function(format){
			// IE treats \0 as a string end in inputs (truncating the value),
			// so it's a bad format delimiter, anyway
			var separators = format.replace(this.validParts, '\0').split('\0'),
				parts = format.match(this.validParts);
			if (!separators || !separators.length || !parts || parts.length === 0){
				throw new Error("Invalid date format.");
			}
			return {separators: separators, parts: parts};
		},
		parseDate: function(date, format, language){
			if (!date)
				return undefined;
			if (date instanceof Date)
				return date;
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var part_re = /([\-+]\d+)([dmwy])/,
				parts = date.match(/([\-+]\d+)([dmwy])/g),
				part, dir, i;
			if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)){
				date = new Date();
				for (i=0; i < parts.length; i++){
					part = part_re.exec(parts[i]);
					dir = parseInt(part[1]);
					switch (part[2]){
						case 'd':
							date.setUTCDate(date.getUTCDate() + dir);
							break;
						case 'm':
							date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
							break;
						case 'w':
							date.setUTCDate(date.getUTCDate() + dir * 7);
							break;
						case 'y':
							date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
							break;
					}
				}
				return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
			}
			parts = date && date.match(this.nonpunctuation) || [];
			date = new Date();
			var parsed = {},
				setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
				setters_map = {
					yyyy: function(d,v){
						return d.setUTCFullYear(v);
					},
					yy: function(d,v){
						return d.setUTCFullYear(2000+v);
					},
					m: function(d,v){
						if (isNaN(d))
							return d;
						v -= 1;
						while (v < 0) v += 12;
						v %= 12;
						d.setUTCMonth(v);
						while (d.getUTCMonth() !== v)
							d.setUTCDate(d.getUTCDate()-1);
						return d;
					},
					d: function(d,v){
						return d.setUTCDate(v);
					}
				},
				val, filtered;
			setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
			setters_map['dd'] = setters_map['d'];
			date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
			var fparts = format.parts.slice();
			// Remove noop parts
			if (parts.length !== fparts.length){
				fparts = $(fparts).filter(function(i,p){
					return $.inArray(p, setters_order) !== -1;
				}).toArray();
			}
			// Process remainder
			function match_part(){
				var m = this.slice(0, parts[i].length),
					p = parts[i].slice(0, m.length);
				return m === p;
			}
			if (parts.length === fparts.length){
				var cnt;
				for (i=0, cnt = fparts.length; i < cnt; i++){
					val = parseInt(parts[i], 10);
					part = fparts[i];
					if (isNaN(val)){
						switch (part){
							case 'MM':
								filtered = $(dates[language].months).filter(match_part);
								val = $.inArray(filtered[0], dates[language].months) + 1;
								break;
							case 'M':
								filtered = $(dates[language].monthsShort).filter(match_part);
								val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
								break;
						}
					}
					parsed[part] = val;
				}
				var _date, s;
				for (i=0; i < setters_order.length; i++){
					s = setters_order[i];
					if (s in parsed && !isNaN(parsed[s])){
						_date = new Date(date);
						setters_map[s](_date, parsed[s]);
						if (!isNaN(_date))
							date = _date;
					}
				}
			}
			return date;
		},
		formatDate: function(date, format, language){
			if (!date)
				return '';
			if (typeof format === 'string')
				format = DPGlobal.parseFormat(format);
			var val = {
				d: date.getUTCDate(),
				D: dates[language].daysShort[date.getUTCDay()],
				DD: dates[language].days[date.getUTCDay()],
				m: date.getUTCMonth() + 1,
				M: dates[language].monthsShort[date.getUTCMonth()],
				MM: dates[language].months[date.getUTCMonth()],
				yy: date.getUTCFullYear().toString().substring(2),
				yyyy: date.getUTCFullYear()
			};
			val.dd = (val.d < 10 ? '0' : '') + val.d;
			val.mm = (val.m < 10 ? '0' : '') + val.m;
			date = [];
			var seps = $.extend([], format.separators);
			for (var i=0, cnt = format.parts.length; i <= cnt; i++){
				if (seps.length)
					date.push(seps.shift());
				date.push(val[format.parts[i]]);
			}
			return date.join('');
		},
		headTemplate: '<thead>'+
							'<tr>'+
								'<th class="prev">&laquo;</th>'+
								'<th colspan="5" class="datepicker-switch"></th>'+
								'<th class="next">&raquo;</th>'+
							'</tr>'+
						'</thead>',
		contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
		footTemplate: '<tfoot>'+
							'<tr>'+
								'<th colspan="7" class="today"></th>'+
							'</tr>'+
							'<tr>'+
								'<th colspan="7" class="clear"></th>'+
							'</tr>'+
						'</tfoot>'
	};
	DPGlobal.template = '<div class="datepicker">'+
							'<div class="datepicker-days">'+
								'<table class=" table-condensed">'+
									DPGlobal.headTemplate+
									'<tbody></tbody>'+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-months">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
							'<div class="datepicker-years">'+
								'<table class="table-condensed">'+
									DPGlobal.headTemplate+
									DPGlobal.contTemplate+
									DPGlobal.footTemplate+
								'</table>'+
							'</div>'+
						'</div>';

	$.fn.datepicker.DPGlobal = DPGlobal;


	/* DATEPICKER NO CONFLICT
	* =================== */

	$.fn.datepicker.noConflict = function(){
		$.fn.datepicker = old;
		return this;
	};


	/* DATEPICKER DATA-API
	* ================== */

	$(document).on(
		'focus.datepicker.data-api click.datepicker.data-api',
		'[data-provide="datepicker"]',
		function(e){
			var $this = $(this);
			if ($this.data('datepicker'))
				return;
			e.preventDefault();
			// component click requires us to explicitly show it
			$this.datepicker('show');
		}
	);
	$(function(){
		$('[data-provide="datepicker-inline"]').datepicker();
	});

}(window.jQuery));

/*!
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(p){var s=this||(0,eval)("this"),v=s.document,L=s.navigator,w=s.jQuery,D=s.JSON;(function(p){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?p(module.exports||exports,require):"function"===typeof define&&define.amd?define(["exports","require"],p):p(s.ko={})})(function(M,N){function H(a,d){return null===a||typeof a in R?a===d:!1}function S(a,d){var c;return function(){c||(c=setTimeout(function(){c=p;a()},d))}}function T(a,d){var c;return function(){clearTimeout(c);
c=setTimeout(a,d)}}function I(b,d,c,e){a.d[b]={init:function(b,h,k,f,m){var l,q;a.s(function(){var f=a.a.c(h()),k=!c!==!f,z=!q;if(z||d||k!==l)z&&a.Y.la()&&(q=a.a.ia(a.f.childNodes(b),!0)),k?(z||a.f.T(b,a.a.ia(q)),a.Ca(e?e(m,f):m,b)):a.f.ja(b),l=k},null,{o:b});return{controlsDescendantBindings:!0}}};a.h.ha[b]=!1;a.f.Q[b]=!0}var a="undefined"!==typeof M?M:{};a.b=function(b,d){for(var c=b.split("."),e=a,g=0;g<c.length-1;g++)e=e[c[g]];e[c[c.length-1]]=d};a.A=function(a,d,c){a[d]=c};a.version="3.2.0";
a.b("version",a.version);a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function d(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function c(a,b){a.__proto__=b;return a}var e={__proto__:[]}instanceof Array,g={},h={};g[L&&/Firefox\/2/i.test(L.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];g.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(g,function(a,b){if(b.length)for(var c=
0,d=b.length;c<d;c++)h[b[c]]=a});var k={propertychange:!0},f=v&&function(){for(var a=3,b=v.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:p}();return{vb:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],u:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},m:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===
b)return c;return-1},qb:function(a,b,c){for(var d=0,f=a.length;d<f;d++)if(b.call(c,a[d],d))return a[d];return null},ua:function(m,b){var c=a.a.m(m,b);0<c?m.splice(c,1):0===c&&m.shift()},rb:function(m){m=m||[];for(var b=[],c=0,d=m.length;c<d;c++)0>a.a.m(b,m[c])&&b.push(m[c]);return b},Da:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)c.push(b(a[d],d));return c},ta:function(a,b){a=a||[];for(var c=[],d=0,f=a.length;d<f;d++)b(a[d],d)&&c.push(a[d]);return c},ga:function(a,b){if(b instanceof
Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},ea:function(b,c,d){var f=a.a.m(a.a.Xa(b),c);0>f?d&&b.push(c):d||b.splice(f,1)},xa:e,extend:d,za:c,Aa:e?c:d,G:b,na:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},Ka:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},oc:function(b){b=a.a.S(b);for(var c=v.createElement("div"),d=0,f=b.length;d<f;d++)c.appendChild(a.R(b[d]));return c},ia:function(b,c){for(var d=
0,f=b.length,e=[];d<f;d++){var k=b[d].cloneNode(!0);e.push(c?a.R(k):k)}return e},T:function(b,c){a.a.Ka(b);if(c)for(var d=0,f=c.length;d<f;d++)b.appendChild(c[d])},Lb:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var f=d[0],e=f.parentNode,k=0,g=c.length;k<g;k++)e.insertBefore(c[k],f);k=0;for(g=d.length;k<g;k++)a.removeNode(d[k])}},ka:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.shift();if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=
0;c!==d;)if(a.push(c),c=c.nextSibling,!c)return;a.push(d)}}return a},Nb:function(a,b){7>f?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===p?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},vc:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},cc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&
16);for(;a&&a!=b;)a=a.parentNode;return!!a},Ja:function(b){return a.a.cc(b,b.ownerDocument.documentElement)},ob:function(b){return!!a.a.qb(b,a.a.Ja)},t:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},n:function(b,c,d){var e=f&&k[c];if(!e&&w)w(b).bind(c,d);else if(e||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var g=function(a){d.call(b,a)},h="on"+c;b.attachEvent(h,g);a.a.w.da(b,function(){b.detachEvent(h,g)})}else throw Error("Browser doesn't support addEventListener or attachEvent");
else b.addEventListener(c,d,!1)},oa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.t(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(w&&!d)w(b).trigger(c);else if("function"==typeof v.createEvent)if("function"==typeof b.dispatchEvent)d=v.createEvent(h[c]||"HTMLEvents"),d.initEvent(c,!0,!0,s,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");
else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");},c:function(b){return a.C(b)?b():b},Xa:function(b){return a.C(b)?b.v():b},Ba:function(b,c,d){if(c){var f=/\S+/g,e=b.className.match(f)||[];a.a.u(c.match(f),function(b){a.a.ea(e,b,d)});b.className=e.join(" ")}},bb:function(b,c){var d=a.a.c(c);if(null===d||d===p)d="";var f=a.f.firstChild(b);!f||3!=f.nodeType||a.f.nextSibling(f)?a.f.T(b,[b.ownerDocument.createTextNode(d)]):
f.data=d;a.a.fc(b)},Mb:function(a,b){a.name=b;if(7>=f)try{a.mergeAttributes(v.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},fc:function(a){9<=f&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},dc:function(a){if(f){var b=a.style.width;a.style.width=0;a.style.width=b}},sc:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],f=b;f<=c;f++)d.push(f);return d},S:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},yc:6===f,zc:7===f,L:f,xb:function(b,c){for(var d=
a.a.S(b.getElementsByTagName("input")).concat(a.a.S(b.getElementsByTagName("textarea"))),f="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},e=[],k=d.length-1;0<=k;k--)f(d[k])&&e.push(d[k]);return e},pc:function(b){return"string"==typeof b&&(b=a.a.cb(b))?D&&D.parse?D.parse(b):(new Function("return "+b))():null},eb:function(b,c,d){if(!D||!D.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return D.stringify(a.a.c(b),c,d)},qc:function(c,d,f){f=f||{};var e=f.params||{},k=f.includeFields||this.vb,g=c;if("object"==typeof c&&"form"===a.a.t(c))for(var g=c.action,h=k.length-1;0<=h;h--)for(var r=a.a.xb(c,k[h]),E=r.length-1;0<=E;E--)e[r[E].name]=r[E].value;d=a.a.c(d);var y=v.createElement("form");y.style.display="none";y.action=g;y.method="post";for(var p in d)c=v.createElement("input"),c.type="hidden",c.name=p,c.value=a.a.eb(a.a.c(d[p])),y.appendChild(c);b(e,function(a,b){var c=v.createElement("input");
c.type="hidden";c.name=a;c.value=b;y.appendChild(c)});v.body.appendChild(y);f.submitter?f.submitter(y):y.submit();setTimeout(function(){y.parentNode.removeChild(y)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.u);a.b("utils.arrayFirst",a.a.qb);a.b("utils.arrayFilter",a.a.ta);a.b("utils.arrayGetDistinctValues",a.a.rb);a.b("utils.arrayIndexOf",a.a.m);a.b("utils.arrayMap",a.a.Da);a.b("utils.arrayPushAll",a.a.ga);a.b("utils.arrayRemoveItem",a.a.ua);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.vb);a.b("utils.getFormFields",a.a.xb);a.b("utils.peekObservable",a.a.Xa);a.b("utils.postJson",a.a.qc);a.b("utils.parseJson",a.a.pc);a.b("utils.registerEventHandler",a.a.n);a.b("utils.stringifyJson",a.a.eb);a.b("utils.range",a.a.sc);a.b("utils.toggleDomNodeCssClass",a.a.Ba);a.b("utils.triggerEvent",a.a.oa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.G);a.b("utils.addOrRemoveItem",a.a.ea);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=function(a){var d=
this,c=Array.prototype.slice.call(arguments);a=c.shift();return function(){return d.apply(a,c.concat(Array.prototype.slice.call(arguments)))}});a.a.e=new function(){function a(b,h){var k=b[c];if(!k||"null"===k||!e[k]){if(!h)return p;k=b[c]="ko"+d++;e[k]={}}return e[k]}var d=0,c="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===p?p:e[d]},set:function(c,d,e){if(e!==p||a(c,!1)!==p)a(c,!0)[d]=e},clear:function(a){var b=a[c];return b?(delete e[b],a[c]=null,!0):!1},F:function(){return d++ +
c}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.w=new function(){function b(b,d){var f=a.a.e.get(b,c);f===p&&d&&(f=[],a.a.e.set(b,c,f));return f}function d(c){var e=b(c,!1);if(e)for(var e=e.slice(0),f=0;f<e.length;f++)e[f](c);a.a.e.clear(c);a.a.w.cleanExternalData(c);if(g[c.nodeType])for(e=c.firstChild;c=e;)e=c.nextSibling,8===c.nodeType&&d(c)}var c=a.a.e.F(),e={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{da:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");
b(a,!0).push(c)},Kb:function(d,e){var f=b(d,!1);f&&(a.a.ua(f,e),0==f.length&&a.a.e.set(d,c,p))},R:function(b){if(e[b.nodeType]&&(d(b),g[b.nodeType])){var c=[];a.a.ga(c,b.getElementsByTagName("*"));for(var f=0,m=c.length;f<m;f++)d(c[f])}return b},removeNode:function(b){a.R(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){w&&"function"==typeof w.cleanData&&w.cleanData([a])}}};a.R=a.a.w.R;a.removeNode=a.a.w.removeNode;a.b("cleanNode",a.R);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",
a.a.w);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.w.da);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.w.Kb);(function(){a.a.ba=function(b){var d;if(w)if(w.parseHTML)d=w.parseHTML(b)||[];else{if((d=w.clean([b]))&&d[0]){for(b=d[0];b.parentNode&&11!==b.parentNode.nodeType;)b=b.parentNode;b.parentNode&&b.parentNode.removeChild(b)}}else{var c=a.a.cb(b).toLowerCase();d=v.createElement("div");c=c.match(/^<(thead|tbody|tfoot)/)&&[1,"<table>","</table>"]||!c.indexOf("<tr")&&[2,"<table><tbody>",
"</tbody></table>"]||(!c.indexOf("<td")||!c.indexOf("<th"))&&[3,"<table><tbody><tr>","</tr></tbody></table>"]||[0,"",""];b="ignored<div>"+c[1]+b+c[2]+"</div>";for("function"==typeof s.innerShiv?d.appendChild(s.innerShiv(b)):d.innerHTML=b;c[0]--;)d=d.lastChild;d=a.a.S(d.lastChild.childNodes)}return d};a.a.$a=function(b,d){a.a.Ka(b);d=a.a.c(d);if(null!==d&&d!==p)if("string"!=typeof d&&(d=d.toString()),w)w(b).html(d);else for(var c=a.a.ba(d),e=0;e<c.length;e++)b.appendChild(c[e])}})();a.b("utils.parseHtmlFragment",
a.a.ba);a.b("utils.setHtml",a.a.$a);a.D=function(){function b(c,d){if(c)if(8==c.nodeType){var g=a.D.Gb(c.nodeValue);null!=g&&d.push({bc:c,mc:g})}else if(1==c.nodeType)for(var g=0,h=c.childNodes,k=h.length;g<k;g++)b(h[g],d)}var d={};return{Ua:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);d[b]=a;return"\x3c!--[ko_memo:"+
b+"]--\x3e"},Rb:function(a,b){var g=d[a];if(g===p)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return g.apply(null,b||[]),!0}finally{delete d[a]}},Sb:function(c,d){var g=[];b(c,g);for(var h=0,k=g.length;h<k;h++){var f=g[h].bc,m=[f];d&&a.a.ga(m,d);a.D.Rb(g[h].mc,m);f.nodeValue="";f.parentNode&&f.parentNode.removeChild(f)}},Gb:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.D);a.b("memoization.memoize",a.D.Ua);
a.b("memoization.unmemoize",a.D.Rb);a.b("memoization.parseMemoText",a.D.Gb);a.b("memoization.unmemoizeDomNodeAndDescendants",a.D.Sb);a.La={throttle:function(b,d){b.throttleEvaluation=d;var c=null;return a.j({read:b,write:function(a){clearTimeout(c);c=setTimeout(function(){b(a)},d)}})},rateLimit:function(a,d){var c,e,g;"number"==typeof d?c=d:(c=d.timeout,e=d.method);g="notifyWhenChangesStop"==e?T:S;a.Ta(function(a){return g(a,c)})},notify:function(a,d){a.equalityComparer="always"==d?null:H}};var R=
{undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.La);a.Pb=function(b,d,c){this.target=b;this.wa=d;this.ac=c;this.Cb=!1;a.A(this,"dispose",this.K)};a.Pb.prototype.K=function(){this.Cb=!0;this.ac()};a.P=function(){a.a.Aa(this,a.P.fn);this.M={}};var G="change",A={U:function(b,d,c){var e=this;c=c||G;var g=new a.Pb(e,d?b.bind(d):b,function(){a.a.ua(e.M[c],g);e.nb&&e.nb()});e.va&&e.va(c);e.M[c]||(e.M[c]=[]);e.M[c].push(g);return g},notifySubscribers:function(b,d){d=d||G;if(this.Ab(d))try{a.k.Ea();
for(var c=this.M[d].slice(0),e=0,g;g=c[e];++e)g.Cb||g.wa(b)}finally{a.k.end()}},Ta:function(b){var d=this,c=a.C(d),e,g,h;d.qa||(d.qa=d.notifySubscribers,d.notifySubscribers=function(a,b){b&&b!==G?"beforeChange"===b?d.kb(a):d.qa(a,b):d.lb(a)});var k=b(function(){c&&h===d&&(h=d());e=!1;d.Pa(g,h)&&d.qa(g=h)});d.lb=function(a){e=!0;h=a;k()};d.kb=function(a){e||(g=a,d.qa(a,"beforeChange"))}},Ab:function(a){return this.M[a]&&this.M[a].length},yb:function(){var b=0;a.a.G(this.M,function(a,c){b+=c.length});
return b},Pa:function(a,d){return!this.equalityComparer||!this.equalityComparer(a,d)},extend:function(b){var d=this;b&&a.a.G(b,function(b,e){var g=a.La[b];"function"==typeof g&&(d=g(d,e)||d)});return d}};a.A(A,"subscribe",A.U);a.A(A,"extend",A.extend);a.A(A,"getSubscriptionsCount",A.yb);a.a.xa&&a.a.za(A,Function.prototype);a.P.fn=A;a.Db=function(a){return null!=a&&"function"==typeof a.U&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.P);a.b("isSubscribable",a.Db);a.Y=a.k=function(){function b(a){c.push(e);
e=a}function d(){e=c.pop()}var c=[],e,g=0;return{Ea:b,end:d,Jb:function(b){if(e){if(!a.Db(b))throw Error("Only subscribable things can act as dependencies");e.wa(b,b.Vb||(b.Vb=++g))}},B:function(a,c,f){try{return b(),a.apply(c,f||[])}finally{d()}},la:function(){if(e)return e.s.la()},ma:function(){if(e)return e.ma}}}();a.b("computedContext",a.Y);a.b("computedContext.getDependenciesCount",a.Y.la);a.b("computedContext.isInitial",a.Y.ma);a.b("computedContext.isSleeping",a.Y.Ac);a.p=function(b){function d(){if(0<
arguments.length)return d.Pa(c,arguments[0])&&(d.X(),c=arguments[0],d.W()),this;a.k.Jb(d);return c}var c=b;a.P.call(d);a.a.Aa(d,a.p.fn);d.v=function(){return c};d.W=function(){d.notifySubscribers(c)};d.X=function(){d.notifySubscribers(c,"beforeChange")};a.A(d,"peek",d.v);a.A(d,"valueHasMutated",d.W);a.A(d,"valueWillMutate",d.X);return d};a.p.fn={equalityComparer:H};var F=a.p.rc="__ko_proto__";a.p.fn[F]=a.p;a.a.xa&&a.a.za(a.p.fn,a.P.fn);a.Ma=function(b,d){return null===b||b===p||b[F]===p?!1:b[F]===
d?!0:a.Ma(b[F],d)};a.C=function(b){return a.Ma(b,a.p)};a.Ra=function(b){return"function"==typeof b&&b[F]===a.p||"function"==typeof b&&b[F]===a.j&&b.hc?!0:!1};a.b("observable",a.p);a.b("isObservable",a.C);a.b("isWriteableObservable",a.Ra);a.b("isWritableObservable",a.Ra);a.aa=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.p(b);a.a.Aa(b,a.aa.fn);return b.extend({trackArrayChanges:!0})};
a.aa.fn={remove:function(b){for(var d=this.v(),c=[],e="function"!=typeof b||a.C(b)?function(a){return a===b}:b,g=0;g<d.length;g++){var h=d[g];e(h)&&(0===c.length&&this.X(),c.push(h),d.splice(g,1),g--)}c.length&&this.W();return c},removeAll:function(b){if(b===p){var d=this.v(),c=d.slice(0);this.X();d.splice(0,d.length);this.W();return c}return b?this.remove(function(c){return 0<=a.a.m(b,c)}):[]},destroy:function(b){var d=this.v(),c="function"!=typeof b||a.C(b)?function(a){return a===b}:b;this.X();
for(var e=d.length-1;0<=e;e--)c(d[e])&&(d[e]._destroy=!0);this.W()},destroyAll:function(b){return b===p?this.destroy(function(){return!0}):b?this.destroy(function(d){return 0<=a.a.m(b,d)}):[]},indexOf:function(b){var d=this();return a.a.m(d,b)},replace:function(a,d){var c=this.indexOf(a);0<=c&&(this.X(),this.v()[c]=d,this.W())}};a.a.u("pop push reverse shift sort splice unshift".split(" "),function(b){a.aa.fn[b]=function(){var a=this.v();this.X();this.sb(a,b,arguments);a=a[b].apply(a,arguments);this.W();
return a}});a.a.u(["slice"],function(b){a.aa.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.a.xa&&a.a.za(a.aa.fn,a.p.fn);a.b("observableArray",a.aa);var J="arrayChange";a.La.trackArrayChanges=function(b){function d(){if(!c){c=!0;var d=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==G||++g;return d.apply(this,arguments)};var f=[].concat(b.v()||[]);e=null;b.U(function(c){c=[].concat(c||[]);if(b.Ab(J)){var d;if(!e||1<g)e=a.a.Fa(f,c,{sparse:!0});d=e;d.length&&b.notifySubscribers(d,
J)}f=c;e=null;g=0})}}if(!b.sb){var c=!1,e=null,g=0,h=b.U;b.U=b.subscribe=function(a,b,c){c===J&&d();return h.apply(this,arguments)};b.sb=function(b,d,m){function l(a,b,c){return q[q.length]={status:a,value:b,index:c}}if(c&&!g){var q=[],h=b.length,t=m.length,z=0;switch(d){case "push":z=h;case "unshift":for(d=0;d<t;d++)l("added",m[d],z+d);break;case "pop":z=h-1;case "shift":h&&l("deleted",b[z],z);break;case "splice":d=Math.min(Math.max(0,0>m[0]?h+m[0]:m[0]),h);for(var h=1===t?h:Math.min(d+(m[1]||0),
h),t=d+t-2,z=Math.max(h,t),u=[],r=[],E=2;d<z;++d,++E)d<h&&r.push(l("deleted",b[d],d)),d<t&&u.push(l("added",m[E],d));a.a.wb(r,u);break;default:return}e=q}}}};a.s=a.j=function(b,d,c){function e(){a.a.G(v,function(a,b){b.K()});v={}}function g(){e();C=0;u=!0;n=!1}function h(){var a=f.throttleEvaluation;a&&0<=a?(clearTimeout(P),P=setTimeout(k,a)):f.ib?f.ib():k()}function k(b){if(t){if(E)throw Error("A 'pure' computed must not be called recursively");}else if(!u){if(w&&w()){if(!z){s();return}}else z=!1;
t=!0;if(y)try{var c={};a.k.Ea({wa:function(a,b){c[b]||(c[b]=1,++C)},s:f,ma:p});C=0;q=r.call(d)}finally{a.k.end(),t=!1}else try{var e=v,m=C;a.k.Ea({wa:function(a,b){u||(m&&e[b]?(v[b]=e[b],++C,delete e[b],--m):v[b]||(v[b]=a.U(h),++C))},s:f,ma:E?p:!C});v={};C=0;try{var l=d?r.call(d):r()}finally{a.k.end(),m&&a.a.G(e,function(a,b){b.K()}),n=!1}f.Pa(q,l)&&(f.notifySubscribers(q,"beforeChange"),q=l,!0!==b&&f.notifySubscribers(q))}finally{t=!1}C||s()}}function f(){if(0<arguments.length){if("function"===typeof O)O.apply(d,
arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.k.Jb(f);n&&k(!0);return q}function m(){n&&!C&&k(!0);return q}function l(){return n||0<C}var q,n=!0,t=!1,z=!1,u=!1,r=b,E=!1,y=!1;r&&"object"==typeof r?(c=r,r=c.read):(c=c||{},r||(r=c.read));if("function"!=typeof r)throw Error("Pass a function that returns the value of the ko.computed");var O=c.write,x=c.disposeWhenNodeIsRemoved||
c.o||null,B=c.disposeWhen||c.Ia,w=B,s=g,v={},C=0,P=null;d||(d=c.owner);a.P.call(f);a.a.Aa(f,a.j.fn);f.v=m;f.la=function(){return C};f.hc="function"===typeof c.write;f.K=function(){s()};f.Z=l;var A=f.Ta;f.Ta=function(a){A.call(f,a);f.ib=function(){f.kb(q);n=!0;f.lb(f)}};c.pure?(y=E=!0,f.va=function(){y&&(y=!1,k(!0))},f.nb=function(){f.yb()||(e(),y=n=!0)}):c.deferEvaluation&&(f.va=function(){m();delete f.va});a.A(f,"peek",f.v);a.A(f,"dispose",f.K);a.A(f,"isActive",f.Z);a.A(f,"getDependenciesCount",
f.la);x&&(z=!0,x.nodeType&&(w=function(){return!a.a.Ja(x)||B&&B()}));y||c.deferEvaluation||k();x&&l()&&x.nodeType&&(s=function(){a.a.w.Kb(x,s);g()},a.a.w.da(x,s));return f};a.jc=function(b){return a.Ma(b,a.j)};A=a.p.rc;a.j[A]=a.p;a.j.fn={equalityComparer:H};a.j.fn[A]=a.j;a.a.xa&&a.a.za(a.j.fn,a.P.fn);a.b("dependentObservable",a.j);a.b("computed",a.j);a.b("isComputed",a.jc);a.Ib=function(b,d){if("function"===typeof b)return a.s(b,d,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.s(b,d)};a.b("pureComputed",
a.Ib);(function(){function b(a,g,h){h=h||new c;a=g(a);if("object"!=typeof a||null===a||a===p||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};h.save(a,k);d(a,function(c){var d=g(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var l=h.get(d);k[c]=l!==p?l:b(d,g,h)}});return k}function d(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==
typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function c(){this.keys=[];this.hb=[]}a.Qb=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.C(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Qb(b);return a.a.eb(b,c,d)};c.prototype={save:function(b,c){var d=a.a.m(this.keys,b);0<=d?this.hb[d]=c:(this.keys.push(b),this.hb.push(c))},get:function(b){b=a.a.m(this.keys,b);return 0<=b?this.hb[b]:p}}})();
a.b("toJS",a.Qb);a.b("toJSON",a.toJSON);(function(){a.i={q:function(b){switch(a.a.t(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.Va):7>=a.a.L?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex]):p;default:return b.value}},ca:function(b,d,c){switch(a.a.t(b)){case "option":switch(typeof d){case "string":a.a.e.set(b,a.d.options.Va,p);"__ko__hasDomDataOptionValue__"in
b&&delete b.__ko__hasDomDataOptionValue__;b.value=d;break;default:a.a.e.set(b,a.d.options.Va,d),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof d?d:""}break;case "select":if(""===d||null===d)d=p;for(var e=-1,g=0,h=b.options.length,k;g<h;++g)if(k=a.i.q(b.options[g]),k==d||""==k&&d===p){e=g;break}if(c||0<=e||d===p&&1<b.size)b.selectedIndex=e;break;default:if(null===d||d===p)d="";b.value=d}}}})();a.b("selectExtensions",a.i);a.b("selectExtensions.readValue",a.i.q);a.b("selectExtensions.writeValue",
a.i.ca);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),k,n,t=0;if(d){d.push(",");for(var z=0,u;u=d[z];++z){var r=u.charCodeAt(0);if(44===r){if(0>=t){k&&c.push(n?{key:k,value:n.join("")}:{unknown:k});k=n=t=0;continue}}else if(58===r){if(!n)continue}else if(47===r&&z&&1<u.length)(r=d[z-1].match(g))&&!h[r[0]]&&(b=b.substr(b.indexOf(u)+1),d=b.match(e),d.push(","),z=-1,u="/");else if(40===r||123===r||91===r)++t;else if(41===r||125===r||93===r)--t;
else if(!k&&!n){k=34===r||39===r?u.slice(1,-1):u;continue}n?n.push(u):n=[u]}}return c}var d=["true","false","null","undefined"],c=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),g=/[\])"'A-Za-z0-9_$]+$/,h={"in":1,"return":1,"typeof":1},k={};return{ha:[],V:k,Wa:b,ya:function(f,m){function e(b,m){var f;if(!z){var u=a.getBindingHandler(b);if(u&&u.preprocess&&
!(m=u.preprocess(m,b,e)))return;if(u=k[b])f=m,0<=a.a.m(d,f)?f=!1:(u=f.match(c),f=null===u?!1:u[1]?"Object("+u[1]+")"+u[2]:f),u=f;u&&h.push("'"+b+"':function(_z){"+f+"=_z}")}t&&(m="function(){return "+m+" }");g.push("'"+b+"':"+m)}m=m||{};var g=[],h=[],t=m.valueAccessors,z=m.bindingParams,u="string"===typeof f?b(f):f;a.a.u(u,function(a){e(a.key||a.unknown,a.value)});h.length&&e("_ko_property_writers","{"+h.join(",")+" }");return g.join(",")},lc:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==
b)return!0;return!1},pa:function(b,c,d,e,k){if(b&&a.C(b))!a.Ra(b)||k&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.ha);a.b("expressionRewriting.parseObjectLiteral",a.h.Wa);a.b("expressionRewriting.preProcessBindings",a.h.ya);a.b("expressionRewriting._twoWayBindings",a.h.V);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.ya);(function(){function b(a){return 8==
a.nodeType&&h.test(g?a.text:a.nodeValue)}function d(a){return 8==a.nodeType&&k.test(g?a.text:a.nodeValue)}function c(a,c){for(var f=a,e=1,k=[];f=f.nextSibling;){if(d(f)&&(e--,0===e))return k;k.push(f);b(f)&&e++}if(!c)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var d=c(a,b);return d?0<d.length?d[d.length-1].nextSibling:a.nextSibling:null}var g=v&&"\x3c!--test--\x3e"===v.createComment("test").text,h=g?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,
k=g?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,f={ul:!0,ol:!0};a.f={Q:{},childNodes:function(a){return b(a)?c(a):a.childNodes},ja:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,f=c.length;d<f;d++)a.removeNode(c[d])}else a.a.Ka(c)},T:function(c,d){if(b(c)){a.f.ja(c);for(var f=c.nextSibling,e=0,k=d.length;e<k;e++)f.parentNode.insertBefore(d[e],f)}else a.a.T(c,d)},Hb:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},Bb:function(c,
d,f){f?b(c)?c.parentNode.insertBefore(d,f.nextSibling):f.nextSibling?c.insertBefore(d,f.nextSibling):c.appendChild(d):a.f.Hb(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||d(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&d(a.nextSibling)?null:a.nextSibling},gc:b,xc:function(a){return(a=(g?a.text:a.nodeValue).match(h))?a[1]:null},Fb:function(c){if(f[a.a.t(c)]){var k=c.firstChild;if(k){do if(1===k.nodeType){var g;g=k.firstChild;
var h=null;if(g){do if(h)h.push(g);else if(b(g)){var t=e(g,!0);t?g=t:h=[g]}else d(g)&&(h=[g]);while(g=g.nextSibling)}if(g=h)for(h=k.nextSibling,t=0;t<g.length;t++)h?c.insertBefore(g[t],h):c.appendChild(g[t])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Q);a.b("virtualElements.emptyNode",a.f.ja);a.b("virtualElements.insertAfter",a.f.Bb);a.b("virtualElements.prepend",a.f.Hb);a.b("virtualElements.setDomNodeChildren",a.f.T);(function(){a.J=function(){this.Yb=
{}};a.a.extend(a.J.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.gc(b);default:return!1}},getBindings:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b):null;return a.g.mb(c,b,d,!1)},getBindingAccessors:function(b,d){var c=this.getBindingsString(b,d),c=c?this.parseBindingsString(c,d,b,{valueAccessors:!0}):null;return a.g.mb(c,b,d,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");
case 8:return a.f.xc(b);default:return null}},parseBindingsString:function(b,d,c,e){try{var g=this.Yb,h=b+(e&&e.valueAccessors||""),k;if(!(k=g[h])){var f,m="with($context){with($data||{}){return{"+a.h.ya(b,e)+"}}}";f=new Function("$context","$element",m);k=g[h]=f}return k(d,c)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.J.instance=new a.J})();a.b("bindingProvider",a.J);(function(){function b(a){return function(){return a}}function d(a){return a()}
function c(b){return a.a.na(a.k.B(b),function(a,c){return function(){return b()[c]}})}function e(a,b){return c(this.getBindings.bind(this,a,b))}function g(b,c,d){var f,e=a.f.firstChild(c),k=a.J.instance,g=k.preprocessNode;if(g){for(;f=e;)e=a.f.nextSibling(f),g.call(k,f);e=a.f.firstChild(c)}for(;f=e;)e=a.f.nextSibling(f),h(b,f,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.Fb(c);if(k&&d||a.J.instance.nodeHasBindings(c))e=f(c,null,b,d).shouldBindDescendants;e&&!l[a.a.t(c)]&&g(b,c,!k)}function k(b){var c=
[],d={},f=[];a.a.G(b,function y(e){if(!d[e]){var k=a.getBindingHandler(e);k&&(k.after&&(f.push(e),a.a.u(k.after,function(c){if(b[c]){if(-1!==a.a.m(f,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+f.join(", "));y(c)}}),f.length--),c.push({key:e,zb:k}));d[e]=!0}});return c}function f(b,c,f,g){var m=a.a.e.get(b,q);if(!c){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&g&&a.Ob(b,f);var l;if(c&&"function"!==
typeof c)l=c;else{var h=a.J.instance,n=h.getBindingAccessors||e,s=a.j(function(){(l=c?c(f,b):n.call(h,b,f))&&f.I&&f.I();return l},null,{o:b});l&&s.Z()||(s=null)}var v;if(l){var w=s?function(a){return function(){return d(s()[a])}}:function(a){return l[a]},A=function(){return a.a.na(s?s():l,d)};A.get=function(a){return l[a]&&d(w(a))};A.has=function(a){return a in l};g=k(l);a.a.u(g,function(c){var d=c.zb.init,e=c.zb.update,k=c.key;if(8===b.nodeType&&!a.f.Q[k])throw Error("The binding '"+k+"' cannot be used with virtual elements");
try{"function"==typeof d&&a.k.B(function(){var a=d(b,w(k),A,f.$data,f);if(a&&a.controlsDescendantBindings){if(v!==p)throw Error("Multiple bindings ("+v+" and "+k+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");v=k}}),"function"==typeof e&&a.j(function(){e(b,w(k),A,f.$data,f)},null,{o:b})}catch(g){throw g.message='Unable to process binding "'+k+": "+l[k]+'"\nMessage: '+g.message,g;}})}return{shouldBindDescendants:v===p}}
function m(b){return b&&b instanceof a.N?b:new a.N(b)}a.d={};var l={script:!0};a.getBindingHandler=function(b){return a.d[b]};a.N=function(b,c,d,f){var e=this,k="function"==typeof b&&!a.C(b),g,m=a.j(function(){var g=k?b():b,l=a.a.c(g);c?(c.I&&c.I(),a.a.extend(e,c),m&&(e.I=m)):(e.$parents=[],e.$root=l,e.ko=a);e.$rawData=g;e.$data=l;d&&(e[d]=l);f&&f(e,c,l);return e.$data},null,{Ia:function(){return g&&!a.a.ob(g)},o:!0});m.Z()&&(e.I=m,m.equalityComparer=null,g=[],m.Tb=function(b){g.push(b);a.a.w.da(b,
function(b){a.a.ua(g,b);g.length||(m.K(),e.I=m=p)})})};a.N.prototype.createChildContext=function(b,c,d){return new a.N(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.N.prototype.extend=function(b){return new a.N(this.I||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.F(),n=a.a.e.F();a.Ob=function(b,c){if(2==arguments.length)a.a.e.set(b,n,c),
c.I&&c.I.Tb(b);else return a.a.e.get(b,n)};a.ra=function(b,c,d){1===b.nodeType&&a.f.Fb(b);return f(b,c,m(d),!0)};a.Wb=function(d,f,e){e=m(e);return a.ra(d,"function"===typeof f?c(f.bind(null,e,d)):a.a.na(f,b),e)};a.Ca=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(m(a),b,!0)};a.pb=function(a,b){!w&&s.jQuery&&(w=s.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||s.document.body;h(m(a),
b,!0)};a.Ha=function(b){switch(b.nodeType){case 1:case 8:var c=a.Ob(b);if(c)return c;if(b.parentNode)return a.Ha(b.parentNode)}return p};a.$b=function(b){return(b=a.Ha(b))?b.$data:p};a.b("bindingHandlers",a.d);a.b("applyBindings",a.pb);a.b("applyBindingsToDescendants",a.Ca);a.b("applyBindingAccessorsToNode",a.ra);a.b("applyBindingsToNode",a.Wb);a.b("contextFor",a.Ha);a.b("dataFor",a.$b)})();(function(b){function d(d,f){var e=g.hasOwnProperty(d)?g[d]:b,l;e||(e=g[d]=new a.P,c(d,function(a){h[d]=a;delete g[d];
l?e.notifySubscribers(a):setTimeout(function(){e.notifySubscribers(a)},0)}),l=!0);e.U(f)}function c(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a)}):b(null)})}function e(c,d,g,l){l||(l=a.g.loaders.slice(0));var h=l.shift();if(h){var n=h[c];if(n){var t=!1;if(n.apply(h,d.concat(function(a){t?g(null):null!==a?g(a):e(c,d,g,l)}))!==b&&(t=!0,!h.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");
}else e(c,d,g,l)}else g(null)}var g={},h={};a.g={get:function(a,c){var e=h.hasOwnProperty(a)?h[a]:b;e?setTimeout(function(){c(e)},0):d(a,c)},tb:function(a){delete h[a]},jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.tb)})();(function(){function b(b,c,d,e){function k(){0===--u&&e(h)}var h={},u=2,r=d.template;d=d.viewModel;r?g(c,r,function(c){a.g.jb("loadTemplate",[b,c],function(a){h.template=a;k()})}):k();d?g(c,d,function(c){a.g.jb("loadViewModel",
[b,c],function(a){h[f]=a;k()})}):k()}function d(a,b,c){if("function"===typeof b)c(function(a){return new b(a)});else if("function"===typeof b[f])c(b[f]);else if("instance"in b){var e=b.instance;c(function(){return e})}else"viewModel"in b?d(a,b.viewModel,c):a("Unknown viewModel value: "+b)}function c(b){switch(a.a.t(b)){case "script":return a.a.ba(b.text);case "textarea":return a.a.ba(b.value);case "template":if(e(b.content))return a.a.ia(b.content.childNodes)}return a.a.ia(b.childNodes)}function e(a){return s.DocumentFragment?
a instanceof DocumentFragment:a&&11===a.nodeType}function g(a,b,c){"string"===typeof b.require?N||s.require?(N||s.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function h(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.tc=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.Qa(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.Qa=function(a){return a in k};a.g.wc=function(b){delete k[b];a.g.tb(b)};a.g.ub={getConfig:function(a,
b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=h(a);g(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,d,f){b=h(b);if("string"===typeof d)f(a.a.ba(d));else if(d instanceof Array)f(d);else if(e(d))f(a.a.S(d.childNodes));else if(d.element)if(d=d.element,s.HTMLElement?d instanceof HTMLElement:d&&d.tagName&&1===d.nodeType)f(c(d));else if("string"===typeof d){var k=v.getElementById(d);k?f(c(k)):b("Cannot find element with ID "+d)}else b("Unknown element type: "+d);else b("Unknown template value: "+
d)},loadViewModel:function(a,b,c){d(h(a),b,c)}};var f="createViewModel";a.b("components.register",a.g.tc);a.b("components.isRegistered",a.g.Qa);a.b("components.unregister",a.g.wc);a.b("components.defaultLoader",a.g.ub);a.g.loaders.push(a.g.ub);a.g.Ub=k})();(function(){function b(b,e){var g=b.getAttribute("params");if(g){var g=d.parseBindingsString(g,e,b,{valueAccessors:!0,bindingParams:!0}),g=a.a.na(g,function(d){return a.s(d,null,{o:b})}),h=a.a.na(g,function(d){return d.Z()?a.s(function(){return a.a.c(d())},
null,{o:b}):d.v()});h.hasOwnProperty("$raw")||(h.$raw=g);return h}return{$raw:{}}}a.g.getComponentNameForNode=function(b){b=a.a.t(b);return a.g.Qa(b)&&b};a.g.mb=function(c,d,g,h){if(1===d.nodeType){var k=a.g.getComponentNameForNode(d);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var f={name:k,params:b(d,g)};c.component=h?function(){return f}:f}}return c};var d=new a.J;9>a.a.L&&(a.g.register=function(a){return function(b){v.createElement(b);
return a.apply(this,arguments)}}(a.g.register),v.createDocumentFragment=function(b){return function(){var d=b(),g=a.g.Ub,h;for(h in g)g.hasOwnProperty(h)&&d.createElement(h);return d}}(v.createDocumentFragment))})();(function(){var b=0;a.d.component={init:function(d,c,e,g,h){function k(){var a=f&&f.dispose;"function"===typeof a&&a.call(f);m=null}var f,m;a.a.w.da(d,k);a.s(function(){var e=a.a.c(c()),g,n;"string"===typeof e?g=e:(g=a.a.c(e.name),n=a.a.c(e.params));if(!g)throw Error("No component name specified");
var t=m=++b;a.g.get(g,function(b){if(m===t){k();if(!b)throw Error("Unknown component '"+g+"'");var c=b.template;if(!c)throw Error("Component '"+g+"' has no template");c=a.a.ia(c);a.f.T(d,c);var c=n,e=b.createViewModel;b=e?e.call(b,c,{element:d}):c;c=h.createChildContext(b);f=b;a.Ca(c,d)}})},null,{o:d});return{controlsDescendantBindings:!0}}};a.f.Q.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,d){var c=a.a.c(d())||{};a.a.G(c,function(c,d){d=a.a.c(d);var h=
!1===d||null===d||d===p;h&&b.removeAttribute(c);8>=a.a.L&&c in Q?(c=Q[c],h?b.removeAttribute(c):b[c]=d):h||b.setAttribute(c,d.toString());"name"===c&&a.a.Mb(b,h?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,d,c){function e(){var e=b.checked,k=q?h():e;if(!a.Y.ma()&&(!f||e)){var g=a.k.B(d);m?l!==k?(e&&(a.a.ea(g,k,!0),a.a.ea(g,l,!1)),l=k):a.a.ea(g,k,e):a.h.pa(g,c,"checked",k,!0)}}function g(){var c=a.a.c(d());b.checked=m?0<=a.a.m(c,h()):k?c:h()===c}var h=a.Ib(function(){return c.has("checkedValue")?
a.a.c(c.get("checkedValue")):c.has("value")?a.a.c(c.get("value")):b.value}),k="checkbox"==b.type,f="radio"==b.type;if(k||f){var m=k&&a.a.c(d())instanceof Array,l=m?h():p,q=f||m;f&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.s(e,null,{o:b});a.a.n(b,"click",e);a.s(g,null,{o:b})}}};a.h.V.checked=!0;a.d.checkedValue={update:function(b,d){b.value=a.a.c(d())}}})();a.d.css={update:function(b,d){var c=a.a.c(d());"object"==typeof c?a.a.G(c,function(c,d){d=a.a.c(d);a.a.Ba(b,c,d)}):(c=String(c||""),
a.a.Ba(b,b.__ko__cssValue,!1),b.__ko__cssValue=c,a.a.Ba(b,c,!0))}};a.d.enable={update:function(b,d){var c=a.a.c(d());c&&b.disabled?b.removeAttribute("disabled"):c||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,d){a.d.enable.update(b,function(){return!a.a.c(d())})}};a.d.event={init:function(b,d,c,e,g){var h=d()||{};a.a.G(h,function(k){"string"==typeof k&&a.a.n(b,k,function(b){var h,l=d()[k];if(l){try{var q=a.a.S(arguments);e=g.$data;q.unshift(e);h=l.apply(e,q)}finally{!0!==h&&(b.preventDefault?
b.preventDefault():b.returnValue=!1)}!1===c.get(k+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={Eb:function(b){return function(){var d=b(),c=a.a.Xa(d);if(!c||"number"==typeof c.length)return{foreach:d,templateEngine:a.O.Oa};a.a.c(d);return{foreach:c.data,as:c.as,includeDestroyed:c.includeDestroyed,afterAdd:c.afterAdd,beforeRemove:c.beforeRemove,afterRender:c.afterRender,beforeMove:c.beforeMove,afterMove:c.afterMove,templateEngine:a.O.Oa}}},init:function(b,
d){return a.d.template.init(b,a.d.foreach.Eb(d))},update:function(b,d,c,e,g){return a.d.template.update(b,a.d.foreach.Eb(d),c,e,g)}};a.h.ha.foreach=!1;a.f.Q.foreach=!0;a.d.hasfocus={init:function(b,d,c){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(h){g=f.body}e=g===b}f=d();a.h.pa(f,c,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var g=e.bind(null,!0),h=e.bind(null,!1);a.a.n(b,"focus",g);a.a.n(b,"focusin",
g);a.a.n(b,"blur",h);a.a.n(b,"focusout",h)},update:function(b,d){var c=!!a.a.c(d());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===c||(c?b.focus():b.blur(),a.k.B(a.a.oa,null,[b,c?"focusin":"focusout"]))}};a.h.V.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.V.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,d){a.a.$a(b,d())}};I("if");I("ifnot",!1,!0);I("with",!0,!1,function(a,d){return a.createChildContext(d)});var K={};a.d.options={init:function(b){if("select"!==
a.a.t(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,d,c){function e(){return a.a.ta(b.options,function(a){return a.selected})}function g(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function h(c,d){if(q.length){var e=0<=a.a.m(q,a.i.q(d[0]));a.a.Nb(d[0],e);n&&!e&&a.k.B(a.a.oa,null,[b,"change"])}}var k=0!=b.length&&b.multiple?b.scrollTop:null,f=a.a.c(d()),m=c.get("optionsIncludeDestroyed");
d={};var l,q;q=b.multiple?a.a.Da(e(),a.i.q):0<=b.selectedIndex?[a.i.q(b.options[b.selectedIndex])]:[];f&&("undefined"==typeof f.length&&(f=[f]),l=a.a.ta(f,function(b){return m||b===p||null===b||!a.a.c(b._destroy)}),c.has("optionsCaption")&&(f=a.a.c(c.get("optionsCaption")),null!==f&&f!==p&&l.unshift(K)));var n=!1;d.beforeRemove=function(a){b.removeChild(a)};f=h;c.has("optionsAfterRender")&&(f=function(b,d){h(0,d);a.k.B(c.get("optionsAfterRender"),null,[d[0],b!==K?b:p])});a.a.Za(b,l,function(d,e,f){f.length&&
(q=f[0].selected?[a.i.q(f[0])]:[],n=!0);e=b.ownerDocument.createElement("option");d===K?(a.a.bb(e,c.get("optionsCaption")),a.i.ca(e,p)):(f=g(d,c.get("optionsValue"),d),a.i.ca(e,a.a.c(f)),d=g(d,c.get("optionsText"),f),a.a.bb(e,d));return[e]},d,f);a.k.B(function(){c.get("valueAllowUnset")&&c.has("value")?a.i.ca(b,a.a.c(c.get("value")),!0):(b.multiple?q.length&&e().length<q.length:q.length&&0<=b.selectedIndex?a.i.q(b.options[b.selectedIndex])!==q[0]:q.length||0<=b.selectedIndex)&&a.a.oa(b,"change")});
a.a.dc(b);k&&20<Math.abs(k-b.scrollTop)&&(b.scrollTop=k)}};a.d.options.Va=a.a.e.F();a.d.selectedOptions={after:["options","foreach"],init:function(b,d,c){a.a.n(b,"change",function(){var e=d(),g=[];a.a.u(b.getElementsByTagName("option"),function(b){b.selected&&g.push(a.i.q(b))});a.h.pa(e,c,"selectedOptions",g)})},update:function(b,d){if("select"!=a.a.t(b))throw Error("values binding applies only to SELECT elements");var c=a.a.c(d());c&&"number"==typeof c.length&&a.a.u(b.getElementsByTagName("option"),
function(b){var d=0<=a.a.m(c,a.i.q(b));a.a.Nb(b,d)})}};a.h.V.selectedOptions=!0;a.d.style={update:function(b,d){var c=a.a.c(d()||{});a.a.G(c,function(c,d){d=a.a.c(d);if(null===d||d===p||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,d,c,e,g){if("function"!=typeof d())throw Error("The value for a submit binding must be a function");a.a.n(b,"submit",function(a){var c,e=d();try{c=e.call(g.$data,b)}finally{!0!==c&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},
update:function(b,d){a.a.bb(b,d())}};a.f.Q.text=!0;(function(){if(s&&s.navigator)var b=function(a){if(a)return parseFloat(a[1])},d=s.opera&&s.opera.version&&parseInt(s.opera.version()),c=s.navigator.userAgent,e=b(c.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),g=b(c.match(/Firefox\/([^ ]*)/));if(10>a.a.L)var h=a.a.e.F(),k=a.a.e.F(),f=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,h)||(a.a.e.set(d,h,!0),a.a.n(d,"selectionchange",
f));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,c,f){function k(c,d){a.a.n(b,c,d)}function h(){var d=a.a.c(c());if(null===d||d===p)d="";v!==p&&d===v?setTimeout(h,4):b.value!==d&&(s=d,b.value=d)}function u(){y||(v=b.value,y=setTimeout(r,4))}function r(){clearTimeout(y);v=y=p;var d=b.value;s!==d&&(s=d,a.h.pa(c(),f,"textInput",d))}var s=b.value,y,v;10>a.a.L?(k("propertychange",function(a){"value"===a.propertyName&&r()}),8==a.a.L&&(k("keyup",r),k("keydown",r)),8<=a.a.L&&(m(b,r),k("dragend",u))):
(k("input",r),5>e&&"textarea"===a.a.t(b)?(k("keydown",u),k("paste",u),k("cut",u)):11>d?k("keydown",u):4>g&&(k("DOMAutoComplete",r),k("dragdrop",r),k("drop",r)));k("change",r);a.s(h,null,{o:b})}};a.h.V.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,d){if(d()){var c="ko_unique_"+ ++a.d.uniqueName.Zb;a.a.Mb(b,c)}}};a.d.uniqueName.Zb=0;a.d.value={after:["options","foreach"],init:function(b,d,c){if("input"!=b.tagName.toLowerCase()||"checkbox"!=
b.type&&"radio"!=b.type){var e=["change"],g=c.get("valueUpdate"),h=!1,k=null;g&&("string"==typeof g&&(g=[g]),a.a.ga(e,g),e=a.a.rb(e));var f=function(){k=null;h=!1;var e=d(),f=a.i.q(b);a.h.pa(e,c,"value",f)};!a.a.L||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.m(e,"propertychange")||(a.a.n(b,"propertychange",function(){h=!0}),a.a.n(b,"focus",function(){h=!1}),a.a.n(b,"blur",function(){h&&f()}));a.a.u(e,function(c){var d=f;a.a.vc(c,
"after")&&(d=function(){k=a.i.q(b);setTimeout(f,0)},c=c.substring(5));a.a.n(b,c,d)});var m=function(){var e=a.a.c(d()),f=a.i.q(b);if(null!==k&&e===k)setTimeout(m,0);else if(e!==f)if("select"===a.a.t(b)){var g=c.get("valueAllowUnset"),f=function(){a.i.ca(b,e,g)};f();g||e===a.i.q(b)?setTimeout(f,0):a.k.B(a.a.oa,null,[b,"change"])}else a.i.ca(b,e)};a.s(m,null,{o:b})}else a.ra(b,{checkedValue:d})},update:function(){}};a.h.V.value=!0;a.d.visible={update:function(b,d){var c=a.a.c(d()),e="none"!=b.style.display;
c&&!e?b.style.display="":!c&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(d,c,e,g,h){return a.d.event.init.call(this,d,function(){var a={};a[b]=c();return a},e,g,h)}}})("click");a.H=function(){};a.H.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.H.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.H.prototype.makeTemplateSource=function(b,d){if("string"==typeof b){d=d||v;var c=
d.getElementById(b);if(!c)throw Error("Cannot find template with ID "+b);return new a.r.l(c)}if(1==b.nodeType||8==b.nodeType)return new a.r.fa(b);throw Error("Unknown template type: "+b);};a.H.prototype.renderTemplate=function(a,d,c,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,d,c)};a.H.prototype.isTemplateRewritten=function(a,d){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,d).data("isRewritten")};a.H.prototype.rewriteTemplate=function(a,d,c){a=this.makeTemplateSource(a,
c);d=d(a.text());a.text(d);a.data("isRewritten",!0)};a.b("templateEngine",a.H);a.fb=function(){function b(b,c,d,k){b=a.h.Wa(b);for(var f=a.h.ha,m=0;m<b.length;m++){var l=b[m].key;if(f.hasOwnProperty(l)){var q=f[l];if("function"===typeof q){if(l=q(b[m].value))throw Error(l);}else if(!q)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.ya(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+
"')";return k.createJavaScriptEvaluatorBlock(d)+c}var d=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,c=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{ec:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.fb.nc(b,c)},d)},nc:function(a,g){return a.replace(d,function(a,c,d,e,l){return b(l,c,d,g)}).replace(c,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",g)})},Xb:function(b,c){return a.D.Ua(function(d,
k){var f=d.nextSibling;f&&f.nodeName.toLowerCase()===c&&a.ra(f,b,k)})}}}();a.b("__tr_ambtns",a.fb.Xb);(function(){a.r={};a.r.l=function(a){this.l=a};a.r.l.prototype.text=function(){var b=a.a.t(this.l),b="script"===b?"text":"textarea"===b?"value":"innerHTML";if(0==arguments.length)return this.l[b];var d=arguments[0];"innerHTML"===b?a.a.$a(this.l,d):this.l[b]=d};var b=a.a.e.F()+"_";a.r.l.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.l,b+c);a.a.e.set(this.l,b+c,arguments[1])};
var d=a.a.e.F();a.r.fa=function(a){this.l=a};a.r.fa.prototype=new a.r.l;a.r.fa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.l,d)||{};b.gb===p&&b.Ga&&(b.gb=b.Ga.innerHTML);return b.gb}a.a.e.set(this.l,d,{gb:arguments[0]})};a.r.l.prototype.nodes=function(){if(0==arguments.length)return(a.a.e.get(this.l,d)||{}).Ga;a.a.e.set(this.l,d,{Ga:arguments[0]})};a.b("templateSources",a.r);a.b("templateSources.domElement",a.r.l);a.b("templateSources.anonymousTemplate",a.r.fa)})();(function(){function b(b,
c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function d(c,d){if(c.length){var e=c[0],g=c[c.length-1],h=e.parentNode,n=a.J.instance,t=n.preprocessNode;if(t){b(e,g,function(a,b){var c=a.previousSibling,d=t.call(n,a);d&&(a===e&&(e=d[0]||b),a===g&&(g=d[d.length-1]||c))});c.length=0;if(!e)return;e===g?c.push(e):(c.push(e,g),a.a.ka(c,h))}b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.pb(d,b)});b(e,g,function(b){1!==b.nodeType&&8!==b.nodeType||a.D.Sb(b,[d])});a.a.ka(c,
h)}}function c(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,h,l,q){q=q||{};var n=b&&c(b),n=n&&n.ownerDocument,t=q.templateEngine||g;a.fb.ec(h,t,n);h=t.renderTemplate(h,l,q,n);if("number"!=typeof h.length||0<h.length&&"number"!=typeof h[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.f.T(b,h);n=!0;break;case "replaceNode":a.a.Lb(b,h);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+
e);}n&&(d(h,l),q.afterRender&&a.k.B(q.afterRender,null,[h,l.$data]));return h}var g;a.ab=function(b){if(b!=p&&!(b instanceof a.H))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Ya=function(b,d,h,l,q){h=h||{};if((h.templateEngine||g)==p)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(l){var n=c(l);return a.j(function(){var g=d&&d instanceof a.N?d:new a.N(a.a.c(d)),p=a.C(b)?b():"function"===typeof b?b(g.$data,g):b,g=e(l,q,p,g,h);
"replaceNode"==q&&(l=g,n=c(l))},null,{Ia:function(){return!n||!a.a.Ja(n)},o:n&&"replaceNode"==q?n.parentNode:n})}return a.D.Ua(function(c){a.Ya(b,d,h,c,"replaceNode")})};a.uc=function(b,c,g,h,q){function n(a,b){d(b,s);g.afterRender&&g.afterRender(b,a)}function t(c,d){s=q.createChildContext(c,g.as,function(a){a.$index=d});var f=a.C(b)?b():"function"===typeof b?b(c,s):b;return e(null,"ignoreTargetNode",f,s,g)}var s;return a.j(function(){var b=a.a.c(c)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.ta(b,
function(b){return g.includeDestroyed||b===p||null===b||!a.a.c(b._destroy)});a.k.B(a.a.Za,null,[h,b,t,g,n])},null,{o:h})};var h=a.a.e.F();a.d.template={init:function(b,c){var d=a.a.c(c());"string"==typeof d||d.name?a.f.ja(b):(d=a.f.childNodes(b),d=a.a.oc(d),(new a.r.fa(b)).nodes(d));return{controlsDescendantBindings:!0}},update:function(b,c,d,e,g){var n=c(),t;c=a.a.c(n);d=!0;e=null;"string"==typeof c?c={}:(n=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)),t=a.a.c(c.data));
"foreach"in c?e=a.uc(n||b,d&&c.foreach||[],c,b,g):d?(g="data"in c?g.createChildContext(t,c.as):g,e=a.Ya(n||b,g,c,b)):a.f.ja(b);g=e;(t=a.a.e.get(b,h))&&"function"==typeof t.K&&t.K();a.a.e.set(b,h,g&&g.Z()?g:p)}};a.h.ha.template=function(b){b=a.h.Wa(b);return 1==b.length&&b[0].unknown||a.h.lc(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Q.template=!0})();a.b("setTemplateEngine",a.ab);a.b("renderTemplate",a.Ya);a.a.wb=function(a,d,c){if(a.length&&
d.length){var e,g,h,k,f;for(e=g=0;(!c||e<c)&&(k=a[g]);++g){for(h=0;f=d[h];++h)if(k.value===f.value){k.moved=f.index;f.moved=k.index;d.splice(h,1);e=h=0;break}e+=h}}};a.a.Fa=function(){function b(b,c,e,g,h){var k=Math.min,f=Math.max,m=[],l,q=b.length,n,p=c.length,s=p-q||1,u=q+p+1,r,v,w;for(l=0;l<=q;l++)for(v=r,m.push(r=[]),w=k(p,l+s),n=f(0,l-1);n<=w;n++)r[n]=n?l?b[l-1]===c[n-1]?v[n-1]:k(v[n]||u,r[n-1]||u)+1:n+1:l+1;k=[];f=[];s=[];l=q;for(n=p;l||n;)p=m[l][n]-1,n&&p===m[l][n-1]?f.push(k[k.length]={status:e,
value:c[--n],index:n}):l&&p===m[l-1][n]?s.push(k[k.length]={status:g,value:b[--l],index:l}):(--n,--l,h.sparse||k.push({status:"retained",value:c[n]}));a.a.wb(f,s,10*q);return k.reverse()}return function(a,c,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];c=c||[];return a.length<=c.length?b(a,c,"added","deleted",e):b(c,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Fa);(function(){function b(b,d,g,h,k){var f=[],m=a.j(function(){var l=d(g,k,a.a.ka(f,b))||[];0<f.length&&(a.a.Lb(f,
l),h&&a.k.B(h,null,[g,l,k]));f.length=0;a.a.ga(f,l)},null,{o:b,Ia:function(){return!a.a.ob(f)}});return{$:f,j:m.Z()?m:p}}var d=a.a.e.F();a.a.Za=function(c,e,g,h,k){function f(b,d){x=q[d];r!==d&&(A[b]=x);x.Na(r++);a.a.ka(x.$,c);s.push(x);w.push(x)}function m(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.u(c[d].$,function(a){b(a,d,c[d].sa)})}e=e||[];h=h||{};var l=a.a.e.get(c,d)===p,q=a.a.e.get(c,d)||[],n=a.a.Da(q,function(a){return a.sa}),t=a.a.Fa(n,e,h.dontLimitMoves),s=[],u=0,r=0,v=[],w=[];e=
[];for(var A=[],n=[],x,B=0,D,F;D=t[B];B++)switch(F=D.moved,D.status){case "deleted":F===p&&(x=q[u],x.j&&x.j.K(),v.push.apply(v,a.a.ka(x.$,c)),h.beforeRemove&&(e[B]=x,w.push(x)));u++;break;case "retained":f(B,u++);break;case "added":F!==p?f(B,F):(x={sa:D.value,Na:a.p(r++)},s.push(x),w.push(x),l||(n[B]=x))}m(h.beforeMove,A);a.a.u(v,h.beforeRemove?a.R:a.removeNode);for(var B=0,l=a.f.firstChild(c),G;x=w[B];B++){x.$||a.a.extend(x,b(c,g,x.sa,k,x.Na));for(u=0;t=x.$[u];l=t.nextSibling,G=t,u++)t!==l&&a.f.Bb(c,
t,G);!x.ic&&k&&(k(x.sa,x.$,x.Na),x.ic=!0)}m(h.beforeRemove,e);m(h.afterMove,A);m(h.afterAdd,n);a.a.e.set(c,d,s)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Za);a.O=function(){this.allowTemplateRewriting=!1};a.O.prototype=new a.H;a.O.prototype.renderTemplateSource=function(b){var d=(9>a.a.L?0:b.nodes)?b.nodes():null;if(d)return a.a.S(d.cloneNode(!0).childNodes);b=b.text();return a.a.ba(b)};a.O.Oa=new a.O;a.ab(a.O.Oa);a.b("nativeTemplateEngine",a.O);(function(){a.Sa=function(){var a=this.kc=
function(){if(!w||!w.tmpl)return 0;try{if(0<=w.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,g){g=g||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=w.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=w.extend({koBindingContext:e},g.templateOptions);e=w.tmpl(h,
b,e);e.appendTo(v.createElement("div"));w.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){v.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(w.tmpl.tag.ko_code={open:"__.push($1 || '');"},w.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.Sa.prototype=new a.H;var b=new a.Sa;0<b.kc&&a.ab(b);a.b("jqueryTmplTemplateEngine",a.Sa)})()})})();})();

// knockout-postbox 0.4.2 | (c) 2013 Ryan Niemeyer |  http://www.opensource.org/licenses/mit-license
!function(a){"function"==typeof require&&"object"==typeof exports&&"object"==typeof module?a(require("knockout"),exports):"function"==typeof define&&define.amd?define(["knockout","exports"],a):a(ko,ko.postbox={})}(function(a,b,c){var d,e;a.subscribable.call(b),b.topicCache={},b.serializer=a.toJSON,b.publish=function(a,c){a&&(b.topicCache[a]={value:c,serialized:b.serializer(c)},b.notifySubscribers(c,a))},e=b.subscribe,b.subscribe=function(a,d,f,g){var h,i;return a?("boolean"==typeof f&&(g=f,f=c),h=e.call(b,d,f,a),g&&(i=b.topicCache[a],i!==c&&d.call(f,i.value)),h):void 0},b.defaultComparer=function(a,c){return c&&b.serializer(a)===c.serialized},a.subscribable.fn.publishOn=function(a,c,e){var f;return a&&("function"==typeof c?e=c:f=c,e=e||b.defaultComparer,d.call(this,a,"publishOn"),this.postboxSubs[a].publishOn=this.subscribe(function(c){e.call(this,c,b.topicCache[a])||b.publish(a,c)},this),f||b.publish(a,this())),this},d=function(a,b){var c=this.postboxSubs=this.postboxSubs||{};c[a]=c[a]||{},c[a][b]&&c[a][b].dispose()},a.subscribable.fn.stopPublishingOn=function(a){return d.call(this,a,"publishOn"),this},a.subscribable.fn.subscribeTo=function(e,f,g){var h,i,j,k=this;return"function"==typeof f?g=f:h=f,e&&a.isWriteableObservable(this)&&(d.call(this,e,"subscribeTo"),j=function(a){k(g?g.call(k,a):a)},this.postboxSubs[e].subscribeTo=b.subscribe(e,j),h&&(i=b.topicCache[e],i!==c&&j(i.value))),this},a.subscribable.fn.unsubscribeFrom=function(a){return d.call(this,a,"subscribeTo"),this},a.subscribable.fn.syncWith=function(a,b,c,d){return this.subscribeTo(a,b).publishOn(a,c,d),this},a.postbox=b});
function CalibrateCameras(cameras){
    var self = this;
    self.cameras = cameras;
    self.cameraPositionChanged = ko.observable(false);

    for(var i = 0; i < cameras.length; i++){
        var cam = cameras[i];
        cam.position.subscribe(function(newVal){
            self.cameraPositionChanged(true);
        });
        for(var j = 0; j < cam.options.length; j++ ){
            cam.options[j].subscribe(function(newVal){
                self.cameraPositionChanged(true);
            });
        }
    }

    self.calibrateCameraPositions = function(){
        if( self.cameraPositionChanged() ){
            var cal_parameters = {};
            cal_parameters.name = "cameras";
            cal_parameters.select_type = "save";
            cal_parameters.parameters = {};
            cal_parameters.parameters.camera_positions = {};

            for( var i = 0; i < self.cameras.length; i++){
                cal_parameters.parameters.camera_positions["camera" + i + "_position"] = self.cameras[i].pos_int();
            }
            calibrate(cal_parameters);
            self.cameraPositionChanged(false);
        }
    }

    function calibrate(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function CalibrateLiquidSensor(monitor){
    var self = this;
    Common.apply(self, arguments);
    self.monitor = monitor;
    self.liquid_calibration_message = ko.observable(" ");
    self.liquid_calibration_status = ko.observable("CALIBRATE");


    self.calibrateLiquidSensor = function(){
        var cal_parameters = {};
        cal_parameters.name = "liquid_sensors";
        cal_parameters.select_type = "save";
        cal_parameters.parameters = {};
        cal_parameters.parameters.sensor_number = self.liquidSensorNumber();

        if(self.liquid_calibration_status()=="CALIBRATE"){
            self.liquid_calibration_message("Remove tube");
            self.liquid_calibration_status("SAVE NO TUBE");
            return;
        }
        else if(self.liquid_calibration_status()=="SAVE NO TUBE"){
            self.liquid_calibration_message("Add tubing");
            self.liquid_calibration_status("SAVE TUBE ONLY");
            cal_parameters.parameters.parameter = "no_tube_present_counts";
        }
        else if(self.liquid_calibration_status()=="SAVE TUBE ONLY"){
            self.liquid_calibration_message("Add liquid to tube");
            self.liquid_calibration_status("SAVE LIQUID");
            cal_parameters.parameters.parameter = "no_liquid_present_counts";
        }
        else if(self.liquid_calibration_status()=="SAVE LIQUID"){
            self.liquid_calibration_message("Calibration Complete");
            self.liquid_calibration_status("CALIBRATE");
            cal_parameters.parameters.parameter = "liquid_present_counts";
        }
       calibrate(cal_parameters);
    }

    self.cancel = function(){
        self.liquid_calibration_status("CALIBRATE");
        self.liquid_calibration_message(" ");
    }

    function calibrate(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function CalibrateMixers(mixers){
    var self = this;
    self.mixers = mixers;
    self.mixerCalibrationChanged = ko.observable(false);

    for( var i = 0; i < self.mixers.length; i++){
        var mixer = self.mixers[i];
        mixer.dutyCycle.subscribe(function(oldVal){
            if( oldVal ){
                self.mixerCalibrationChanged(true);
            }
        }, null, "beforeChange");
    }

    self.saveMixerCalibrations = function(){
        var cal_parameters = {};
        cal_parameters.name = "mixers";
        cal_parameters.select_type = "save";
        cal_parameters.parameters = {};
        var mixers = []
        for( var i = 0; i < self.mixers.length; i++ ){
            var mixer = self.mixers[i];
            mixers.push({
                reactor: mixer.reactorId,
                duty_cycle: mixer.dutyCycle()
            });
            mixer.defaultCycle = mixer.dutyCycle();
        }
        cal_parameters.parameters.mixers = mixers;
        calibrate(cal_parameters);
        self.mixerCalibrationChanged(false);
    }

    function calibrate(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function PressureRegulatorsCalibrations(pressureRegs){
    var self = this;
    self.pressureRegulators = pressureRegs;

    self.calibratePressureState = ko.observable("calibrate");
    self.canCalibratePressure = ko.observable(true);
    self.calibratePressureReadIn = ko.observable(0);
    self.calibratePressureInstructions = ko.observable("Please Wait");
    self.calibrationMonitor = undefined;
    self.calibratingRegulator = ko.observable("");
    self.displayCalibrate = ko.pureComputed(function(){
        return self.calibratePressureState() != "calibrate";
    });
    self.pressureCalibrateBtnText = ko.pureComputed(function(){
        var btnText = "";
        switch(self.calibratePressureState()){
            case "calibrate":
                btnText = "CALIBRATE";
                break;
            case "calibrating":
                btnText = "CONTINUE";
                break;
            default:
                btnText = "Not Defined";
                break;
        }
        return btnText;
    });

    self.pressure_abort = function(){
        var cal = {};
        cal.name = "pressure_regulators";
        cal.select_type = "control";
        cal.parameters = {control_type: "abort"};
        calibrate(cal);
    }

    self.calibratePressureRegulators = function(){
        switch(self.calibratePressureState()){
            case "calibrate":
                self.calibratePressureState("calibrating");
                var cal = {};
                cal.name = "pressure_regulators";
                cal.select_type = "control";
                cal.parameters = {control_type: "calibrate"};
                calibrate(cal);
                self.calibrationMonitor = setInterval(function(){
                    var cal = {};
                    cal.name = "pressure_regulators";
                    cal.select_type = "control";
                    cal.parameters = {"control_type": "poll"}
                    calibrate(cal, function(resp){
                        if( resp.calibrate.is_calibrating ){
                            self.calibratePressureState("calibrating");
                            self.calibratePressureInstructions(resp.calibrate.message);
                            self.calibratingRegulator(resp.calibrate.calibrating_regulator)
                        }
                        else{
                            self.calibratePressureState("calibrate");
                        }
                    });
                }, 1000);
                break;
            case "calibrating":
                self.calibratePressureState("calibrating");
                var cal = {};
                cal.name = "pressure_regulators";
                cal.select_type = "control";
                cal.parameters = {control_type: "calibrate", response: self.calibratePressureReadIn()};
                calibrate(cal);
                break;
            default:
                self.calibratePressureState("calibrate");
                console.log("Not a valid calibration step");
        }
    }

    function calibrate(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function ReactorCalibrations(reactors, pneumaticPressure){
    var self = this;
     self.reactors = reactors;
     self.isCalibrating = ko.observable(false);
     self.reactorToCalIndex = ko.observable(0);
     self.pneumaticPressure = pneumaticPressure;
     self.reactorToCal = ko.pureComputed(function(){
        return self.reactors[parseInt(self.reactorToCalIndex())];
     });

     self.doCalibrate = function(){
        self.pneumaticPressure.setPoint(0);//User will be manually moving the reactor up/down/forward/back

        for(var i = 0; i < self.reactors.length; i++){
            var reactor = self.reactors[i];
            reactor.brakeRelease();
            reactor.ctrlMode("edit");
        }
        self.isCalibrating(true);
     }

     self.cancel = function(){
        for(var i = 0; i < self.reactors.length; i++ ){
            self.reactors[i].ctrlMode("command");
        }
        self.isCalibrating(false);
     }
     
     self.reactorCalibrating = ko.pureComputed(function(){
        if( self.isCalibrating() ){
            return self.reactors[self.reactorToCalIndex()];
        }
        return null;
     });

     self.save = function(){
        if(self.isCalibrating()){
           var reactor = self.reactorCalibrating();
           if( reactor.selectedPosition() !== null ){
               var cal = {};
               var position = reactor.selectedPosition();
               cal.name = "reactors";
               cal.select_type = "save";
               cal.parameters = {"reactor": reactor.reactorId, "position": position};
               self.calibrate(cal);
           }
        }
     }

     self.doneCalibrating = function(){
        for( var i = 0; i < self.reactors.length; i++ ){
            reactors[i].ctrlMode("command");
        }
        self.isCalibrating(false);
     }

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function CalibrateCassettes(reagentRobot, cassettes){
    var self = this;
    self.cassettes = cassettes;
    self.reagentRobot = reagentRobot;
    self.selectedCassetteIndex = ko.observable(0);

    self.selectedCassette = ko.pureComputed(function(){
        if( self.selectedCassetteIndex() >= 0 && self.selectedCassetteIndex() < self.cassettes.length )
            return self.cassettes[parseInt(self.selectedCassetteIndex())];
        return null;
    });

    self.reagentToCal = ko.pureComputed(function(){
        var cassette = self.selectedCassette();
        if( cassette ){
            return cassette.selectedReagent();
        }
    });

    self.isCalibrating = ko.observable(false);

    for(var i=0; i < self.cassettes.length; i++){
        var cassette = self.cassettes[i];
        function moveToReagentOnSelect(cassette){
            cassette.selectedReagent.subscribeChanged(function(newVal, oldVal){
                self.deselectOtherCassettes();
                if( !self.isCalibrating() ){
                    if( !cassette.selectedReagent().isOperation ){
                        self.reagentRobot.moveToReagent(cassette.selectedReagent());
                    }
                    else{
                        self.moveToOperationPosition(cassette.selectedReagent().position, cassette.selectedReagent().cassetteId);
                    }
                }
            });
        }
        moveToReagentOnSelect(cassette);
    }

    self.deselectOtherCassettes = function(){
        for(var j=0; j < self.cassettes.length; j++){
            var cas = self.cassettes[j];
            if( cas != self.selectedCassette() )
                cas.selectedReagentIndex(-1);
        }
    }

    self.doCalibrate = function(){
        self.isCalibrating(true);
    }

    self.isCalibrating.subscribe(function(newVal){
        if( newVal ){
            self.reagentXSubscription = self.reagentRobot.x.subscribe(function(newVal){
                if(self.reagentToCal()){
                    self.reagentToCal().x(newVal);
                }
            });
            self.reagentYSubscription = self.reagentRobot.y.subscribe(function(newVal){
                if(self.reagentToCal()){
                    self.reagentToCal().y(newVal);
                }
            });
        }
        else{
            self.reagentXSubscription.dispose();
            self.reagentYSubscription.dispose();
        }
    });

    self.moveToOperationPosition = function(positionName, reactor){
        self.reagentRobot.moveToOperation(positionName, reactor);
    }

    self.save = function(){
        if( self.isCalibrating() ){
            var cal = {};
            cal.name = "reagent_robot";
            cal.select_type = "save";
            var reagent = self.reagentToCal();

            if( reagent ){
                cal.parameters = {reactor: reagent.cassetteId, position: reagent.position,
                                  x: reagent.x(), y: reagent.y()};
                self.calibrate(cal, function(res){
                    reagent.isCalibrated(true);
                });
            }
        }
    }

    self.stopCalibrate = function(){
        self.isCalibrating(false);
        for(var i=0; i < self.cassettes.length; i++){
            self.cassettes[i].getReagentPositions();
        }
		for(var i=0; i < self.cassettes.length; i++){
            var cassette = self.cassettes[i];
            for(var j=0; j < cassette.reagents.length; j++){
                cassette.reagents[j].isCalibrated(false);
            }
        }
    }

    self.calibrate = function(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function ReagentRobotCalibration(reagentRobot){
    var self = this;
    self.reagentRobot = reagentRobot;
    self.selectedPosition = ko.observable();
    self.selectPosition = function(pos){
        self.selectedPosition(pos);
    }
    self.isCalibrating = ko.observable(false);

    self.doCalibrate = function(){
       self.isCalibrating(true);
    }

    self.cancel = function(){
       self.isCalibrating(false);
    }

    self.save = function(){
       var cal = {};
       cal.name = "reagent_robot";
       cal.select_type = "save";
       cal.parameters = {"reactor": reactor.reactorId, "position": reactor.selectedPosition(),
                         "x": self.reagentRobot.x(), "y": self.reagentRobot.y()};
       self.calibrate(cal);
       self.isCalibrating(false);
    }

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function Camera(options){
    var self = this;
    Common.apply(self, arguments);
    var cameraPositions = [camera0_position, camera1_position, camera2_position];
    self.cameraId = ko.observable(options.cameraId);
    self.cameraName = self.cameraId() + 1;
    self.src = ko.observable(self.videoUrl[self.cameraId()]);
    self.right_max = 0;//px
    self.left_max = -230;//px

    self.resetText = ko.observable("");
    self.brightness = ko.observable(32768);
    self.contrast = ko.observable(27648);
    self.saturation = ko.observable(32768);
    self.hue = ko.observable(32768);
    self.chroma_agc = ko.observable(false);
    self.agc_crush = ko.observable(true);
    self.uv_ratio = ko.observable(50);
    self.options = [self.brightness, self.contrast, self.saturation,
                    self.hue, self.chroma_agc,self.agc_crush,self.uv_ratio];

    self.position = ko.observable(cameraPositions[self.cameraId()]);

    self.pos_int = ko.pureComputed(function(){
        return parseInt(self.position());
    });

    self.canIncreasePos = ko.pureComputed(function(){
        return self.pos_int() < self.right_max;
    });
    self.canDecreasePos = ko.pureComputed(function(){
        return self.pos_int() > self.left_max;
    });

    self.moveHorizontal = function(dx){
        var pos_int = self.pos_int();
        pos_int = pos_int + dx;
        self.position(pos_int + "px");
    }
    self.incPosition = function(){
        self.moveHorizontal(5);
    }
    self.decPosition = function(){
        self.moveHorizontal(-5);
    }
    self.resetVideo = function(){
        self.resetText("RESETTING...");
        Elixys.doApiCall("/video_reset", {video_reset : {"camera_id": self.cameraId()}}, function(res){
            self.setDefaultResetText();
        });
    }
    self.setDefaultResetText = function(){
        self.resetText("Reset Feed " + self.cameraName);
        self.src("");
        self.src(self.videoUrl[self.cameraId()]);
    }

    self.setDefaultResetText();

    self.doCalibrate = function(params){
        var cal = {};
        cal.name = "cameras";
        cal.select_type = "control";
        params["camera"] = self.cameraId();
        params["type"] = "set";
        cal.parameters = params;
        calibrate(cal);
    }

    self.loadDefaults = function(){
        var cal = {};
        var params = {};
        cal.name = "cameras";
        cal.select_type = "control";
        params["camera"] = self.cameraId();
        params["type"] = "query";
        cal.parameters = params;

        calibrate(cal, function(res){
            if( res.calibrate && res.calibrate != "ok"){
                res = JSON.parse(res.calibrate);
                self.brightness(res.brightness);
                self.contrast(res.contrast);
                self.saturation(res.saturation);
                self.hue(res.hue);
                self.chroma_agc(res.chroma_agc == 1 ? true : false);// = ko.observable(false);
                self.agc_crush(res.agc_crush == 1 ? true : false);// = ko.observable(true);
                self.uv_ratio(res.uv_ratio);// = ko.observable(50);
            }

            self.brightness.subscribe(function(newVal){
                self.doCalibrate({"option": "brightness", "value": newVal});
            });
            self.contrast.subscribe(function(newVal){
                self.doCalibrate({"option": "contrast", "value": newVal});
            });
            self.saturation.subscribe(function(newVal){
                self.doCalibrate({"option": "saturation", "value": newVal});
            });
            self.hue.subscribe(function(newVal){
                self.doCalibrate({"option": "hue", "value": newVal});
            });
            self.agc_crush.subscribe(function(newVal){
                self.doCalibrate({"option": "agc_crush", "value": newVal ? 1 : 0});
            });
            self.chroma_agc.subscribe(function(newVal){
                self.doCalibrate({"option": "chroma_agc", "value": newVal ? 1 : 0});
            });
            self.uv_ratio.subscribe(function(newVal){
                self.doCalibrate({"option": "uv_ratio", "value": newVal});
            });
        });
    }

    function calibrate(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }

    self.loadDefaults();
    self.setDefaultResetText();
}
function ElixysMonitor(){
    var self = this;
    Common.apply(self, arguments);

    self.state = {
        hplc: ko.observableArray(),
        liquid_sensor: {
            value: displayRoundingDown(30.0, 1)
        },
        valves: ko.observableArray(),
        mixers: ko.observableArray(),
        heaters: ko.observableArray(),
        thermocouples: ko.observableArray(),
        vacuumPump: ko.observableArray(),
        smcInterface: ko.observableArray(),
        pressureRegulators: ko.observableArray(),
        coolantPump: ko.observableArray(),
        digitalInputs: ko.observableArray(),
        linearActuators: ko.observableArray(),
        radiationSensors: ko.observableArray()
    }

    function displayText(text){
        return withDisplayFn(function(value) {
          if( value !== undefined ) {
            return value;
          }
          else {
            return "status";
          }
        }, text);
    }

    function displayRoundingDown(start, sigFigs) {
        return withDisplayFn(function(value) {
          if( value !== undefined ) {
            return value.toFixed(sigFigs);
          }
          else {
            return -1;
          }
        }, start);
    }

    function withDisplayFn(f, start) {
        var value = ko.observable(start);
        function readVal() {
            return f(value());
        }
        function writeVal(newValue) {
            value(newValue);
        }
        return ko.computed({
          read: readVal,
          write: writeVal
        });
    }

    function displayBool(bool){
        return withDisplayFn(function(value) {
          if( value !== undefined ) {
            return value;
          }
          else {
            return false;
          }
        }, bool);
    }

    self.gotStateMonitor = function(result) {
        var status = result.Status;
        var sensor_number = self.liquidSensorNumber();
        self.state.liquid_sensor.value(status.LiquidSensors[sensor_number].value);
        var mixers = [];
        var heaters = [];
        var thermocouples = [];
        var pressureRegulators = [];
        var smcInterface = [];
        var valves = [];
        var digitalInputs = [];
        var linearActuators = [];
        var radiationSensors = [];
        for(var index in status.Valves){
            valves.push(status.Valves[index]);
        }
        for(var index in status.Mixers){
            mixers.push( status.Mixers[index] );
        }
        for(var index in status.Heaters){
            heaters.push( status.Heaters[index] );
        }
        for(var index in status.Thermocouples){
            thermocouples.push( status.Thermocouples[index] );
        }
        for(var index in status.PressureRegulators ){
            pressureRegulators.push(status.PressureRegulators[index]);
        }
        for(var index in status.SMCInterface ){
            smcInterface.push(status.SMCInterface[index]);
        }
        for(var index in status.DigitalInputs ){
            digitalInputs.push(status.DigitalInputs[index]);
        }
        for(var index in status.LinearActuators ){
            linearActuators.push(status.LinearActuators[index]);
        }
        for(var index in status.RadiationSensors){
            radiationSensors.push(status.RadiationSensors[index]);
        }
        self.state.mixers(mixers);
        self.state.heaters(heaters);
        self.state.thermocouples(thermocouples);
        self.state.vacuumPump(status.VacuumPump[0]);
        self.state.smcInterface(smcInterface);
        self.state.pressureRegulators(pressureRegulators);
        self.state.coolantPump(status.CoolantPump[0]);
        self.state.hplc(status.HplcValve[0]);
        self.state.valves(valves);
        self.state.digitalInputs(digitalInputs);
        self.state.linearActuators(linearActuators);
        self.state.radiationSensors(radiationSensors);
    }

    self.requestState = function(){
        return Elixys.sequence(function(fail) {
          return [
            function() {
              return Elixys.doApiCall("/get_state_monitor", {});
            },
            function(payload) {
              var result = payload["get_state_monitor"];
              if( result.error ) {
                return fail(result.error);
              }
              else {
                return result;
              }
            },
            self.gotStateMonitor
          ];
        });
    }
}


function Cassette(cassetteId){
    var self = this;

    self.displaySPECartridge = ko.observable(true);
    self.displayReagentNames = ko.observable(true);
    self.selectedReagent = ko.observable();
    self.selectedReagentIndex = ko.observable();

    self.cassetteId = cassetteId;
    self.reagents = [];
    self.reagentPositions = [];

    for(var i = 0; i < 12; i++){
        self.reagents.push(new CassetteReagent("", i, self.cassetteId));
    }
    self.reagents.push(new CassetteReagent("", "evaporate", self.cassetteId));
    self.reagents.push(new CassetteReagent("", "elute", self.cassetteId));
    self.reagents.push(new CassetteReagent("", "add0", self.cassetteId));
    self.reagents.push(new CassetteReagent("", "add1", self.cassetteId));
    self.reagents.push(new CassetteReagent("", "transfer", self.cassetteId));

    self.getReagentPositions = function(){
        for(var i=0; i < self.reagents.length; i++){
            self.reagents[i].getPositionFromConfig();
        }
    }

    self.selectReagent = function(reagentPos){
        var reg = self.reagents[reagentPos];
        self.selectedReagentIndex(reagentPos);
        self.selectedReagent(reg);
    }

    function CassetteReagent(name, reagentId, cassetteId){
        var self = this;
        self.reagentId = reagentId;
        self.name = name;
        self.isCalibrated = ko.observable(false);


        if( !isNaN(self.reagentId ) ){
            self.position = "reagent" + self.reagentId;
            self.isOperation = false;
        }
        else{
            self.position = self.reagentId;
            self.isOperation = true;
        }

        self.cassetteId = cassetteId;
        self.description = ko.observable("");
        self.name = ko.observable(name);

        self.getPositionFromConfig = function(){
            $.get("/hardware_config?keys=ReagentRobot,Positions,Reactor" + self.cassetteId + "," + self.position, function(res){
                res = JSON.parse(res);
                self.x(res[0]);
                self.y(res[1]);
            });
        }
        self.x = ko.observable(0);
        self.y = ko.observable(0);
        self.getPositionFromConfig();
    }
}
function ReagentRobot(monitor, cassettes){
    var self = this;
    self.gripper = new Gripper(monitor);
    self.gasTransfer = new GasTransfer(monitor);
    self.cassettes = cassettes;
    self.monitor = monitor;
    self.selectedOperation = ko.observable();

    self.selectedReagent = ko.observable();

    self.xIndex;
    self.yIndex;

    self.brakeRelease = function(){
        var cal = {};
        cal.name = "reagent_robot";
        cal.select_type = "control";
        cal.parameters = {control_type: "brake_release"};
        self.calibrate(cal);
    }

    self.x = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var actuators = self.monitor.state.linearActuators();
            if( self.xIndex == null ){
                self.xIndex = self.findIndex(actuators, "Reagent Robot X Axis");
            }

            if( self.xIndex != null ){
                return actuators[self.xIndex].value;
            }
            return 0;
        }
    });

    self.y = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var actuators = self.monitor.state.linearActuators();
            if( self.yIndex == null ){
                self.yIndex = self.findIndex(actuators, "Reagent Robot Y Axis");
            }

            if( self.yIndex != null ){
                return actuators[self.yIndex].value;
            }
            return 0;
        }
    });

    self.moveToOperation = function(pos, reactor){
        self.selectedReagent(null);
        self.selectedOperation(null);
        var cal = {};
        cal.name = "reagent_robot"
        cal.select_type = "control";
        cal.parameters = {control_type: "move_position", position: pos, reactor: reactor};
        self.calibrate(cal, function(res){
            self.polling = setInterval(function(){
                var cal = {};
                cal.name = "reagent_robot";
                cal.select_type = "control";
                cal.parameters = {control_type: "poll"};
                self.calibrate(cal, function(res){
                    if( res.calibrate == true){
                        self.selectedOperation({reactor: reactor, position: pos});
                        clearInterval(self.polling);
                    }
                });
            }, 500);
        });
    }

    self.moveToReagent = function(reagent){
        self.selectedOperation(null);
        self.selectedReagent(null);
        var cal = {};
        cal.name = "reagent_robot";
        cal.select_type = "control";
        cal.parameters = {control_type: "move_coord", x: reagent.x(), y: reagent.y()};
        self.calibrate(cal, function(res){
            self.polling = setInterval(function(){
                var cal = {};
                cal.name = "reagent_robot";
                cal.select_type = "control";
                cal.parameters = {control_type: "poll"};
                self.calibrate(cal, function(res){
                    if( res.calibrate == true){
                        self.selectedReagent(reagent);
                        clearInterval(self.polling);
                    }
                });
            }, 500);
        });

    }

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name)
                return i;
        }
        return null;
    }
}

function Gripper(monitor){
    var self = this;
    self.monitor = monitor;
    self.isUpIndex;
    self.isDownIndex;
    self.isOpenIndex;
    self.isDownIndex;
    self.open = function(){
        var cal = {};
        cal.name = "gripper";
        cal.select_type = "control";
        cal.parameters = {control_type: "open"};
        self.calibrate(cal);
    }

    self.close = function(){
        var cal = {};
        cal.name = "gripper";
        cal.select_type = "control";
        cal.parameters = {control_type: "close"};
        self.calibrate(cal);
    }

    self.lift = function(){
        var cal = {};
        cal.name = "gripper";
        cal.select_type = "control";
        cal.parameters = {control_type: "lift"};
        self.calibrate(cal);
    }

    self.lower = function(){
        var cal = {};
        cal.name = "gripper";
        cal.select_type = "control";
        cal.parameters = {control_type: "lower"};
        self.calibrate(cal);
    }


    self.isOpen = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var mon = self.monitor.state.digitalInputs();
            if( self.isOpenIndex == null){
                self.isOpenIndex = self.findIndex(mon, "Gripper Open Sensor");
            }

            if( self.isOpenIndex != null ){
                return mon[self.isOpenIndex].value;
            }
            return false;
        }
    });

    self.isClosed = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var mon = self.monitor.state.digitalInputs();
            if( self.isClosedIndex == null){
                self.isClosedIndex = self.findIndex(mon, "Gripper Close Sensor");
            }

            if( self.isOpenIndex != null ){
                return mon[self.isClosedIndex].value;
            }
            return false;
        }
    });

    self.isUp = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var mon = self.monitor.state.digitalInputs();
            if( self.isUpIndex == null){
                self.isUpIndex = self.findIndex(mon, "Gripper Up Sensor");
            }

            if( self.isOpenIndex != null ){
                return mon[self.isUpIndex].value;
            }
            return false;
        }
    });

    self.isDown = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var mon = self.monitor.state.digitalInputs();
            if( self.isDownIndex == null){
                self.isDownIndex = self.findIndex(mon, "Gripper Down Sensor");
            }

            if( self.isOpenIndex != null ){
                return mon[self.isDownIndex].value;
            }
            return false;
        }
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name)
                return i;
        }
        return null;
    }
}

function GasTransfer(monitor){
    var self = this;
    self.monitor = monitor;
    self.isUpIndex;
    self.isDownIndex;
    self.isTransferringIndex;

    self.isUp = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var inputs = self.monitor.state.valves();
            if( self.isUpIndex == null ){
                self.isUpIndex = self.findIndex(inputs, "Gas Transfer Up Valve");
            }

            if( self.isUpIndex != null ){
                return inputs[self.isUpIndex].value;
            }
        }
        return false;
    });

    self.isDown = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var inputs = self.monitor.state.valves();
            if( self.isDownIndex == null ){
                self.isDownIndex = self.findIndex(inputs, "Gas Transfer Down Valve");
            }

            if( self.isDownIndex != null ){
                return inputs[self.isDownIndex].value;
            }
        }
        return false;
    });

    self.isTransferring = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var inputs = self.monitor.state.valves();
            if( self.isTransferringIndex == null ){
                self.isTransferringIndex = self.findIndex(inputs, "Gas Transfer Transfer Valve");
            }

            if( self.isTransferringIndex != null ){
                return inputs[self.isTransferringIndex].value;
            }
        }
        return false;
    });

    self.lift = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {control_type: "lift"};
        self.calibrate(cal);
    }

    self.lower = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {control_type: "lower"};
        self.calibrate(cal);
    }

    self.startTransfer = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {control_type: "start_transfer"};
        self.calibrate(cal);
    }

    self.stopTransfer = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {control_type: "stop_transfer"};
        self.calibrate(cal);
    }

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name){
                return i;
            }
        }
        return null;
    }
}

function HPLC(monitor){
    var self = this;
    self.monitor = monitor;

    self.load = function(){
        cal = {}
        cal.name = "hplc";
        cal.select_type = "control";
        cal.parameters = {"control_type": "load"};
        self.calibrate(cal);
    }

    self.inject = function(){
        cal = {}
        cal.name = "hplc";
        cal.select_type = "control";
        cal.parameters = {"control_type": "inject"};
        self.calibrate(cal);
    }

    self.position = ko.pureComputed(function(){
        var position = "NA";
        if( self.monitor && self.monitor.state ){
            position = self.monitor.state.hplc().position;
        }
        return position;
    });

    self.inInjectMode = ko.pureComputed(function(){
        return self.position() == "inject"
    });

    self.inLoadMode = ko.pureComputed(function(){
        return self.position() == "load";
    });

    self.calibrate = function(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function Heater(heaterId, reactorId, monitor, name){
    var self = this;
    self.requestedTemp = ko.observable(25);
    self.monitor = monitor;
    //self.name = "R" + (reactorId + 1) + " H" + (heaterId + 1);
	self.name =  name;
    self.heaterId = heaterId;
    self.reactorId = reactorId;
    self.id = "R" + self.reactorId + "H" + self.heaterId;
    self.canChangeHeat = ko.observable(true);

    self.on = function(){
        cal = {};
        cal.name = "temperature_controllers";
        cal.select_type = "control";
        cal.parameters = {control_type: "turn_on", heater: heaterId};
        self.calibrate(cal);
    }
    self.off = function(){
        cal = {};
        cal.name = "temperature_controllers";
        cal.select_type = "control";
        cal.parameters = {control_type: "turn_off", heater: heaterId};
        self.calibrate(cal);
    }

    self.isOn = ko.computed(function(){
        if( self.monitor && self.monitor.state ){
            var heaters = self.monitor.state.heaters();
            if( heaters.length > self.heaterId ){
                return heaters[self.heaterId].value;
            }
        }
        return false;
    });
    self.state = ko.pureComputed(function(){
        return self.isOn() ? "On" : "Off";
    });

    self.currentTemperature = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var heaters = self.monitor.state.thermocouples();
            if( heaters.length > self.heaterId ){
                return heaters[self.heaterId].value;
            }
        }
        return false;
    });
    self.requestedTemp.subscribe(function(newVal){
        cal = {};
        cal.name = "temperature_controllers";
        cal.select_type = "control";
        cal.parameters = {control_type: "heat", heater: heaterId, temperature: newVal};
        self.calibrate(cal);
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function Mixer(reactorId, name, monitor){
    var self = this;
    Common.apply(self, arguments);
    self.reactorId = reactorId;
    self.monitor = monitor;
    self.dutyCycle = ko.observable();
    self.defaultCycle;
    self.doChangeSpeed = true;
    self.canChangeSpeed = ko.observable(true);
    $.get("/hardware_config?keys=Reactors,Reactor" + self.reactorId + ",mixer_nominal_duty_cycle", function(res){
        res = parseFloat(res);
        self.defaultCycle = res;
        self.dutyCycle(self.defaultCycle);
        self.dutyCycle.subscribe(self.changeMotorSpeed);
    });
    self.name = name || "Mixer " + (reactorId + 1);

    self.on = function(){
        self.setStirState(true, undefined, function(res){
            self.doChangeSpeed = false;
            self.dutyCycle(self.defaultCycle);
            self.doChangeSpeed = true;
        });
    }
    self.off = function(){
        self.setStirState(false);
    }
    self.state = ko.pureComputed(function(){
        return self.isStirring() ? "On" : "Off"
    });

    self.changeMotorSpeed = function(newSpeed){
        if( self.doChangeSpeed ){
            self.setStirState(self.isStirring(), newSpeed);
        }
    }

    self.setStirState = function(state, speed, handleResponse){
        console.log("Setting the stir state");
        var cal = {};
        cal.name = "mixers";
        cal.select_type = "control";
        cal.parameters = {reactor: self.reactorId, state: state, duty_cycle: speed};
        self.calibrate(cal, handleResponse);
    }

    self.isStirring = ko.pureComputed(function(){
        return self.currentMotorSpeed() > 0;
    });

    self.currentMotorSpeed = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var mixer = self.monitor.state.mixers()[self.reactorId];
            if( mixer ){
                return self.monitor.state.mixers()[self.reactorId].value;
            }
        }
        return 0;
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function Stopcock(reactor, index, monitor){
    var self = this;
    self.stopcockIndex = index;
    self.reactor = reactor;
    self.monitor = monitor;
    self.counterClockwiseId;
    self.clockwiseId;
    self.clockwiseName = "Reactor" + self.reactor + " Stopcock" + self.stopcockIndex + " CW Valve";
    self.counterClockwiseName = "Reactor" + self.reactor + " Stopcock" + self.stopcockIndex + " CCW Valve";
    self.name = self.stopcockIndex + 1;

    self.turnClockwise = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control"
        cal.parameters = {"control_type" : "stopcock", "reactor": self.reactor,
                          "stopcock": self.stopcockIndex, "position": "clockwise"};
        self.calibrate(cal);
    }

    self.turnCounterClockwise = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control"
        cal.parameters = {"control_type" : "stopcock", "reactor": self.reactor,
                          "stopcock": self.stopcockIndex, "position": "counterclockwise"};
        self.calibrate(cal);
    }

    self.isClockwise = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var valves = self.monitor.state.valves();
            if( valves ){
                if( !(self.clockwiseId || self.clockwiseId == 0) ){
                    self.clockwiseId = self.findIndexClockWise(valves);
                }

                if(self.clockwiseId || self.clockwiseId == 0 )
                    return valves[self.clockwiseId].value;
            }
        }
        return false;
    });

    self.isCounterClockwise = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var valves = self.monitor.state.valves();
            if( valves ){
                if( !(self.counterClockwiseId || self.counterClockwiseId == 0)){
                    self.counterClockwiseId = self.findIndexCounterClockWise(valves);
                }
                if( self.counterClockwiseId || self.counterClockwiseId == 0 )
                    return valves[self.counterClockwiseId].value;
            }
        }
        return false;
    });

    self.state = ko.pureComputed(function(){
        if( self.isClockwise() ){
            return true;
        }
        else if( self.isCounterClockwise() ){
            return false;
        }
        else{
            return false;
        }
    });

    self.findIndexClockWise = function(valves){
        for(var i=0; i < valves.length; i++){
            var valve = valves[i];

            if(valve.name == self.clockwiseName){
                return i;
            }
        }
        return null;
    }

    self.findIndexCounterClockWise = function(valves){
        for(var i=0; i < valves.length; i++){
            var valve = valves[i];
            if( valve.name == self.counterClockwiseName ){
                return i;
            }
        }
        return null;
    }

    self.calibrate = function(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function VacuumPump(monitor){
    var self = this;
    self.monitor = monitor;
    self.id = "vacuum-pump";
    self.canChangeState = ko.observable(true);

    self.on = function(){
        var cal = {};
        cal.name = "vacuum_pump";
        cal.select_type = "control";
        cal.parameters = {state: true};
        self.calibrate(cal);
    }

    self.off = function(){
        var cal = {};
        cal.name = "vacuum_pump";
        cal.select_type = "control";
        cal.parameters = {state: false};
        self.calibrate(cal);
    }

    self.state = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var pump = self.monitor.state.vacuumPump();
            if( pump ){
                return pump.value > 0 ? "On" : "Off";
            }
        }
        return "Off";
    });

    self.pressure = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var pressure = self.monitor.state.smcInterface();
            if( pressure.length > 0 ){
                return pressure[0].value;
            }
        }
        return 0;
    });
    
    self.mmHg = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var pressure = self.monitor.state.smcInterface();
            if( pressure.length > 0 ){
                return pressure[0].mmHg;
            }
        }
        return 0;
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function CoolantPump(id, monitor){
    var self = this;
    self.monitor = monitor;
    self.id = id;
    self.name = "coolant_pump";
    self.canChangeState = ko.observable(true);

    self.on = function(){
        var cal = {};
        cal.name = "coolant_pump";
        cal.select_type = "control";
        cal.parameters = {"state": true};
        self.calibrate(cal);
    }

    self.off = function(){
        var cal = {};
        cal.name = "coolant_pump";
        cal.select_type = "control";
        cal.parameters = {"state": false};
        self.calibrate(cal);
    }

    self.state = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var coolantPump = self.monitor.state.coolantPump();
            if(coolantPump){
                return coolantPump.value ? "On" : "Off";
            }
        }
        return "Off";
    });

    self.calibrate = function(cal_parameters, calibrateResponseFn) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, calibrateResponseFn);
    }
}
function ReactorHeater(heaters, reactorId, name, heatOnChange){
    var self = this;
    self.id = reactorId;
    self.reactorId = reactorId;
    self.heaters = heaters;
    self.name = name;
    self.heatOnChange = heatOnChange ? heatOnChange : false;
    self.requestedTemp = ko.observable(25);
    self.isOn = ko.computed(function(){
        for(var i=0; i < self.heaters.length; i++){
            if( self.heaters[i].isOn() )
                return true;
        }
        return false;
    })
    self.requestedState = ko.observable(false);
    self.canChangeHeat = ko.observable(true);
    self.canChangeHeat.subscribe(function(newVal){
        if( newVal ){
            if( self.heatTimer ) { clearInterval( self.heatTimer ); }
        }
    });

    self.setTemperature = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        if( self.heatOnChange ){
            cal.parameters = {reactor: self.reactorId, control_type: "heat", temp: self.requestedTemp(),
                              state: self.requestedState()}
        }
        else{
            cal.parameters = {reactor: self.reactorId, control_type: "heat", temp: self.requestedTemp(),
                              state: self.requestedState(), time: self.heatDuration()}
            if( self.requestedState() ){
                self.monitorCanHeat = setInterval(function(){
                                          var cal = {};
                                          cal.name = "reactors";
                                          cal.select_type = "control";
                                          cal.parameters = {reactor: self.reactorId, control_type: "heat", temp: self.requestedTemp(),
                                                            state: self.requestedState(), query: true};
                                          self.calibrate(cal, function(res){
                                              
                                              res = res.calibrate;
                                              self.canChangeHeat(!res.timed_heating);
                                              if( self.canChangeHeat() ){
                                                  clearInterval(self.monitorCanHeat);
                                              }
                                          });
                                      }, 1000);
            }
            else if( self.monitorCanHeat ){
                clearInterval(self.monitorCanHeat);
                self.canChangeHeat(true);
            }
    
        }

        self.calibrate(cal);
    }

    self.requestedTemp.subscribe(function(newVal){
        if( self.heatOnChange ){
            if( newVal < self.currentTemperature() ){
                self.requestedState(false);
                if( self.tempDrop ){
                    self.tempDrop.dispose();
                }
                self.tempDrop = self.currentTemperature.subscribe(function(newVal){
                    if(newVal < self.requestedTemp()){
                        self.requestedState(true);
                        self.setTemperature();
                        self.tempDrop.dispose();
                    }
                });
            }
            else{
                self.requestedState(true);
            }
            self.setTemperature();
        }
    });

    self.off = function(){
        self.requestedState(false);
        self.setTemperature();
        if( self.heatTimer ){
            clearInterval( self.heatTimer );
        }
        
    }

    self.on = function(){
        self.requestedState(true);
        self.setTemperature();
        if( !self.heatOnChange ){
            self.heatTimer = setInterval(function(){
                if( self.heatDuration() > 0 ){
                    self.heatDuration(self.heatDuration() - 1);
                }
                else{
                    clearInterval( self.heatTimer );
                }
            }, 1000);
        }
    }

    self.state = ko.pureComputed(function(){
        return self.isOn() ? "On" : "Off";
    });

    self.heatDuration = ko.observable(0);

    self.currentTemperature = ko.pureComputed(function(){
        var summedTemps = 0;
        for(var i=0; i < self.heaters.length; i++){
            summedTemps+=self.heaters[i].currentTemperature();
        }
        return summedTemps/self.heaters.length;
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function Reactor(reactorId, monitor, heatOnChange){
    var self = this;
    self.reactorId = reactorId;
    self.monitor = monitor;
    self.camera = new Camera({cameraId: self.reactorId});
    self.mixer = new Mixer(self.reactorId, null, self.monitor);
    self.upIndex;
    self.downIndex;
    self.linearActuatorId;
    self.heaters = [];
	self.allHeaters = [];
    self.stopcocks = [];
    self.ctrlMode = ko.observable("command");

    self.isInPosition = ko.observable(true);

    self.selectedPosition = ko.observable("");

    var numHeaters = 3;
    for(var h = 0; h < numHeaters; h++){
        var heaterId = self.reactorId*numHeaters + h;
        var heater = new Heater(heaterId,self.reactorId,self.monitor, "THERMO " + (h + 1) + ": ");
        self.heaters.push(heater);
    }
    self.heater = new ReactorHeater(self.heaters, self.reactorId, "MASTER TEMP: ", heatOnChange);
    self.allHeaters.push(self.heater);
    self.allHeaters = self.allHeaters.concat(self.heaters);

    var numStopCocks = 3;
    for(var s = 0; s < numStopCocks; s++){
        var stopcock = new Stopcock(self.reactorId,s,self.monitor);
        self.stopcocks.push(stopcock);
    }

    self.lift = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        cal.parameters = {"reactor": self.reactorId, "control_type": "lift"};
        self.calibrate(cal);
    }

    self.brakeRelease = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        cal.parameters = {"reactor": self.reactorId, "control_type": "brake_release"};
        self.calibrate(cal);
    }

    self.lower = function(){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        cal.parameters = {"reactor": self.reactorId, "control_type": "lower"};
        self.calibrate(cal);
    }

    self.home = function(){
        self.selectedPosition("home");
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        cal.parameters = {"reactor": self.reactorId, "control_type": "home"};
        self.calibrate(cal);
    }

    self.movePosition = function(posName){
        self.selectedPosition(posName);
        self.isInPosition(false);
        if( self.ctrlMode() == "command" ){
            var cal = {};
            cal.name = "reactors";
            cal.select_type = "control";
            cal.parameters = {"reactor": self.reactorId, "control_type": "move_position", "position": posName};
            self.calibrate(cal);

            self.polling = setInterval(function(){
                var cal = {};
                cal.name = "reactors";
                cal.select_type = "control";
                cal.parameters = {control_type: "poll"};
                self.calibrate(cal, function(res){
                    if( res.calibrate == true){
                        self.isInPosition(true);
                        clearInterval(self.polling);
                    }
                });
            }, 500);
        }
    }

    self.moveAdd = function(){
        self.movePosition("add");
    }

    self.moveTransfer = function(){
        self.movePosition("transfer");
    }

    self.moveReact0 = function(){
        self.movePosition("react0");
    }

    self.moveReact1 = function(){
        self.movePosition("react1");
    }

    self.moveEvap = function(){
        self.movePosition("evaporate");
    }

    self.moveInstall = function(){
        self.movePosition("install");
    }

    self.move_coord = function(x){
        var cal = {};
        cal.name = "reactors";
        cal.select_type = "control";
        cal.parameters = {"reactor": self.reactorId, "control_type": "move_coord", "x": x};
        self.calibrate(cal);
    }

    self.isUp = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var digitalInputs = self.monitor.state.digitalInputs();
            if( digitalInputs ){
                if( self.upIndex == null ){
                    self.upIndex = self.findIndex(digitalInputs, "Reactor" + self.reactorId + " Up Sensor");
                }

                if( self.upIndex != null && digitalInputs.length-1 >= self.upIndex){
                    return digitalInputs[self.upIndex].value;
                }
            }
        }
    });

    self.isDown = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var digitalInputs = self.monitor.state.digitalInputs();
            if( digitalInputs ){
                if( self.downIndex == null ){
                    self.downIndex = self.findIndex(digitalInputs, "Reactor" + self.reactorId + " Down Sensor");
                }

                if( self.downIndex != null && digitalInputs.length - 1 >= self.downIndex){
                    return digitalInputs[self.downIndex].value;
                }
            }
        }

    });

    self.position = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var linearActuators = self.monitor.state.linearActuators();
            if( linearActuators){
                if( self.linearActuatorId == null ){
                    self.linearActuatorId = self.findIndex(linearActuators, "Reactor" + self.reactorId + " Axis");
                }

                if( self.linearActuatorId != null && linearActuators.length -1 >= self.linearActuatorId){
                    return linearActuators[self.linearActuatorId].value;
                }
            }
        }
    });

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name)
                return i;
        }
        return null;
    }

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }
}
function InertGasValve(monitor, id){
    var self = this;
    self.monitor = monitor;
    self.id = id;
    self.valveIndex;
    self.canChangeState = ko.observable(true);

    self.on = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {"control_type": "start_transfer"};
        self.calibrate(cal);
    }

    self.off = function(){
        var cal = {};
        cal.name = "gas_transfer";
        cal.select_type = "control";
        cal.parameters = {"control_type": "stop_transfer"};
        self.calibrate(cal);
    }

    self.state = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var monitor = self.monitor.state.valves();
            if( !self.valveIndex ){
                self.valveIndex = self.findIndex(monitor, "Gas Transfer Transfer Valve");
            }

            if(self.valveIndex){
                return monitor[self.valveIndex].value ? "Off" : "On";
            }
        }
        return "Off";
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name){
                return i;
            }
        }
        return null;
    }
}
function ActiveGasValve(monitor, id){
    var self = this;
    self.monitor = monitor;
    self.id = id;
    self.valveIndex;
    self.canChangeState = ko.observable(true);

    self.on = function(){
        var cal = {};
        cal.name = "active_gas";
        cal.select_type = "control";
        cal.parameters = {"state": false};
        self.calibrate(cal);
    }

    self.off = function(){
        var cal = {};
        cal.name = "active_gas";
        cal.select_type = "control";
        cal.parameters = {"state": true};
        self.calibrate(cal);
    }

    self.state = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var monitor = self.monitor.state.valves();
            if( !self.valveIndex ){
                self.valveIndex = self.findIndex(monitor, "F18/Isotope Valve");
            }

            if(self.valveIndex){
                return monitor[self.valveIndex].value ? "Off" : "On";
            }
        }
        return "Off";
    });

    self.calibrate = function(cal_parameters, handleResponse) {
        return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                                parameters: cal_parameters.parameters}}, handleResponse);
    }

    self.findIndex = function(monitorArray,name){
        for(var i=0; i < monitorArray.length; i++){
            var mon = monitorArray[i];

            if(mon.name == name){
                return i;
            }
        }
        return null;
    }
}
function RadiationSensor(sensorId, monitor){
    var self = this;
    self.sensorId = sensorId;
    self.monitor = monitor;

    self.radiationLevel = ko.pureComputed(function(){
        if( self.monitor && self.monitor.state ){
            var radSensors = self.monitor.state.radiationSensors();
            if( radSensors.length > self.sensorId ){
                return radSensors[self.sensorId].value;
            }
        }
        return 0;
    });
}
PressureRegulator = function(name, id, monitor){
  var self = this;
  self.name = name;
  self.monitor = monitor;
  self.id = id;
  self.psiRequested = ko.observable(0);
  self.psiRequested.subscribe(function(newVal){
    var maxPressure = self.maxPressure();
    if( newVal > maxPressure ){
        self.psiRequested(maxPressure);
    }
    else{
        self.setPoint(newVal);
    }
  });
  self.canChangePressure = ko.observable(true);

  self.setPoint = function(psi){
    console.log("Setting Pressure to " + psi );
    var cal = {};
    cal.name = "pressure_regulators";
    cal.select_type = "control";
    cal.parameters = {pressure: self.psiRequested(), id: self.id};
    self.calibrate(cal);
  }

  self.psi = ko.pureComputed(function(){
    if(self.monitor && self.monitor.state ){
      var pressureRegs = self.monitor.state.pressureRegulators();
      if( pressureRegs.length > self.id ){
        return pressureRegs[self.id].value;
      }
    }
    return 0;
  });
  
  self.maxPressure = function(){
    if( self.id == 0 ){
      return 30;
    }
    else{
      return 60;
    }
  }


  self.calibrate = function(cal_parameters, handleResponse) {
      return Elixys.doApiCall("/calibrate", {calibrate: {name : cal_parameters.name, type: cal_parameters.select_type,
                              parameters: cal_parameters.parameters}}, handleResponse);
  }
}
ko.bindingHandlers.truncatedText = {
    update: function (element, valueAccessor, allBindingsAccessor) {

        var originalText = ko.utils.unwrapObservable(valueAccessor());
            // 10 is a default maximum length
        var length = ko.utils.unwrapObservable(allBindingsAccessor().maxTextLength) || 20;
        if( originalText ){
          var truncatedText = originalText.length > length ? originalText.substring(0, length) + "..." : originalText;
        }
        else{
          var truncatedText = "";
        }
        ko.bindingHandlers.text.update(element, function() {
          return truncatedText;
        });
    }
}

ko.subscribable.fn.subscribeChanged = function(callback) {
    var previousValue;
    this.subscribe(function(_previousValue) {
        previousValue = _previousValue;
    }, undefined, 'beforeChange');
    this.subscribe(function(latestValue) {
        callback(latestValue, previousValue );
    });
};

ko.bindingHandlers.numericText = {
    update: function (element, valueAccessor, allBindingsAccessor) {
        var rawValue = parseFloat( ko.utils.unwrapObservable(valueAccessor()) );
        var sigDigits = ko.utils.unwrapObservable(allBindingsAccessor().sigDigits) || null;
        var retVal = rawValue;

        if( sigDigits != null ){
          retVal = rawValue.toFixed(2);
        }
        // updating text binding handler to show truncatedText
        ko.bindingHandlers.text.update(element, function() {
            return retVal;
        });
    }
}

$(document).ready(function () {
  Elixys.init();
});
var Elixys = (function ($, window) {
  'use strict';
   
  var viewModels = {},
      doApiCall = function (request, data, success, error) {
        return $.ajax({
          url: request,
          dataType: 'json',
          contentType: "application/json; charset=utf-8",
          type: 'POST',
          data: JSON.stringify(data),
          success: success,
          error: error
        });
      };


  function setSections(anchor, pages, after) {
    var page = pages.splice(0,1)[0];
    $.get(page, function(data) {
      anchor.append(data);
      if(pages.length === 0) {
        after();
      }
      else {
        setSections(anchor, pages, after);
      }
    });
  }

  // TODO: For a release, set this to a specific version number. For
  // dev, leave as Date.now().
  var version = Date.now();//"0.0.1";

  /**
   * The html document needs to be assembled before applying the knockout bindings
   */
  function loadTemplates(anchor, after){
    setSections(anchor, [
      "static/templates/system/camera.html?v=" + version,
      "static/templates/system/mixer.html?v=" + version,
      "static/templates/system/heater.html?v=" + version,
      "static/templates/system/heater-client-control.html?v=" + version,
      "static/templates/system/heater-readout.html?v=" + version,
      "static/templates/system/vacuum_pump.html?v=" + version,
      "static/templates/system/coolant_pump.html?v=" + version,
      "static/templates/system/pressure_regulator.html?v=" + version,
      "static/templates/system/hplc.html?v=" + version,
      "static/templates/system/stopcock.html?v=" + version,
      "static/templates/system/reactor.html?v=" + version,
      "static/templates/system/cassette.html?v=" + version,
      "static/templates/system/radiation_sensor.html?v=" + version,
      "static/templates/system/inert_gas_valve.html?v=" + version,
      /* Calibration Templates */
      "static/templates/calibration/video-calibrate.html?v=" + version,
      "static/templates/calibration/fluid-gas-calibrate-client.html?v=" + version,
      "static/templates/calibration/radiation-calibrate.html?v=" + version,
      "static/templates/calibration/heat-calibrate-client.html?v=" + version,
      "static/templates/calibration/reactors-calibrate.html?v=" + version,
      "static/templates/calibration/reagents-calibrate.html?v=" + version,

      "static/templates/login.html?v=" + version,
      "static/templates/topHeader.html?v=" + version,
      "static/templates/sequences.html?v=" + version,
      "static/templates/elixys-manual.html?v=" + version,
      "static/templates/system.html?v=" + version,
      "static/templates/editSequence.html?v=" + version,
      "static/templates/cassettes.html?v=" + version,
      "static/templates/operations.html?v=" + version,
      "static/templates/statusLogs.html?v=" + version,
      "static/templates/logs.html?v=" + version,
      "static/templates/running.html?v=" + version,
      "static/templates/sidebarNavigation.html?v=" + version,
      "static/templates/connectionError.html?v=" + version,
      "static/templates/notificationPopup.html?v=" + version,
      "static/templates/newSequencePopup.html?v=" + version,
      "static/templates/twoButtonPopup.html?v=" + version,
      "static/templates/importSequencePopup.html?v=" + version,
      "static/templates/blank.html?v=" + version,
      "static/templates/pre-run-checklist.html?v=" + version,
      "static/templates/templatedPopup.html?v=" + version,
      /* Edit sequence */
      "static/templates/editSequence/reagent-popup.html?v=" + version,
      "static/templates/editSequence/add.html?v=" + version,
      "static/templates/editSequence/add-stir-popup.html?v=" + version,
      "static/templates/editSequence/evaporate.html?v=" + version,
      "static/templates/editSequence/evaporate-stir-popup.html?v=" + version,
      "static/templates/editSequence/transfer.html?v=" + version,
      "static/templates/editSequence/transfer-stir-popup.html?v=" + version,
      "static/templates/editSequence/transfer-destination-popup.html?v=" + version,
      "static/templates/editSequence/react.html?v=" + version,
      "static/templates/editSequence/react-stir-popup.html?v=" + version,
      "static/templates/editSequence/prompt.html?v=" + version,
      "static/templates/editSequence/trapisotope.html?v=" + version,
      "static/templates/editSequence/eluteisotope.html?v=" + version,
      "static/templates/editSequence/move.html?v=" + version,
      "static/templates/editSequence/move-position-popup.html?v=" + version,
      "static/templates/editSequence/externaladd.html?v=" + version,
      /* Running */
      "static/templates/running/add.html?v=" + version,
      "static/templates/running/evaporate.html?v=" + version,
      "static/templates/running/transfer.html?v=" + version,
      "static/templates/running/react.html?v=" + version,
      "static/templates/running/prompt.html?v=" + version,
      "static/templates/running/trapisotope.html?v=" + version,
      "static/templates/running/eluteisotope.html?v=" + version,
      "static/templates/running/move.html?v=" + version,
      "static/templates/running/externaladd.html?v=" + version,
      /* Running parameters */
      "static/templates/runningParameters/add.html?v=" + version,
      "static/templates/runningParameters/evaporate.html?v=" + version,
      "static/templates/runningParameters/transfer.html?v=" + version,
      "static/templates/runningParameters/react.html?v=" + version,
      "static/templates/runningParameters/prompt.html?v=" + version,
      "static/templates/runningParameters/trap.html?v=" + version,
      "static/templates/runningParameters/elute.html?v=" + version,
      "static/templates/runningParameters/move.html?v=" + version,
      "static/templates/runningParameters/externaladd.html?v=" + version
    ], after);
  }

  function initializeCustomBindings() {
    ko.bindingHandlers.sidebarToggle = {
      init: function(element, valueAccessor, allBindings) {
        var offset = allBindings.get("initialOffset") || 0;
        $(element).css({ left: offset });
      },
      update: function(element, valueAccessor, allBindings) {
        var sidebarVisible = ko.unwrap(valueAccessor());
        var offset = allBindings.get("initialOffset") || 0;
		if( sidebarVisible ) {
			var toolbarWidth = 100;
            $(element).animate({ left: offset + toolbarWidth });
        }
        else {
		    var toolbarWidth = offset;
            $(element).animate({ left: toolbarWidth });
        }
      }
    };

    ko.bindingHandlers.draggable = {
      init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        $(element).drag("start", function (ev, dd) {
          return valueAccessor().start(element, viewModel, dd);
        }).drag(function (ev, dd){
          valueAccessor().drag(element, viewModel, dd);
        }).drag("end", function (ev, dd){
          valueAccessor().end(element, viewModel, dd);
        });
      }
    };

    ko.bindingHandlers.droppable = {
      init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        $(element).drop("init", function (ev, dd) {
          valueAccessor().initialize(element);
        }).drop("start", function (ev, dd) {
          valueAccessor().start(element);
        }).drop("end", function (ev, dd) {
          valueAccessor().end(element);
        }).drop(function (ev, dd) {
          valueAccessor().drop(element);
        });
      }
    };
    
    ko.bindingHandlers.dblclick = {
      init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var value = valueAccessor();
        var valueUnwrapped = ko.unwrap(value);
        $(element).dblclick(function() {
          valueUnwrapped(viewModel);
        });
      }
    };

    ko.bindingHandlers.numeric = {
      init: function (element, valueAccessor) {
        $(element).on("keydown", function (event) {
          // Allow: backspace, delete, tab, escape, and enter
          if (event.keyCode == 46 || event.keyCode == 8 || event.keyCode == 9 || event.keyCode == 27 || event.keyCode == 13 ||
              // Allow: Ctrl+A
              (event.keyCode == 65 && event.ctrlKey === true) ||
              // Allow: . ,
              (event.keyCode == 188 || event.keyCode == 190 || event.keyCode == 110) ||
              // Allow: home, end, left, right
              (event.keyCode >= 35 && event.keyCode <= 39)) {
            // let it happen, don't do anything
            return;
          }
          else {
            // Ensure that it is a number and stop the keypress
            if (event.shiftKey || (event.keyCode < 48 || event.keyCode > 57) && (event.keyCode < 96 || event.keyCode > 105)) {
              event.preventDefault();
            }
          }
        });
      }
    };
  }
  
  function initializeComponent(name, constr, url) {
    $.get(url, function(template) {
      ko.components.register(name, {
        viewModel: constr,
        template: template
      });
    });
  }
  
  function numericInput(params) {
    var self = this;
    self.value = params.value;
    self.max = params.max || 9999;
    self.min = params.min || 0;
    self.maxlength = params.maxlength || 3;
    self.step = params.step || 1;
    self.fixed = params.fixed;
    self.input = ko.observable(self.value());
    self.input.subscribe(function(newValue) {
      if( !isNaN(newValue) ) {
        self.value(parseFloat(newValue));
      }
    });
    self.canIncrement = ko.pureComputed(function() {
      return ko.unwrap(self.enable) && self.value() < ko.unwrap(self.max);
    });
    self.increment = function() {
      var newValue = self.value() + self.step;
      if( self.fixed ){
        newValue = newValue.toFixed(self.fixed);
      }
      self.value(newValue);
      self.input(newValue);
    };
    self.canDecrement = ko.pureComputed(function() {
      return ko.unwrap(self.enable) && self.value() > ko.unwrap(self.min);
    });
    self.decrement = function() {
      var newValue = self.value() - self.step;
      if( self.fixed ){
        newValue = newValue.toFixed(self.fixed);
      }
      self.value(newValue);
      self.input(newValue);
    };
    if( params.enable ) {
      self.enable = params.enable;
    }
    else {
      self.enable = true;
    }
  }

  function toggleStir(params){
      var self = this;
      self.currentMotorSpeed = params.currentMotorSpeed;
      self.enabled = params.enabled;
      self.reactor = params.reactor;
      self.setStirState = function( reactor, current_motor_speed ){
        if( self.enabled() ){
          var state = current_motor_speed == 0;
          Elixys.doApiCall("/set_stir_state",
                       {"set_stir_state": {'reactor' : reactor.toUpperCase(), 'state' : state}},
                       function(result){
                       },
                       function(error){
                         console.log( 'An error occured while attempting to stir');
                         console.log( error );
                       });
        }
      }
  }
  
  function timerInput(params) {
    var self = this;
    var target = params.value;
    var initial = parseInt(target() || 0);
    var min = params.min || 0;
    var max = params.max || 3599; // 59:59
    if( params.enable ) {
      self.enable = params.enable;
    }
    else {
      self.enable = true;
    }
    
    var secondObs = ko.observable(initial % 60);
    self.second = ko.computed({
      read: function() {
        var value = parseInt(target()) % 60;
        if( value < 10 ) {
          return "0" + value;
        }
        else {
          return value;
        }
      },
      write: function(value) {
        secondObs(isNaN(value) ? 0 : value);
      }
    });
    
    var minuteObs = ko.observable(parseInt(initial / 60));
    self.minute = ko.computed({
      read: function() {
        var value = parseInt(target() / 60);
        if( value < 10 ) {
          return "0" + value;
        }
        else {
          return value;
        }
      },
      write: function(value) {
        minuteObs(isNaN(value) ? 0 : value);
      }
    });
    
    var time = ko.pureComputed(function() {
      var minute = parseInt(minuteObs());
      var second = parseInt(secondObs());
      return (isNaN(minute) ? 0 : minute * 60) + (isNaN(second) ? 0 : second);
    });
    time.subscribe(function(newValue) {
      target(newValue);
    });
    self.canIncrement = ko.pureComputed(function() {
      return ko.unwrap(self.enable) && target() < ko.unwrap(max);
    });
    self.increment = function() {
      var newValue = target() + 1;
      target(newValue);
    };
    self.canDecrement = ko.pureComputed(function() {
      return ko.unwrap(self.enable) && target() > ko.unwrap(min);
    });
    self.decrement = function() {
      var newValue = target() - 1;
      target(newValue);
    };
    
    self.dispose = function() {
      self.second.dispose();
      self.minute.dispose();
    };
  }
  
  /**
   * Elixys initialization.
   */
  function init() {


    // view models.
    viewModels.connectionError = new ConnectionError();
    viewModels.login = new Login();
    viewModels.logs = new Logs();
    viewModels.sidebarNavigation = new SidebarNavigation();
    viewModels.sequences = new Sequences();
    viewModels.system = new System();
    viewModels.running = new Running();
    viewModels.editSequence = new EditSequence();
    viewModels.notificationPopup = new NotificationPopup();
    viewModels.newSequencePopup = new NewSequencePopup();
    viewModels.importSequencePopup = new ImportSequencePopup();
    viewModels.preRunChecklist = new PreRunChecklist();
    viewModels.templatedPopup = new TemplatedPopup();
    viewModels.elixysManual = new ElixysManual();
    viewModels.twoButtonPopup = new TwoButtonPopup();

    loadTemplates($('#templates'), function () {
      // apply custom ko bindings.
      initializeCustomBindings();

      ko.applyBindings(viewModels.connectionError, $('#connection-error')[0]);
      ko.applyBindings(viewModels.login, $('#login')[0]);
      ko.applyBindings(viewModels.logs, $('#logs')[0]);
      ko.applyBindings(viewModels.sidebarNavigation, $('#sidebar-navigation')[0]);
      ko.applyBindings(viewModels.sequences, $('#sequences')[0]);
      ko.applyBindings(viewModels.system, $('#system')[0]);
      ko.applyBindings(viewModels.running, $('#running')[0]);
      ko.applyBindings(viewModels.editSequence, $('#edit-sequence')[0]);
      ko.applyBindings(viewModels.notificationPopup, $('#notification-popup')[0]);
      ko.applyBindings(viewModels.newSequencePopup, $('#new-sequence-popup')[0]);
      ko.applyBindings(viewModels.importSequencePopup, $('#import-sequence-popup')[0]);
      ko.applyBindings(viewModels.preRunChecklist, $('#pre-run-checklist')[0]);
      ko.applyBindings(viewModels.templatedPopup, $('#templated-popup')[0]);
      ko.applyBindings(viewModels.elixysManual, $("#elixys-manual")[0]);
      ko.applyBindings(viewModels.twoButtonPopup, $("#two-button-popup")[0]);
      $('.date-picker').datepicker({
        autoclose: true
      });
    });
    
    // Load components
    initializeComponent("numeric-input", numericInput, "static/templates/numeric-input.html?v=" + version);
    initializeComponent("timer-input", timerInput, "static/templates/timer-input.html?v=" + version);
    initializeComponent("toggle-stir", toggleStir, "static/templates/runningParameters/toggleStir.html?v=" + version);

    // iOS web app fix
    if( window.navigator.standalone === true ) {
      ko.applyBindings({ isIOS: true }, $('#status-bar')[0]);
    }

    // Activate FastClick
    var attachFastClick = Origami.fastclick;
    attachFastClick(document.body);
  }

  function logOut() {
    Elixys.doApiCall("/logout", null, function(success){}, function(error){});
    viewModels.login.isLoggedIn(false);
    viewModels.login.currentPage('');
    viewModels.login.isSidebarVisible(false);
    reloadPage();
  }

  function viewManual(){
    viewModels.elixysManual.view();
  }

self.initializeStatusInterval = undefined; //will be defined when system initialize started
self.shutdownStatusInterval = undefined; //will be defined when shutdown started

  function initialize(){
	Elixys.showNotificationPopup("Start System Initialize",
		        {
		        confirmCallback: function(){
		        Elixys.hideNotificationPopup();
		        var result = Elixys.doApiCall("/initialize_system",
		        {
		        initialize_system: {

		        }
		        },function(result){
		            var message = result["initialize_system"];
		            if(message !="ok"){
                    var error_message = message["error"];
                    showNotificationPopup(error_message, {showCloseButton: true});
                    }
                    else{
                    self.initializeStatusInterval = window.setInterval(pollInitializeStatus, 1000);
                    }
		            });

		        }
		        ,
                confirmText: "Yes",
                cancelCallback: function() {},
                cancelText: "No"
                }
                );
  }


 function pollInitializeStatus() {
        var result = Elixys.doApiCall("/initialize_system",
        {
        initialize_system: {
            query: true
            }
        },
        function(result){
		            var initialize_state = result["initialize_system"];
                    var fail_status = initialize_state["fail"];
                    var running_status = initialize_state["running"];
                    var status = initialize_state["message"];
                    if(fail_status===true){
                        window.clearInterval(self.initializeStatusInterval);
                        showNotificationPopup(status, {showCloseButton: true});

                    }
                    else{
                        if(running_status===false){
                            window.clearInterval(self.initializeStatusInterval);
                            showNotificationPopup("System Initialize Complete", {showCloseButton: true});
                        }

                    }

		            });
  }

function unlock_robots(){
	Elixys.showNotificationPopup("Unlock Reagent and Reactor Robots",
		        {
		        confirmCallback: function(){
		        Elixys.hideNotificationPopup();
		        Elixys.doApiCall("/unlock_robots",{},function(result){
		            var message = result["unlock_robots"];
		            if(message !="ok"){
                    var error_message = message["error"];
                    showNotificationPopup(error_message, {showCloseButton: true});
		            }
		            });

		        }
		        ,
                confirmText: "Yes",
                cancelCallback: function() {},
                cancelText: "No"
                });
  }


  function power(){
	Elixys.showNotificationPopup("Shutdown Elixys",
		        {
		        confirmCallback: function(){
		        Elixys.hideNotificationPopup();
		        Elixys.doApiCall("/system_shutdown",{},function(result){
		            var message = result["system_shutdown"];
		            if(message !="ok"){
                    var error_message = message["error"];
                    showNotificationPopup(error_message, {showCloseButton: true});
		            }
		            else{

		                //wait 20 seconds before telling user it's ok to turn off hardware
		                var complete_message = "System Shutdown Complete - Turn Off Hardware";
		                window.setTimeout(shutdownStatus, 25000, complete_message);

		                var status_message = "System Shutting Down - Do Not Turn Off Hardware Till Complete (May take 20-30 seconds)";
		                window.setTimeout(shutdownStatus, 100, status_message);


		            }
		            });

		        }
		        ,
                confirmText: "Yes",
                cancelCallback: function() {},
                cancelText: "No"
                });
  }

  function shutdownStatus(status_message){
        showNotificationPopup(status_message, {showCloseButton: true});
  }



  function reloadPage() {
    window.onbeforeunload = undefined;
    window.location.reload();
  }

  function triggerConnectionErrorPopup(retry) {
    var connectionError = viewModels.connectionError;
    connectionError.setRetry(retry);
    connectionError.visible(true);
  }

  function positionNotificationPopup() {
    var $notification = $('.notification-popup-box');
    $notification.css('height', 'auto').css({
      'top': '50%',
      'margin-top': '-' + ($notification.outerHeight() / 2) + 'px'
    });
  }

  function showNotificationPopup(message, options) {
    var notification = viewModels.notificationPopup;
    notification.message(message);
    notification.options(options || {});
    notification.visible(true);
    positionNotificationPopup();
  }

  function hideNotificationPopup() {
    var notification = viewModels.notificationPopup;
    notification.visible(false);
  }
  
  function showNotYetImplementedPopup() {
    showNotificationPopup("Not yet implemented", {showCloseButton: true});
  }
  
  function showNewSequencePopup(options) {
    viewModels.newSequencePopup.popup(options);
  }

  function showTwoButtonPopup(options){
    viewModels.twoButtonPopup.popup(options);
  }

  function showImportSequencePopup(options) {
    viewModels.importSequencePopup.popup(options);
  }
  
  function showTemplatedPopup(template, data, extraClass) {
    viewModels.templatedPopup.show(template, data, extraClass);
  }
  
  function hideTemplatedPopup() {
    viewModels.templatedPopup.visible(false);
  }
  
  var navigationDirty = ko.observable(
    ko.computed({
      read: function() { return false; },
      write: function() {}
    })
  );

  /**
   * Expects the fieldName to be an integer (or can be parsed to an integer).
   * @param {Object} fieldName name of a integer field.
   */
  function objectComparator(fieldName) {
    return function (obj1, obj2) {
      var int1 = parseInt(obj1[fieldName]),
          int2 = parseInt(obj2[fieldName]);
      if (int1 < int2) {
        return -1;
      }
      if (int1 > int2) {
        return 1;
      }
      return 0;
    };
  }

  function reduce(lst, initial, fn){
    var l = lst.length;
    var i = 0;
    var result = initial;
    while(i<l){
        result = fn(result, lst[i], i);
        i++;
    }
    return result;
  }

  function map(lst, fn){
    var l = lst.length;
    var i = 0;
    while(i<l){
        lst[i] = fn(lst[i], i);
        i++;
    }
    return lst;
  }

  function forEach(lst, fn){
    var l = lst.length;
    var i = 0;
    while(i<l){
        fn(lst[i], i);
        i++;
    }
  }
  
  function makeObservable(obj, fun) {
    if( fun !== undefined ) {
      return mkObsWithFun(obj);
    }
    else {
      return mkObs(obj);
    }
    
    function mkObsWithFun(obj) {
      var result;
      if( obj instanceof Array ) {
        result = [];
      }
      else {
        result = {};
      }
      for( var prop in obj ) {
        if( typeof obj[prop] === "object" ) {
          result[prop] = mkObsWithFun(obj[prop]);
        }
        else {
          result[prop] = ko.observable(obj[prop]);
          result[prop].subscribe(fun);
        }
      }
      return result;
    }
    
    function mkObs(obj) {
      var result;
      if( obj instanceof Array ) {
        result = [];
      }
      else {
        result = {};
      }
      for( var prop in obj ) {
        if( typeof obj[prop] === "object" ) {
          result[prop] = mkObs(obj[prop]);
        }
        else {
          result[prop] = ko.observable(obj[prop]);
        }
      }
      return result;
    }
  }
  
  function makeObservableArray(arr, fun) {
    return arr.map(function(val) {
      return makeObservable(val, fun);
    });
  }
  
  function unmakeObservable(obj) {
    var result;
    if( obj instanceof Array ) {
      result = [];
    }
    else {
      result = {};
    }
    for( var prop in obj ) {
      if( typeof obj[prop] === "function" ) {
        result[prop] = obj[prop]();
      }
      else if( typeof obj[prop] === "object" ) {
        result[prop] = unmakeObservable(obj[prop]);
      }
      else {
        result[prop] = obj[prop];
      }
    }
    return result;
  }
  
  function unmakeObservableArray(arr) {
    return arr.map(function(val) {
      if( typeof val === "object" ) {
        return unmakeObservable(val);
      }
      else if( typeof val === "function" ) {
        return val();
      }
      else {
        return val;
      }
    });
  }
  
  function incWithMax(target, max) {
    var value = parseFloat(target());
    if( value < max ) {
      target(value + 1);
    }
  }

  function incNumber(target){
  var value = parseFloat(target());
  return value + 1;
  }
  
  function decWithMin(target, min) {
    var value = parseFloat(target());
    if( value > min ) {
      target(value-1);
    }
  }
  
  function timeDisplay(target) {
    var value = target();
    var min = parseInt(value / 60);
    var sec = value % 60;
    if( min < 10 ) {
      min = "0" + min;
    }
    if( sec < 10 ) {
      sec = "0" + sec;
    }
    return min + ":" + sec;
  }
  
  function numberFormatter(target) {
    return {
      target: target,
      number: ko.computed({
        read: target,
        write: function( value ) {
          target(isNaN(value) ? 0 : value);
        }
      })
    };
  }
  
  function timeFormatter(target) {
    var second, minute;
    var initial = target();
    var minuteObs = ko.observable(parseInt(parseInt(initial) / 60));
    var secondObs = ko.observable(parseInt(initial) % 60);
    minute = ko.computed({
      read: function() {
        var value = parseInt(target() / 60);
        if( value < 10 ) {
          return "0" + value;
        }
        else {
          return value;
        }
      },
      write: function(value) {
        minuteObs(isNaN(value) ? 0 : value);
      }
    });
    second = ko.computed({
      read: function() {
        var value = parseInt(target() % 60);
        if( value < 10 ) {
          return "0" + value;
        }
        else {
          return value;
        }
      },
      write: function(value) {
        secondObs(isNaN(value) ? 0 : value);
      }
    });
    var time = ko.pureComputed(function() {
      var minute = parseInt(minuteObs());
      var second = parseInt(secondObs());
      return (isNaN(minute) ? 0 : minute * 60) + (isNaN(second) ? 0 : second);
    });
    time.subscribe(function(newValue) {
      target(newValue);
    });
    return {
      target: target,
      minute: minute,
      second: second
    };
  }
  
  // Only used by transfer
  function withDestination(destination, targetreactor, reagent) {
    return {
      destination: ko.pureComputed(function() {
        var dest = destination();
        if( dest === "reactor" ) {
          return "reactor" + targetreactor();
        }
        else {
          return dest;
        }
      }),
      selectReactor: function(reactor) {
        targetreactor(reactor);
        destination("reactor");
        reagent(0);
        //Elixys.hideTemplatedPopup();
      },
      selectCollectionVial: function() {
        targetreactor(0);
        destination("collection vial");
        reagent(0);
        //Elixys.hideTemplatedPopup();
      },
      selectHplc: function() {
        targetreactor(0);
	destination("hplc");
        reagent(0);
        //Elixys.hideTemplatedPopup();
	
	
      }
    };
  };
  
  function playVideo(data, event) {
    event.target.play();
  }
  
  function truncate(target, limit) {
    var text = ko.unwrap(target);
    if( text.length > limit ) {
      return text.substring(0, limit-3) + "...";
    }
    else {
      return text;
    }
  }
  
  /*
   * For chaining AJAX calls, takes a function that takes the fail continuation
   * and returns a list of functions that take the result of the previous call
   * and returns either a deferred or a regular value.
   * The returned value for sequence will be a deferred.
   */
  function sequence(fn) {
    var dfd = $.Deferred();
    var i = 0;
    var fns = fn(fail);
    executeStep();
    
    function fail() {
      dfd.reject.apply(this, arguments);
    }
    
    function executeStep() {
      if( dfd.state() !== "rejected" ) {
        if( i < fns.length ) {
          var pending = fns[i].apply(this, arguments);
          i++;
          // Check for deferred
          if( typeof pending === "object" && typeof pending.done === "function" && typeof pending.fail === "function" ) {
            pending.done(executeStep).fail(fail);
          }
          else {
            executeStep(pending);
          }
        }
        else {
          dfd.resolve.apply(this, arguments);
        }
      }
    }
    
    return dfd;
  }

  return {
    init: init,
    viewModels: viewModels,
    doApiCall: doApiCall,
    initialize: initialize,
    unlock_robots: unlock_robots,
    power: power,
    logOut: logOut,
    reloadPage: reloadPage,
    triggerConnectionErrorPopup: triggerConnectionErrorPopup,
    showNotificationPopup: showNotificationPopup,
    hideNotificationPopup: hideNotificationPopup,
    showNotYetImplementedPopup: showNotYetImplementedPopup,
    showNewSequencePopup: showNewSequencePopup,
    showImportSequencePopup: showImportSequencePopup,
    showTemplatedPopup: showTemplatedPopup,
    hideTemplatedPopup: hideTemplatedPopup,
    navigationDirty: navigationDirty,
    viewManual: viewManual,
    objectComparator: objectComparator,
    reduce: reduce,
    map: map,
    forEach: forEach,
    makeObservable: makeObservable,
    makeObservableArray: makeObservableArray,
    unmakeObservable: unmakeObservable,
    unmakeObservableArray: unmakeObservableArray,
    incNumber: incNumber,
    incWithMax: incWithMax,
    decWithMin: decWithMin,
    timeDisplay: timeDisplay,
    numberFormatter: numberFormatter,
    timeFormatter: timeFormatter,
    withDestination: withDestination,
    playVideo: playVideo,
    truncate: truncate,
    sequence: sequence,
    showTwoButtonPopup: showTwoButtonPopup
  };
}(jQuery, window));

/**
 * Common view model that's used as a base for other view models.
 */
function Common() {
  'use strict';

  var self = this;

  self.isLoggedIn = ko.observable(false).syncWith('isLoggedIn');

  self.isSidebarVisible = ko.observable(false).syncWith('isSideBarVisible');

  self.currentPage = ko.observable().syncWith('currentPage');

  self.filterDateStart = ko.observable('').syncWith('filterDateStart');

  self.filterDateEnd = ko.observable('').syncWith('filterDateEnd');

  self.filterName = ko.observable('').syncWith('filterName');

  self.currentSequence = ko.observable({details: {}}).syncWith('currentSequence');

  self.currentComponents = ko.observable({}).syncWith('currentComponents');

  self.updateAvailable = ko.observable({}).syncWith('updateAvailable');

  self.videoUrl = [camera0_ip, camera1_ip, camera2_ip];

  self.elixysIP = ko.observable(elixys_ip).syncWith('elixysIP');

  self.liquidSensorNumber = ko.observable(liquid_sensor_number).syncWith('liquidSensorNumber');

  self.camera0_position = ko.observable(camera0_position).syncWith('camera0_position');

  self.camera1_position = ko.observable(camera1_position).syncWith('camera1_position');

  self.camera2_position = ko.observable(camera2_position).syncWith('camera2_position');

  self.cameras_disabled = ko.observable(false).syncWith('cameras_disabled');
  self.cameras_enabled = ko.observable(false).syncWith('cameras_enabled');

  self.elixysVersion = ko.observable(elixys_version).syncWith('elixysVersion');



}

/**
 * Connection error popup view model. 
 */
function ConnectionError() {
  'use strict';

  var self = this,
      retryCallback = function () {};

  // inherits Common.
  Common.apply(self, arguments);

  self.visible = ko.observable(false);
  self.showConnectionErrorMessage = ko.observable(true);
  self.showRefreshMessage = ko.observable(false);

  self.setRetry = function (retryFunction) {
    if (typeof retryFunction === 'function') {
      retryCallback = retryFunction;
    }
  };

  self.retry = function () {
    self.visible(false);
    retryCallback();
  };

  self.refresh = function () {
    self.showConnectionErrorMessage(false);
    self.showRefreshMessage(true);
  };

  self.refreshOk = function () {
    self.visible(false);
    Elixys.reloadPage();
  };

  self.refreshCancel = function () {
    self.showRefreshMessage(false);
    self.showConnectionErrorMessage(true);
  };
};

function NotificationPopup() {
  'use strict';

  var self = this;

  // inherits Common.
  Common.apply(self, arguments);

  self.visible = ko.observable(false);
  self.message = ko.observable();
  self.options = ko.observable({});
  
  // Options

     //extra button (for operation error popup abort)
  self.showOtherButton = ko.computed(function() {
    var showOtherButton = self.options().showOtherButton;
    if( showOtherButton !== undefined ) {
      return showOtherButton;
    }
    else {
      return false;
    }
  });



  self.showCloseButton = ko.computed(function() {
    var showCloseButton = self.options().showCloseButton;
    if( showCloseButton !== undefined ) {
      return showCloseButton;
    }
    else {
      return false;
    }
  });


  //extra callback (for operation error abort)
  self.otherCallback = ko.computed(function() {
    return self.options().otherCallback;
  });


  self.confirmCallback = ko.computed(function() {
    return self.options().confirmCallback;
  });
  
  self.cancelCallback = ko.computed(function() {
    return self.options().cancelCallback;
  });


  //extra text (for operation error abort)
  self.otherText = ko.computed(function() {
    var otherText = self.options().otherText;
    if( otherText !== undefined ) {
      return otherText;
    }
    else {
      return "Other";
    }
  });


  
  self.confirmText = ko.computed(function() {
    var confirmText = self.options().confirmText;
    if( confirmText !== undefined ) {
      return confirmText;
    }
    else {
      return "Confirm";
    }
  });
  
  self.cancelText = ko.computed(function() {
    var cancelText = self.options().cancelText;
    if( cancelText !== undefined ) {
      return cancelText;
    }
    else {
      return "Cancel";
    }
  });


  //extra (for operation error abort)
  self.other = function() {
    var callback = self.otherCallback();
    if( callback ) {
      callback();
    }
    self.visible(false);
  };

  
  self.confirm = function() {
    var callback = self.confirmCallback();
    if( callback ) {
      callback();
    }
    self.visible(false);
  };
  
  self.close = function() {
    var callback = self.cancelCallback();
    if( callback ) {
      callback();
    }
    self.visible(false);
  }
};

function Login() {
  'use strict';

  var self = this;

  // inherits Common.
  self.updateComplete = ko.observable(true);
  Common.apply(self, arguments);



  self.logIn = function () {
    Elixys.doApiCall("/login", null, function(success){}, function(error){});
    self.isLoggedIn(true);
    self.currentPage('SEQUENCES');
  };


self.softwareUpdateAvailable = function(){
    var status = self.updateAvailable().status;

    return status;

    }

  self.showSoftwareUpdate = function(){
          var result = Elixys.doApiCall('/software_show_updates', {},
          function(result){
          var software_update = result["software_show_updates"];

          if(software_update.error != null){
          self.updateAvailable({"status":false});
          }

          else{
          self.updateAvailable({"status":true});

          }

          }

          );


        }

self.showSoftwareUpdate();

self.updateStatusInterval = undefined;

self.update_software = function(){
    if(self.updateComplete() === false){
    return ;
    }
    else{
    self.updateComplete(false);
    }
	Elixys.showNotificationPopup("Update Elixys Software?",
		        {
		        confirmCallback: function(){
		        //Elixys.hideNotificationPopup();

		        Elixys.doApiCall("/software_update",{software_update : {}},function(result){
		            Elixys.showNotificationPopup("Updating software - do no remove USB", {showCloseButton: true});
		            var message = result["software_update"];

		            if(message.error !== null){
                    var error_message = message.status_message;
                    self.updateComplete(true);
                    Elixys.showNotificationPopup(error_message, {showCloseButton: true});
		            }

		            else{

                    self.updateStatusInterval = window.setInterval(pollUpdateStatus, 1500);

                    }
		            });

		        }
		        ,
                confirmText: "Yes",
                cancelCallback: function() {self.updateComplete(true);},
                cancelText: "No"
                });

  }



  function pollUpdateStatus() {
        var result = Elixys.doApiCall("/software_update",
        {
        software_update: {
            query: true
            }
        },
        function(result){
		            var update_status = result["software_update"];
                    var running_status = update_status["running"];
                    var info = update_status["info"];
                    var status_message = update_status["status_message"];

                        if(running_status===false){
                            self.updateComplete(true);
                            window.clearInterval(self.updateStatusInterval);
                            Elixys.showNotificationPopup(status_message, {showCloseButton: true});
                        }
                        else{
                        self.updateComplete(false);
                        }


		            });
  }




}




/*
 * Logs view model.
 */
function Logs() {
	'use strict';
	
	var self = this;


	var getLogs = function() {
    Elixys.sequence(function(fail) {
      return [
        function() {
          Elixys.showNotificationPopup("Loading...");
          return Elixys.doApiCall("/get_logs");
        },
        function(result) {
          if(result.error) {
            return fail(result.error);
          }
          var sequences = result["get_logs"];
          sequences.forEach(function(sequence) {
            sequence.displayDate = trimDate(sequence.date);
            sequence.displayTime = trimTime(sequence.time);
          });
          sequences.reverse();
          self.sequences(sequences);
          Elixys.hideNotificationPopup();
        }
      ];
    }).fail(function(error) {
      if(typeof error === "string") {
        Elixys.showNotificationPopup("Error: " + error, {
          showCloseButton: true
        });
      }
      else {
        Elixys.showNotificationPopup("There was an error retrieving the logs.", {
          showCloseButton: true
        });
      }
    });
	};
  
  function trimDate(date) {
    return date.substring(0,6) + date.substring(8);
  }
  
  function trimTime(time) {
    var hour = parseInt(time.substring(0,2));
    var minute = time.substring(3,5);
    var ampm;
    if( hour >= 12 ) {
      ampm = "pm";
    }
    else {
      ampm = "am";
    }
    if( hour > 12 ) {
      hour = hour - 12;
    }
    else if( hour === 0 ) {
      hour = 12;
    }
    return hour + ":" + minute + ampm;
  }
	
  // inherits Common.
  Common.apply(self, arguments);

  self.name = 'LOGS';
  self.sequences = ko.observableArray();
  self.logsToExport = [];
  self.downloadLogsEnabled = ko.observable(false);
  self.exportStatusInterval = undefined; //will be defined when generate export logs started
  self.exportComplete = ko.observable(true); //initially true
  self.percentExportComplete = ko.observable("");


  //disable download link -- see postRender for html element
  function removeDownloadLink(){
    self.downloadLogsEnabled(false);
    self.downloadLogsEnabled.valueHasMutated();
  }


  // Filters
  self.sequencesFiltered = ko.computed(function() {
    var filterStr = self.filterName();
    var filterDateStart = Date.parse(self.filterDateStart());
    var filterDateEnd = Date.parse(self.filterDateEnd());
    if ((filterStr != null && filterStr.length > 0) ||
        (!isNaN(filterDateStart) || !isNaN(filterDateEnd))) {
      filterStr = filterStr.toLowerCase();
      return ko.utils.arrayFilter(self.sequences(), function(seq) {
        return ((seq.details.name != null && seq.details.name.toLowerCase().indexOf(filterStr) != -1)
                || (seq.details.comment != null && seq.details.comment.toLowerCase().indexOf(filterStr) != -1))
          && (isNaN(filterDateStart) || (!isNaN(Date.parse(seq.date)) && filterDateStart <= Date.parse(seq.date)))
          && (isNaN(filterDateEnd) || (!isNaN(Date.parse(seq.date)) && filterDateEnd >= Date.parse(seq.date)));
      });
    }
    return self.sequences();
  });

  self.visible = ko.computed(function() {
    return self.currentPage() === self.name;
  });

  self.visible.subscribe(function() {
    if (self.visible()) {
      getLogs();
    }
    else{
      clearInterval(self.exportStatusInterval);
    }
  });

   //select to export all logs
   self.exportAllLogsEnabled = ko.observable(false);
   self.updateAllLogsExport = function(){
	    var new_en_state = !self.exportAllLogsEnabled();
	    self.exportAllLogsEnabled(new_en_state);
        var id = 0;
        if(new_en_state===true){
            var export_state = true;
            }
        else{
        var export_state = false;
        }
        for(var seq in self.sequences()){
	        id = self.sequences()[seq].sequenceid;
	        self.exportLogIds()[id] = export_state;

	        }
	     self.exportLogIds.valueHasMutated();
	};

  //poll export status to see when ready
  function pollExportStatus(){
  var result = Elixys.doApiCall("/get_export_logs_status",{get_export_logs_status:{}},
        function(result){
		            var export_status = result["get_export_logs_status"];
                    var error = export_status["error"];
                    var running = export_status["running"];
                    var message = export_status["message"];
                    var data_available = export_status["data_available"];
                    if(error===true){
                        self.exportComplete(true);
                        window.clearInterval(self.exportStatusInterval);
                        Elixys.showNotificationPopup(message, {showCloseButton: true});

                    }
                    else{
                        if(running===false){
                            if(data_available === true){
                            window.clearInterval(self.exportStatusInterval);
                            self.downloadLogsEnabled(true);
                            self.exportComplete(true);
                            }
                            else{
                                //export logs does not have anything for export or is not running
                                window.clearInterval(self.exportStatusInterval);
                                self.downloadLogsEnabled(false);
                                self.exportComplete(true);

                            }

                        }
                        else{
                          //show % complete
                          var percent = export_status["percent_complete"];
                          self.percentExportComplete(percent + "% Complete");
                          self.exportComplete(false);

                        }

                    }

		            });
  }

  //send export logs request
  self.generateExportLogs = function(){
    self.downloadLogsEnabled(false);
    self.logsToExport = []; //clear array
    var id = 0;
	    for(var seq in self.sequences()){
	        id = self.sequences()[seq].sequenceid;
	        if(self.exportLogIds()[id]===true){
	           self.logsToExport.push(id);
	        }
	    }
	 //send request with sequences to export
	 var result = Elixys.doApiCall('/export_logs', {export_logs: self.logsToExport},
          function(result){
          var export_status = result["export_logs"];

          if(export_status.error !== undefined){
            self.downloadLogsEnabled(false);
            Elixys.showNotificationPopup(export_status.error, {showCloseButton: true});

          }
          else{
            clearInterval(self.exportStatusInterval);
            self.exportStatusInterval = window.setInterval(pollExportStatus, 1000);
          }

          });
  }

  //select export individual logs
  self.exportLogIds = ko.observable({});
	self.updateLogsExport = function(id){
	    var id = id.sequenceid;
	    if(self.exportLogIds()[id]!==undefined){
	    self.exportLogIds()[id] = !self.exportLogIds()[id]; //toggle value
	    }
	    else{
	        self.exportLogIds()[id] = true;
	    }
	    self.exportLogIds.valueHasMutated();
	};


    //Warning -  exportLogIP is not used at the moment
	self.exportLogIp = ko.computed(function() {
	    var elixys_ip = self.elixysIP();
	    var export_address = elixys_ip + "/export_logs?";
	    var id = 0;
	    for(var seq in self.sequences()){
	        id = self.sequences()[seq].sequenceid;
	        if(self.exportLogIds()[id]===true){
	            export_address = export_address.concat(id+"="+1+"&"); //ex GET request: ipaddress/export_logs?123=1&304=1&...etc
	        }
	    }
	    export_address = export_address.slice(0,-1);
	    return export_address;

	});

	self.downloadLogIp = ko.computed(function() {
	    var download_export_address = "/download_export_logs";
	    return download_export_address;

	});

  self.exportSequence = function(sequenceid){
    window.location = "/export_sequence?sequenceid=" + sequenceid;
  }

  self.viewSequence = function(sequence) {
    return Elixys.doApiCall("/get_sequence_and_components", {
      get_sequence_and_components: {
        sequenceid: sequence.sequenceid
      }
    }, function(payload) {
      var result = payload["get_sequence_and_components"];
      if( result.error ) {
        console.log(result);
      }
      else {
        self.currentSequence(result["sequence"]);
        self.currentComponents(result["components"]);
        self.currentPage(Elixys.viewModels.editSequence.name);
      }
    }, function() {
      console.log('error');
    });
  };

  self.postRender = function() {
    $("#input-date-start").clearSearch();
    $("#input-date-end").clearSearch();
    $("#sequence-search-button").clearSearch();
    //download link - disappear after click
        self.downloadLink = window.document.getElementById("export-logs-download");
        self.downloadLink.onclick = removeDownloadLink;

    //see if logging was taking place (if user had to logout of GUI and then log back for ex)
    if(self.exportStatusInterval === undefined){
        self.exportStatusInterval = window.setInterval(pollExportStatus, 1000);
    }
  }

}

function SidebarNavigation() {
  'use strict';

  var self = this;
  var autoCloseTimeout = null;

  // inherits Common.
  Common.apply(self, arguments);
  
  self.options = [
    new SidebarOption("SEQUENCES", "sequences"),
    new SidebarOption("LOGS", "logs"),
    new SidebarOption("RUNNING", ko.pureComputed(function() {
      var isRunning = Elixys.viewModels.running.isRunning();
      if( isRunning ) {
        return "running";
      }
      else {
        return "running disabled";
      }
    })
    , function() {
      Elixys.viewModels.running.goToPage();
    }),
	
	new SidebarOption("SYSTEM", "system"),

	new SidebarOption("MANUAL", "elixys_manual", function(){
    Elixys.viewManual();
    }),
    new SidebarOption("LOG OUT", "logout", function() {
      Elixys.logOut();
    }),
		
  new SidebarOption("Power", "power",
      function() {
      Elixys.power();

		})

  ];

  self.executeAction = function (option) {
    // Automatically close the menu when a selection is made.
    self.isSidebarVisible(false);

    if (self.isLoggedIn()) {
      var dirty = Elixys.navigationDirty()();
      if( dirty ) {
        Elixys.showNotificationPopup("You have unsaved changes that will be lost if you navigate away. Continue?", {
          confirmCallback: function() {
            Elixys.navigationDirty()(false);
            option.action();
          },
          confirmText: "Continue"
        });
      }
      else {
        option.action();
      }
    }
    else {
      alert("You have been automatically logged out");
      Elixys.logOut();
    }
  };

  self.toggleSidebar = function() {
    var opening = !self.isSidebarVisible();
    self.isSidebarVisible(opening);
    // Auto-close the menu after 5 seconds.
    if (opening) {
      window.clearTimeout(autoCloseTimeout);
      autoCloseTimeout = window.setTimeout(function() {
          self.isSidebarVisible(false);
        }, 5000);
    } else {
      window.clearTimeout(autoCloseTimeout);
    }
  };

  self.isSystemPage = ko.pureComputed(function() {
        return self.currentPage() == "SYSTEM";
  });

  function SidebarOption(pageName, className, action) {
    'use strict';

    var optionSelf = this;

    optionSelf.pageName = pageName;

    if( typeof className === "string" ) {
      optionSelf.imageClass = ko.observable("image-container " + className);
    }
    else {
      optionSelf.imageClass = ko.pureComputed(function() {
        return "image-container " + className();
      });
    }
    
    if( action ) {
      optionSelf.action = action;
    }
    else {
      optionSelf.action = function() {
        self.currentPage(pageName);
      };
    }
  }
}

/**
 * Sequences view model.
 */
function Sequences() {
  'use strict';

  var self = this,
      getSequences = function () {
        return Elixys.doApiCall('/get_sequences', {
          'get_sequences': {
            'userid': 0
          }
        }, function (result) {
          var sequences = result["get_sequences"];
          sequences.sort(function(a, b) {
            var aName = a.details.name.toLowerCase();
            var bName = b.details.name.toLowerCase();
            if( aName > bName ) {
              return 1;
            }
            else if( aName < bName ) {
              return -1;
            }
            else {
              return 0;
            }
          });
          self.sequences(sequences);
        }, function () {
          console.log('error');
          Elixys.triggerConnectionErrorPopup(getSequences);
        });
      };
  var getComponents = function(sequenceId) {
    return Elixys.sequence(function(fail) {
      return [
        function() {
          Elixys.showNotificationPopup("Loading...");
          return Elixys.doApiCall("/get_components", {
            get_components: {
              sequenceid: sequenceId
            }
          });
        },
        function(payload) {
          if( payload.error ) {
            return fail(payload.error);
          }
          else {
            return payload.get_components;
          }
        },
        function(result) {
          self.currentComponents(result);
          Elixys.hideNotificationPopup();
        }
      ];
    }).fail(function(error) {
      if( typeof error === "string" ) {
        Elixys.showNotificationPopup("Error: " + error, {
          showCloseButton: true
        });
      }
      else {
        Elixys.showNotificationPopup("Error loading sequence operations.", {
          showCloseButton: true
        });
      }
    });
  };
  var getSequenceAndComponents = function(sequenceId) {
    return Elixys.doApiCall('/get_sequence_and_components', {
      'get_sequence_and_components': {
        'sequenceid': sequenceId
      }
    }, function(result) {
      var result2 = result['get_sequence_and_components'];
      self.currentSequence(result2['sequence']);
      self.currentComponents(result2['components']);
    }, function() {
      console.log('error');
    });
  };
  // For debugging purposes only
  var getComponentStructure = function(componentType) {
    return Elixys.doApiCall('/get_structure', {
      'get_structure': {
        'type': 'component',
        'componenttype': componentType
      }
    }, function(result) {
      console.log(result['get_structure']);
    }, function() {
      console.log('error');
    });
  };

  // inherits Common.
  Common.apply(self, arguments);

  self.export_sequence = function(sequence){
    var link = document.createElement("a");
    link.href = "/export_sequence?sequenceid=" + sequence.sequenceid;
    link.click();
  }

  self.name = 'SEQUENCES';
  self.sequences = ko.observableArray();
  self.sequenceListScroller = new SequenceListScroller();

  // Filters
  self.sequencesFiltered = ko.computed(function() {
    var filterStr = self.filterName();
    var filterDateStart = Date.parse(self.filterDateStart());
    var filterDateEnd = Date.parse(self.filterDateEnd());
    if ((filterStr != null && filterStr.length > 0) ||
        (!isNaN(filterDateStart) || !isNaN(filterDateEnd))) {
      filterStr = filterStr.toLowerCase();
      return ko.utils.arrayFilter(self.sequences(), function(seq) {
        return ((seq.details.name != null && seq.details.name.toLowerCase().indexOf(filterStr) != -1)
                || (seq.details.comment != null && seq.details.comment.toLowerCase().indexOf(filterStr) != -1))
          && (isNaN(filterDateStart) || (!isNaN(Date.parse(seq.date)) && filterDateStart <= Date.parse(seq.date)))
          && (isNaN(filterDateEnd) || (!isNaN(Date.parse(seq.date)) && filterDateEnd >= Date.parse(seq.date)));
      });
    }
    return self.sequences();
  });

  self.visible = ko.computed(function () {
    return self.currentPage() === self.name;
  });
  self.visible.subscribe(function () {
    if (self.visible()) {
      Elixys.showNotificationPopup('Loading...');
      getSequences().complete(function () {
        Elixys.hideNotificationPopup();
      });
    }
  });

  self.newSequence = function () {
    Elixys.showNewSequencePopup({
      create: function(name, description) {
        return Elixys.sequence(function(fail) {
          return [
            function() {
              return Elixys.doApiCall("/add_sequence_and_cassettes", {
                add_sequence_and_cassettes: {
                  userid: 1,
                  details: {
                    name: name,
                    comment: description,
                    valid: 0
                  }
                }
              })
            },
            function(payload) {
              var result = payload["add_sequence_and_cassettes"];
              if( result.error ) {
                fail(result.error);
              }
              else {
                self.currentSequence(result.sequence);
                self.currentPage("EDIT SEQUENCE");
              }
            }
          ];
        });
      }
    });
  };

  self.importSequence = function () {
    Elixys.showImportSequencePopup({
      validateImport: function(importCtrl){
        var file_object = importCtrl.file();
        if(file_object !== undefined){
            var seq_import_pattern = /[.](sequence|zip)/g; //regex
            var sequence_index = file_object.name.search(seq_import_pattern);

            if(sequence_index>1){
                var seq_name = file_object.name.substring(0, sequence_index);
                importCtrl.currentImportName(seq_name);
                importCtrl.name(importCtrl.currentImportName());
                importCtrl.import_file_valid(true);
                importCtrl.import_file_valid.valueHasMutated();
            }
            else{
               importCtrl.currentImportName("Invalid file type");
               importCtrl.currentImportName.valueHasMutated();
               importCtrl.import_file_valid(false);
            }
        }
        else{
           importCtrl.import_file_valid(false);
        }
      },
      importFile: function(importCtrl){
        var seq_file = importCtrl.file();
        importCtrl.import_name = seq_file.name;
        var file_reader = new FileReader();
        file_reader.onload = function(e) {
          var result = e.target.result;
          var fileType = seq_file.name.search(/[.](zip)/g) > 0 ? "zip" : "sequence";
            Elixys.doApiCall("/import_sequence", { import_sequence: {"sequence_data": btoa(e.target.result), "import_name": importCtrl.name(), "file_type": fileType} },
              function(res){
                var result = res["import_sequence"];
                if( result.error ) {
                  var error = result.error;
                  if( typeof error === "string" ) {
                    importCtrl.buttonText("Import");
                    Elixys.showNotificationPopup("Error: " + error, {
                      showCloseButton: true
                    });
                  }
                  else {
                    importCtrl.buttonText("Import");
                    Elixys.showNotificationPopup("There was an error importing the sequence.", {
                      showCloseButton: true
                    });
                  }
                  importCtrl.notBusy(true);
                }
                else {
                  importCtrl.notBusy(true);
                  importCtrl.buttonText("Import");
                  importCtrl.close();
                  self.currentSequence(result.sequence);
                  self.currentPage("EDIT SEQUENCE");
                }
              },
              function(err){
                importCtrl.notBusy(true);
                importCtrl.buttonText("Import");
                Elixys.showNotificationPopup("There was an error importing the sequence.", {
                  showCloseButton: true
                });
              }
            );
        };
        file_reader.readAsBinaryString(seq_file);
      }
    });
  };

  self.editSequence = function (sequence) {
    self.currentSequence(sequence);
    self.currentPage('EDIT SEQUENCE');
    getComponents(sequence['sequenceid']);
  };

  self.copySequence = function (sequence) {
    Elixys.showNewSequencePopup({
      titleText: "Copy Sequence",
      buttonText: "Copy",
      create: function(name, description) {
        return Elixys.sequence(function(fail) {
          return [
            function() {
              return Elixys.doApiCall("/copy_sequence_and_components", {
                copy_sequence_and_components: {
                  sequenceid: sequence.sequenceid,
                  name: name,
                  comment: description
                }
              });
            },
            function(payload) {
              var result = payload["copy_sequence_and_components"];
              if( result.error ) {
                fail(result.error);
              }
              else {
                self.currentSequence(result.sequence);
                self.currentPage("EDIT SEQUENCE");
              }
            }
          ];
        });
      }
    });
  };

  self.deleteSequence = function (sequence) {
    Elixys.showNotificationPopup("Are you sure you wish to delete sequence \"" + sequence.details.name + "\"?", {
      confirmCallback: function() {
        window.setTimeout(function() {
          Elixys.showNotificationPopup("Deleting...");
          return Elixys.doApiCall("/delete_sequence", {
            delete_sequence: {
              sequenceid: sequence.sequenceid
            }
          }, function(result) {
            // Refresh sequence list
            Elixys.showNotificationPopup('Loading...');
            return getSequences().complete(function () {
              Elixys.hideNotificationPopup();
              if( self.currentSequence() && self.currentSequence().sequenceid == sequence.sequenceid ){
                self.currentSequence(null);
              }
            });
          });
        }, 0);
      },
      cancelCallback: function() {
        // Just dismisses the dialog.
      }
    });
  };
  
  self.trimDate = function(target) {
    return target.substring(0, 6) + target.substring(8);
  };

  self.postRender = function() {
    $("#input-date-start").clearSearch();
    $("#input-date-end").clearSearch();
    $("#sequence-search-button").clearSearch();
  }

}

function Reagent(position, description, name) {
  'use strict';

  var self = this;
  self.position = position;
  self.description = description;
  self.name = name;
}

function SequenceListScroller(){
    var self = this;
    self.scrollElement = null;
    self.initialScroll = 0;
    self.initialOffset = 0;
    self.start = function(element, task, dd){
        var result = false;
        self.scrollElement = $(element).parent().parent();
        self.initialScroll = self.scrollElement.scrollTop();
        self.initialOffset = dd.offsetY;
        return $(element);
    };
    self.drag = function(element, task, dd){
        self.scrollElement.scrollTop(self.initialScroll+self.initialOffset-dd.offsetY);
    };
    self.end = function(element, task, dd){
    };
}

function ElixysManual() {
  'use strict';

  var self = this;
  self.name = 'ELIXYS MANUAL';
  self.__default_manual = "/elixys_manual#zoom=100";
  self.src = ko.observable("");
  Common.apply(self, arguments);

  self.visible = ko.pureComputed(function(){
    return self.currentPage() == self.name;
  });

  self.isSidebarVisible.subscribe(function(open){
    self.width( self.getWidth(open) );
  });

  self.returnToSequence = function(){
    if( self.canReturnToSequence() ){
      self.currentPage("EDIT SEQUENCE");
    }
  }

  self.canReturnToSequence = function(){
    return self.currentSequence() != null && self.currentSequence().sequenceid != undefined;
  }

  self.getWidth = function(open){
    if( open ){
      return "95%;";
    }
    else{
      return "102%;";
    }
  }

  self.width = ko.observable( self.getWidth(false) );

  self.view = function( src ){
    self.currentPage(self.name);

    var docContainer = document.getElementById("manual-pdf");
    if( src ){
      docContainer.src = "/static/please-wait.html";
      setTimeout(function(){
        docContainer.src = src;
      }, 100);
    }
    else{
      docContainer.src = self.__default_manual;
    }
  }

}
function System() {
  'use strict';

  var self = this;
  // inherits Common.
  Common.apply(self, arguments);
  
  self.selectedSystemTemplate = ko.observable('videocalibrate-template');

  self.name = 'SYSTEM';
  self.visible = ko.computed(function() {
    return self.currentPage() === self.name;
  });
  self.monitor = new ElixysMonitor();
  self.reactors = [];
  self.coolantPump = new CoolantPump(1, self.monitor);
  self.vacuumPump = new VacuumPump(self.monitor);
  self.hplc = new HPLC(self.monitor);
  self.inertGasValve = new InertGasValve(self.monitor, "inert");
  self.activeGasValve = new ActiveGasValve(self.monitor, "active");
  self.ctrlMode = ko.observable("");
  self.cameras = [];
  self.mixers = [];
  self.heaters = [];
  self.pressureRegulators = [];
  self.stopcocks = [];
  self.cassettes = [];

  self.pressureRegulators.push(new PressureRegulator("Inert Pressure", 0, self.monitor));
  self.pressureRegulators.push(new PressureRegulator("Pneumatic Pressure", 1, self.monitor));
  self.radiationSensors = [];
  for(var i = 0; i < 7; i++){
    var radSensor = new RadiationSensor(i, self.monitor);
    self.radiationSensors.push(radSensor);
  }
  var numReactors = 3;
  for( var r = 0; r < numReactors; r++ ){
    var reactor = new Reactor(r, self.monitor);
    var cam = reactor.camera;
    var mixer = reactor.mixer;
    self.reactors.push(reactor);
    self.cameras.push(cam);
    self.mixers.push(mixer);
    self.heaters = self.heaters.concat(reactor.heaters);
    self.stopcocks = self.stopcocks.concat(reactor.stopcocks);
  }

  self.reactors[0].heater.canChangeHeat.subscribe(function(newVal){
    var heaterA = self.reactors[1].heater;
    var heaterB = self.reactors[2].heater;
    if( heaterA.canChangeHeat() != newVal ) { heaterA.canChangeHeat(newVal); }
    if( heaterB.canChangeHeat() != newVal ) { heaterB.canChangeHeat(newVal); }
  });

  self.reactors[1].heater.canChangeHeat.subscribe(function(newVal){
    var heaterA = self.reactors[0].heater;
    var heaterB = self.reactors[2].heater;
    if( heaterA.canChangeHeat() != newVal ) { heaterA.canChangeHeat(newVal); }
    if( heaterB.canChangeHeat() != newVal ) { heaterB.canChangeHeat(newVal); }
  });

  self.reactors[2].heater.canChangeHeat.subscribe(function(newVal){
    var heaterA = self.reactors[0].heater;
    var heaterB = self.reactors[1].heater;
    if( heaterA.canChangeHeat() != newVal ) { heaterA.canChangeHeat(newVal); }
    if( heaterB.canChangeHeat() != newVal ) { heaterB.canChangeHeat(newVal); }
  });
  
  var numCassettes = 3;
  for( var c = 0; c < numCassettes; c++){
    var cassette = new Cassette(c);
    cassette.displaySPECartridge(false);
    self.cassettes.push(cassette);
  }
  self.reagentRobot = new ReagentRobot(self.monitor, self.cassettes);

  self.cameraCalibrations = new CalibrateCameras(self.cameras);
  self.liquidSensorCalibration = new CalibrateLiquidSensor(self.monitor);
  self.mixerCalibrations = new CalibrateMixers(self.mixers);
  self.pressureRegulatorCalibrations = new PressureRegulatorsCalibrations(self.pressureRegulators);
  self.reactorCalibrations = new ReactorCalibrations(self.reactors,self.pressureRegulators[1]);
  self.cassetteCalibrations = new CalibrateCassettes(self.reagentRobot, self.cassettes);
  self.reagentRobotCalibrations = new ReactorCalibrations(self.reagentRobot);

  self.stateMonitorInterval = undefined;

  self.postRender = function() {
    if(self.currentPage() === self.name){
      self.stateMonitorInterval = window.setInterval(pollStateMonitor, 1000);
    }
  }

  function pollStateMonitor() {
    if(self.currentPage()!==self.name){window.clearInterval(self.stateMonitorInterval);}
    return self.monitor.requestState();
  }
  
  self.toggleSidebar = function() {
	Elixys.viewModels.sidebarNavigation.toggleSidebar();  
  }

}

function EditSequence() {
  'use strict';

  var self = this;

  // inherits Common.
  Common.apply(self, arguments);

  //dictionary of selected reagents and the task they belong to (prevent task from using already selected reagent)
  self.selectedReagents = ko.observable({});
  self.operationOrders = ko.observable({});

  for(var i = 0; i<=35; i++){self.selectedReagents()[i]={"task":undefined, "selected":false};}
function trimTime(time) {
    var hour = parseInt(time.substring(0,2));
    var minute = time.substring(3,5);
    var sec = time.substring(6,8);
    var ampm;
    if( hour >= 12 ) {
      ampm = "pm";
    }
    else {
      ampm = "am";
    }
    if( hour > 12 ) {
      hour = hour - 12;
    }
    else if( hour === 0 ) {
      hour = 12;
    }
    return hour + ":" + minute + ":" + sec + ampm;
  }


  //get status logs
  self.statusLogs = ko.observableArray();
  self.getStatusLogs = function(){
          var result = Elixys.doApiCall('/get_status_logs', {
              'get_status_logs': {
                'sequenceid': self.currentSequence().sequenceid
              }
            },
            function(result){
              var data = result["get_status_logs"];
              data.forEach(function(status_log) {
                status_log.operation_status.time = trimTime(status_log.operation_status.time);
              });

              self.statusLogs(data);
            }

          );

  }
  //update operation order numbers for labeling on edit page
  function updateOperationOrders(){
  //populate order of operations
          self.dragDropManager.taskSequence().map(function(task, ix) {
            self.operationOrders()[ix] = {"order":ix + 1};
            self.dragDropManager.taskSequence()[ix].order(ix+1);

        })
  }

  function getComponents(sequenceId) {
    return Elixys.sequence(function(fail) {
      return [
        function() {
          return Elixys.doApiCall('/get_components', {
            'get_components': {
              'sequenceid': sequenceId
            }
          });
        },
        function(result) {
          self.currentComponents(result['get_components']);
          return self.populateComponents(result['get_components']);
        },
        function(cassettes, components) {
          self.cassettes(cassettes);
          self.dragDropManager.taskSequence(components);
          //populate selected reagents list
          //clear first
          for(var i = 0; i<=35; i++){self.selectedReagents()[i]={"task":undefined, "selected":false};}

          //populate order of operations
          updateOperationOrders();

          //look for components with reagentpos values
          for(var i in self.dragDropManager.taskSequence()){

            if(self.dragDropManager.taskSequence()[i].data.reagentpos!==undefined){

                var pos = parseInt(self.dragDropManager.taskSequence()[i].data.reagentpos());
                if(pos >=0){
                self.selectedReagents()[pos]["task"] = self.dragDropManager.taskSequence()[i];
                self.selectedReagents()[pos]["selected"] = true;
                }


            }
          }


          self.deleteList = [];
          self.dirty(false);
          self.dragDropManager.selectedOptionsDrag.dragActions.arrowsRequired();
          // Keep the same Operation selected, if possible.
          self.dragDropManager.toggleSelectedOptionById(self.previouslySelectedTaskId);
        }
      ];
    }).fail(function() {
      Elixys.triggerConnectionErrorPopup(getComponents);
    });
  }
  // This is called for loaded Tasks
  self.populateComponents = function(components) {
    var details,
        i,
        component,
        cassettes = [],
        components,
        rawTasks = [],
        tasks = [];
    for (i = 0; i < components.length; i++) {
      component = components[i];
      details = component.details;

      // cassette
      if (component.componenttype === 'CASSETTE') {
        component.reagents.sort(Elixys.objectComparator('position'));
        cassettes[details.reactor] = new Cassette(component);
      }
      // tasks
      else {
        rawTasks.push(component);
      }
    }
    
    rawTasks.sort(Elixys.objectComparator("order"));
    // Need to set cassettes in order to be able to reference them for reagent observables.
    self.cassettes(cassettes);
    
    components = rawTasks.map(function(component) {
      var fields = componentTypeMap[component.componenttype];
      if( fields !== undefined ) {
        var loadedTask = new Task(
          fields.name,
          component.componentid,
          "selectedTasks",
          fields.className,
          " box dropped",
          fields.templateName,
          component.componenttype,
          Elixys.makeObservable(component.details, setDirty),
          fields.pressure,
          fields.validators
        );
        return loadedTask;
      }
    });
    
    // We use a deferred to "return" multiple values
    return $.Deferred().resolve(cassettes, components);
  };
  
  self.dirty = ko.observable(false);
  
  var _navigationDirty = Elixys.navigationDirty();
  Elixys.navigationDirty(
    ko.computed({
      read: function() {
        return self.dirty() || _navigationDirty();
      },
      write: function(value) {
        if( value === false ) {
          self.dirty(false);
          _navigationDirty(false);
        }
      }
    })
  );

  function setDirty() {
    if( self.currentPage() === self.name ) {
      self.dirty(true);
    }
  }
  function reagentValidator(reagentPos){
      return ko.pureComputed(function(){
        if( reagentPos ){
          var position = reagentPos();
          var inRange = rangeValidator(position, 0, 35);
          if( !inRange ) return false;

          var cassetteIndex = parseInt( position / 12 );
          var reagentIndex = parseInt( position % 12 );

          if( !(cassetteIndex >= 0 && cassetteIndex <= 2) ) return false;

          var cassette = Elixys.viewModels.editSequence.cassettes()[cassetteIndex];
          if( cassette ){
            var reagent = Elixys.viewModels.editSequence.cassettes()[cassetteIndex].reagents[reagentIndex];
            return reagent && reagent.name && reagent.name() != "";
          }
          return false;
        }
        return false;
      })
  }
  function rangeValidator(target, min, max) {
    return ko.pureComputed(function() {
      var value = target();
      return value >= min && value <= max;
    });
  }

  function stringLengthValidator(target, max) {
    return ko.pureComputed(function() {
      var value = target();
      return value == null || value.length <= max;
    });
  }
  
  function optionValidator(target, options) {
    return ko.pureComputed(function() {
      var value = target();
      for( var i = 0; i < options.length; i++ ) {
        if( value === options[i] ) {
          return true;
        }
      }
      return false;
    });
  }

  self.viewInstructionOptions = function(){
    if( self.hasInstructions() ){
      Elixys.showTwoButtonPopup({
        titleText: "Instruction Options",
        btnAText: "View",
        btnAClick: function(popup){
          popup.close();
          self.getInstructions();
        },
        btnBText: "Overwrite",
        btnBClick: function(popup){
          popup.close();
          self.openAttachmentDialog();
        }
      });
    }
    else{
      self.openAttachmentDialog();
    }
  }

  var componentTypeMap = {
    ADD: {
      name: "ADD REAGENT",
      className: "add-operation",
      templateName: "add-template",
      pressure: function(data) {
        return data.deliverypressure;
      },
      validators: function(data) {
        var stirmode_valid = optionValidator(data.stirmode, ["after operation", "during operation"]);
        var stir_valid = rangeValidator(data.stir, 0, 1);
        var stirmodeValidator = ko.pureComputed(function() {
          var mode_valid = stirmode_valid();
          if( data.stir() === 1 ) {
            return mode_valid;
          }
          else {
            return true;
          }
        });
        return {
          deliveryposition_valid: rangeValidator(data.deliveryposition, 0, 1),
          deliverypressure_valid: rangeValidator(data.deliverypressure, 0, 30),
          deliverytime_valid: rangeValidator(data.deliverytime, 0, 3599),
          durationofstir_valid: rangeValidator(data.durationofstir, 0, 3599),
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          reagentpos_valid: reagentValidator(data.reagentpos),
          stir_valid: ko.pureComputed(function() {
            return stir_valid() && stirmodeValidator();
          }),
          stirmode_valid: stirmodeValidator,
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    EVAPORATE: {
      name: "EVAPORATE",
      className: "evaporate-operation",
      templateName: "evaporate-template",
      pressure: function(data) {
        return data.evaporationpressure;
      },
      validators: function(data) {
        var durationofstir_valid = rangeValidator(data.durationofstir, 0, 3599);
        var stirdelay_valid = rangeValidator(data.stirdelay, 0, 3599);
        var stir_valid = rangeValidator(data.stir, 0, 1);
        var stirdelayValidator = ko.pureComputed(function() {
          var delay_valid = stirdelay_valid();
          var duration = data.evaporationduration();
          var delay = data.stirdelay();
          if( data.stir() === 1 ) {
            return delay_valid && delay <= duration;
          }
          else {
            return true;
          }
        });
        var durationofstirValidator = ko.pureComputed(function() {
          var duration_valid = durationofstir_valid();
          var delay_valid = stirdelay_valid();
          var duration = data.evaporationduration();
          var delay = data.stirdelay();
          var stirduration = data.durationofstir();
          if( data.stir() === 1 ) {
            return duration_valid && delay_valid && stirduration <= duration - delay;
          }
          else {
            return true;
          }
        });
        return {
          coolduration_valid: rangeValidator(data.coolduration, 0, 3599),
          durationofstir_valid: durationofstirValidator,
          evaporationduration_valid: rangeValidator(data.evaporationduration, 0, 3599),
          evaporationpressure_valid: rangeValidator(data.evaporationpressure, 0, 30),
          evaporationtemperature_valid: rangeValidator(data.evaporationtemperature, 0, 180),
          finaltemperature_valid: rangeValidator(data.finaltemperature, 0, 180),
          pressure_valid: rangeValidator(data.pressure, 0, 30),
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          stir_valid: ko.pureComputed(function() {
            return stir_valid() && stirdelayValidator() && durationofstirValidator();
          }),
          stirdelay_valid: stirdelayValidator,
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    TRANSFER: {
      name: "TRANSFER",
      className: "transfer-operation",
      templateName: "transfer-template",
      pressure: function(data) {
        return data.pressure;
      },
      validators: function(data) {
        var destination_valid = optionValidator(data.destination, ["reactor", "collection vial", "hplc"]);
        var reagentpos_valid = rangeValidator(data.hplc.reagentpos, 0, 35);
        var deliveryposition_valid = rangeValidator(data.deliveryposition, 0, 1);
        var deliverypressure_valid = rangeValidator(data.hplc.deliverypressure, 0, 30);
        var deliverytime_valid = rangeValidator(data.hplc.deliverytime, 0, 3599);
        var isHplc = ko.pureComputed(function() { return data.destination() === "hplc"; });
        var isReactor = ko.pureComputed(function(){ return data.destination().startsWith("reactor"); });
        var reagentposValidator = ko.pureComputed(function() {
          var posValid = reagentpos_valid();
          if( isHplc() ) {
            return posValid;
          }
          else {
            return true;
          }
        });
        var deliverypositionValidator = ko.pureComputed(function() {
          var posValid = deliveryposition_valid();
          if( isHplc() ) {
            return posValid;
          }
          else {
            return true;
          }
        });
        var deliverypressureValidator = ko.pureComputed(function() {
          var pressureValid = deliverypressure_valid();
          if( isHplc() ) {
            return pressureValid;
          }
          else {
            return true;
          }
        });
        var deliverytimeValidator = ko.pureComputed(function() {
          var timeValid = deliverytime_valid();
          if( isHplc() ) {
            return timeValid;
          }
          else {
            return true;
          }
        });
        var destinationValidator = ko.pureComputed(function() {
          var destination = data.destination();
          var mode = data.mode()
          var destinationValid = destination_valid();
          var sourcereactor = data.sourcereactor();
          var targetreactor = data.targetreactor();
          var reagentValid = reagentposValidator();
          var delPosValid = deliverypositionValidator();
          var delPresValid = deliverypressureValidator();
          var delTimeValid = deliverytimeValidator();
          if( destinationValid ) {
            if( destination === "reactor" ) {

              return (sourcereactor !== targetreactor);
            }
            else if( destination === "hplc" ) {
              return reagentValid && delPosValid && delPresValid && delTimeValid;
            }
            else {
              return true;
            }
          }
          else {
            return false;
          }
        });
        var modeValidator = ko.pureComputed(function(){
          var allOptions = ["trap", "elute", "out"];
          var valid = optionValidator(data.mode, allOptions)();
          if( isHplc() ){
            valid &= data.mode() != "trap";
          }
          else if( isReactor() ){
            valid &= data.mode() != "out";
          }
          return valid;
        });
        var stir_valid = rangeValidator(data.stir, 0, 1);
        var targetreactorValid = rangeValidator(data.targetreactor, 0, 2);
        return {
          deliveryposition_valid: deliverypositionValidator,
          destination_valid: destinationValidator,
          deliverypressure_valid: deliverypressureValidator,
          deliverytime_valid: deliverytimeValidator,
          reagentpos_valid: reagentposValidator,
          mode_valid: modeValidator,
          pressure_valid: rangeValidator(data.pressure, 0, 30),
          sourcereactor_valid: rangeValidator(data.sourcereactor, 0, 2),
          stir_valid: ko.pureComputed(function() {
            var stir = data.stir();
            return stir_valid();
          }),
          targetreactor_valid: ko.pureComputed(function() {
            var targetValid = targetreactorValid();
            return data.destination() !== "reactor" || targetValid;
          }),
          transferduration_valid: rangeValidator(data.transferduration, 0, 3599),
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    REACT: {
      name: "REACT",
      className: "react-operation",
      templateName: "react-template",
      validators: function(data) {
        var stir_valid = rangeValidator(data.stir, 0, 1);
        var stirdelay_valid = rangeValidator(data.stirdelay, 0, 3599);
        var durationofstir_valid = rangeValidator(data.durationofstir, 0, 3599);
        var stirdelayValid = ko.pureComputed(function() {
          var duration = data.reactionduration();
          var stirdelay = data.stirdelay();
          var stirdelayValid = stirdelay_valid();
          if( stir_valid() && data.stir() === 1 ) {
            return stirdelayValid && stirdelay <= duration;
          }
          else {
            return true;
          }
        });
        var stirdurationValid = ko.pureComputed(function() {
          var duration = data.reactionduration();
          var stirdelay = data.stirdelay();
          var stirduration = data.durationofstir();
          var stirdelayValid = stirdelay_valid();
          var stirdurationValid = durationofstir_valid();
          if( stir_valid() && data.stir() === 1 ) {
            return stirdelayValid && stirdurationValid && stirduration <= duration - stirdelay;
          }
          else {
            return true;
          }
        });
        return {
          coolduration_valid: rangeValidator(data.coolduration, 0, 3599),
          coolingdelay_valid: rangeValidator(data.coolingdelay, 0, 3599),
          durationofstir_valid: stirdurationValid,
          finaltemperature_valid: rangeValidator(data.finaltemperature, 30, 180),
          reactionduration_valid: rangeValidator(data.reactionduration, 0, 3599),
          reactiontemperature_valid: rangeValidator(data.reactiontemperature, 30, 180),
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          sealposition_valid: rangeValidator(data.sealposition, 0, 1),
          stir_valid: ko.pureComputed(function() {
            return stir_valid() && stirdelayValid() && stirdurationValid();
          }),
          stirdelay_valid: stirdelayValid,
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    PROMPT: {
      name: "PROMPT",
      className: "prompt-operation",
      templateName: "prompt-template",
      validators: function(data) {
        return {
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    TRAPISOTOPE: {
      name: "TRAP ISOTOPE",
      className: "trap-operation",
      templateName: "trapisotope-template",
      pressure: function(data) {
        return data.trappressure;
      },
      validators: function(data) {
        return {
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          activitysource_valid: optionValidator(data.activitysource, ["external", "internal"]),
          trappressure_valid: function(){

                if(data.activitysource()==='external'){
                    data.trappressure(0);
                }
                return rangeValidator(data.trappressure, 0, 30)
                },
          traptime_valid: rangeValidator(data.traptime, 0, 3599),
          cyclotronflag_valid: rangeValidator(data.cyclotronflag, 0, 1),
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    ELUTEISOTOPE: {
      name: "ELUTE ISOTOPE",
      className: "elute-operation",
      templateName: "eluteisotope-template",
      pressure: function(data) {
        return data.elutepressure;
      },
      validators: function(data) {
        return {
          elutepressure_valid: rangeValidator(data.elutepressure, 0, 30),
          elutetime_valid: rangeValidator(data.elutetime, 0, 3599),
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          reagentpos_valid: reagentValidator(data.reagentpos),
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    MOVE: {
      name: "MOVE REACTOR",
      className: "move-operation",
      templateName: "move-template",
      validators: function(data) {
        return {
          position_valid: optionValidator(data.position, ["access vial"]),
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    },
    EXTERNALADD: {
      name: "EXTERNAL ADD",
      className: "externaladd-operation",
      templateName: "externaladd-template",
      validators: function(data) {
        return {
          reactor_valid: rangeValidator(data.reactor, 0, 2),
          reagentname_valid: ko.pureComputed(function() {
            return data.reagentname() !== "";
          }),
          message_valid: stringLengthValidator(data.message, 1024)
        };
      }
    }
  };
  
  self.deleteList = [];
  
  function deleteComponent(task) {
    self.deleteList.push(task);
  }

  self.name = 'EDIT SEQUENCE';
  self.cassettesVisible = ko.observable(true);
  self.operationsVisible = ko.observable(false);
  self.activeTemplate = ko.observable('cassettes-template');
  self.cassettes = ko.observableArray();
  self.currentCassetteReagent = ko.observable(-1);
  var cassettes = self.cassettes;
  self.currentCassette = ko.observable(0);
  self.dragDropManager = new DragDropManager(self.selectedReagents);
  self.previouslySelectedTaskId = -1; // Track selected Operation across Saves

  self.optionRows = [[
    new StaticTaskOption("ADD", {
      deliveryposition: 0,
      deliverypressure: 3,
      deliverytime: 15,
      durationofstir: 0,
      message: "",
      reactor: -1,
      reagentpos: -1,
      stir: 0,
      stirmode: "during operation",
      stirspeed: 500
    }),
    new StaticTaskOption("EVAPORATE", {
      coolduration: 0,
      durationofstir: 0,
      evaporationduration: 0,
      evaporationpressure: 0,
      evaporationtemperature: 35,
      finaltemperature: 35,
      message: "",
      pressure: 5,
      reactor: -1,
      stir: 1,
      stirdelay: 0,
      stirspeed: 500
    }),
    new StaticTaskOption("TRANSFER", {
      deliveryposition: 0,
      destination: "Select",
      hplc: {
        mode: "manual",
        deliveryposition: 0,
        deliverypressure: 0,
        deliverytime: 15,
        reagentpos: 0
      },
      message: "",
      mode: "",
      pressure: 0,
      sourcereactor: -1,
      stir: 1,
      stirspeedsource: 500,
      stirspeedtarget: 500,
      targetreactor: -1,
      transferduration: 0
    }),
    new StaticTaskOption("REACT", {
      coolduration: 0,
      coolingdelay: 0,
      durationofstir: 0,
      finaltemperature: 35,
      message: "",
      reactionduration: 0,
      reactiontemperature: 35,
      reactor: -1,
      sealposition: 0,
      stir: 1,
      stirdelay: 0,
      stirspeed: 500
    }),
    new StaticTaskOption("PROMPT", {
      message: "",
      waitduration: 0
    }),
    new StaticTaskOption("TRAPISOTOPE", {
      reactor: -1,
      activitysource: "internal",
      trappressure: 0,
      traptime: 0,
      message: "",
      cyclotronflag: 0 // Not currently used
    }),
    new StaticTaskOption("ELUTEISOTOPE", {
      elutepressure: 0,
      elutetime: 0,
      message: "",
      reactor: -1,
      reagentpos: -1
    }),
    new StaticTaskOption("MOVE", {
      message: "",
      position: "access vial",
      reactor: -1
    }),
    new StaticTaskOption("EXTERNALADD", {
      message: "",
      reactor: -1,
      reagentname: ""
    })
  ]];

  var reagentPopupInitialized = false;
  self.visible = ko.computed(function () {
    return self.currentPage() === self.name;
  });
  self.visible.subscribe(function(newValue) {
    if (newValue) {
      getComponents(self.currentSequence().sequenceid).done(function() {
        var operations = self.dragDropManager.taskSequence();
        if( operations.length > 0 ) {
          operations[0].toggleSelected();
        }
      });
      self.currentCassette(0);
      self.activeTemplate("operations-template");
      if( !reagentPopupInitialized ) {
        ko.applyBindings(self.reagentPopup, $("#reagent-popup")[0]);

        reagentPopupInitialized = true;
      }
    }
    else {
      self.previouslySelectedTaskId = -1;
      self.dragDropManager.unselectAll();
      self.dragDropManager.taskSequence([]);
      self.dirty(false);
    }
  });

  self.readOnly = ko.computed(function() {
    var sequence = self.currentSequence();
    if( sequence && sequence.type && sequence.type !== "Logged" ) {
      return false;
    }
    else {
      return true;
    }
  });

  self.sequenceExportIP = ko.computed(function() {
    var sequence = self.currentSequence();
    var sequence_export_ip = "";
    if( sequence ){
      var sequenceid = sequence.sequenceid;
      var elixysip = self.elixysIP(); //currently is ... 'http://192.168.100.101:5000'
      sequence_export_ip = elixysip + "/export_sequence?sequenceid=" + sequenceid;
    }
    return sequence_export_ip;
  });
  
  self.run = function() {
    if (self.dirty()) {
      return;
    }
    var operations = self.dragDropManager.taskSequence();
    for( var i = 0; i < operations.length; i++ ) {
      if( !operations[i].isValid() ) {
        Elixys.showNotificationPopup("Please ensure that there are no validation errors in this sequence's operations.", {
          showCloseButton: true
        });
        return;
      }
    }
    Elixys.viewModels.preRunChecklist.processCassettes(self.cassettes(), operations, operations[0]);
  };
  
  self.runFromSelected = function() {
    if (self.dirty()) {
      return;
    }
    var operations = self.dragDropManager.taskSequence();
    var selected = self.dragDropManager.selectedTask();
    if( selected ) {
      for( var i = 0; i < operations.length; i++ ) {
        if( !operations[i].isValid() ) {
          Elixys.showNotificationPopup("Please ensure that there are no validation errors in this sequence's operations.", {
            showCloseButton: true
          });
          return;
        }
      }
      Elixys.viewModels.preRunChecklist.processCassettes(self.cassettes(), operations, selected);
    }
    else {
      Elixys.showNotificationPopup("There is no operation currently selected.", {
        showCloseButton: true
      });
    }
  };
    
  function grabCassetteData(cassette) {
    return {
      componentid: cassette.componentid,
      componenttype: cassette.componenttype,
      details: Elixys.unmakeObservable(cassette.details),
      note: cassette.note,
      order: cassette.order,
      reagents: Elixys.unmakeObservableArray(cassette.reagents),
      sequenceid: cassette.sequenceid,
      type: cassette.type,
      validationerror: cassette.validationerror
    };
  }

  
  self.save = function() {
    if( !self.dirty() ) {
      return;
    }
    var previouslySelectedTask = self.dragDropManager.selectedTask();
    if (previouslySelectedTask) {
      // Record selected operation to restore after Save
      self.previouslySelectedTaskId = previouslySelectedTask.id;
    }

    var sequence = self.currentSequence();
    var cassettes = self.cassettes();
    var sequenceAndComponents = {
      sequence: sequence,
      components: [
        grabCassetteData(cassettes[0]),
        grabCassetteData(cassettes[1]),
        grabCassetteData(cassettes[2])
      ].concat(
        self.dragDropManager.taskSequence().map(function(task, ix) {
          return {
            componentid: task.id || "none",
            componenttype: task.taskType,
            note: "",
            order: ix + 1,
            sequenceid: sequence.sequenceid,
            type: "component",
            validationerror: "",
            details: Elixys.unmakeObservable(task.data)
          };
        })
      )
    };
    
    Elixys.sequence(function(fail) {
      return [
        function() {
          Elixys.showNotificationPopup("Saving...");
          return Elixys.doApiCall("/save_sequence_and_components", {
            "save_sequence_and_components": sequenceAndComponents
          });
        }, function(payload) {
          var result = payload["save_sequence_and_components"];
          if( result.error ) {
            return fail(result.error);
          }
          else {
            return result;
          }
        }, function(result) {
          return getComponents(sequence.sequenceid);
        }, function() {
          self.dirty(false);
        }
      ];
    }).fail(function(error) {
      if( typeof error === "string" ) {
        console.log("Error saving: " + error);
      }
      else {
        console.log(error);
      }
      Elixys.showNotificationPopup("There was an error while saving.", {
        showCloseButton: true
      });
    }).done(function() {
      Elixys.hideNotificationPopup();
    });
  };
  
  function updateCassettes(cassettes, components) {
    var result = [];
    cassettes.forEach(function(cassette, ix) {
      for( var i = 0; i < components.length; i++ ) {
        if( components[i].componenttype === "CASSETTE" && components[i].details.reactor === ix ) {
          for( var j = 0; j < 12; j++ ) {
            components[i].reagents[j].name = cassette.reagents[j].name();
          }
          result.push(components[i]);
          break;
        }
      }
    });
    return result;
  }
  
  self.saveAs = function() {
    Elixys.showNewSequencePopup({
      titleText: "Copy Sequence",
      buttonText: "Copy",
      create: function(name, description) {
        return Elixys.sequence(function(fail) {
          return [
            function() {
              return Elixys.doApiCall("/copy_sequence_and_components", {
                copy_sequence_and_components: {
                  sequenceid: self.currentSequence().sequenceid,
                  name: name,
                  comment: description
                }
              });
            }, function(payload) {
              var result = payload["copy_sequence_and_components"];
              if( result.error ) {
                fail(result.error);
              }
              else {
                self.currentSequence(result.sequence);
                self.currentPage("EDIT SEQUENCE");
                return result;
              }
            }, function(result) {
              // Update the copied sequence
              var sequence = result.sequence;
              var cassettes = updateCassettes(self.cassettes(), result.components);
              return Elixys.doApiCall("/save_sequence_and_components", {
                save_sequence_and_components: {
                  sequence: sequence,
                  components: [
                    cassettes[0],
                    cassettes[1],
                    cassettes[2]
                  ].concat(
                    self.dragDropManager.taskSequence().map(function(task, ix) {
                      return {
                        // We need to regenerate the components because between
                        // adding, deleting, and moving we have no idea which of the
                        // original components correspond to the copied versions
                        componentid: "none",
                        componenttype: task.taskType,
                        note: "",
                        order: ix + 1,
                        sequenceid: sequence.sequenceid,
                        type: "component",
                        validationerror: "",
                        details: Elixys.unmakeObservable(task.data)
                      };
                    })
                  )
                }
              });
            }, function(result) {
              console.log("Updated copy");
              console.log(result);
              self.dirty(false);
              return result;
            },
            function(result) {
          self.currentComponents(result['save_sequence_and_components']['components']);
          return self.populateComponents(result['save_sequence_and_components']['components']);
        },
        function(cassettes, components) {
          self.cassettes(cassettes);
          self.dragDropManager.taskSequence(components);
          //populate selected reagents list
          //clear first
          for(var i = 0; i<=35; i++){self.selectedReagents()[i]={"task":undefined, "selected":false};}

          //populate order of operations
          updateOperationOrders();

          //look for components with reagentpos values
          for(var i in self.dragDropManager.taskSequence()){

            if(self.dragDropManager.taskSequence()[i].data.reagentpos!==undefined){

                var pos = parseInt(self.dragDropManager.taskSequence()[i].data.reagentpos());
                if(pos >=0){
                self.selectedReagents()[pos]["task"] = self.dragDropManager.taskSequence()[i];
                self.selectedReagents()[pos]["selected"] = true;
                }


            }
          }


          self.deleteList = [];
          self.dirty(false);
          self.dragDropManager.selectedOptionsDrag.dragActions.arrowsRequired();
          // Keep the same Operation selected, if possible.
          self.dragDropManager.toggleSelectedOptionById(self.previouslySelectedTaskId);
        }
          ];
        })
      }
    });
  };
  
  self.revert = function() {
    if( !self.dirty() ) {
      return;
    }

    Elixys.showNotificationPopup("Are you sure you wish to revert your changes since the last save?", {
      confirmCallback: function() {
        getComponents(self.currentSequence().sequenceid);
      },
      cancelCallback: function() {
        // Dismisses the dialog.
      }
    });
  };



  function Cassette(cassetteData) {
    'use strict';

    var self = this;
    self.componentid = cassetteData.componentid,
    self.order = cassetteData.order,
    self.sequenceid = cassetteData.sequenceid,
    self.type = cassetteData.type || 'component',
    self.validationerror = cassetteData.validationerror || 0,
    self.componenttype = cassetteData.componenttype || 'CASSETTE',
    self.note = cassetteData.note || '',
    self.reagents = Elixys.makeObservableArray(cassetteData.reagents, setDirty);
    self.details = Elixys.makeObservable(cassetteData.details, setDirty);
  }

  function Reagent(reagentData) {
    'use strict';

    var self = this;
    self.reagentid = reagentData.reagentId;
    self.position = reagentData.position;
    self.name = ko.observable(reagentData.name);
    self.description = reagentData.description || '';
  }

  function Arrow(){
    var self = this;
    self.visible = ko.observable(false);
    self.markup;
  };

  function TaskPane(ref){
    var self = this;
    self.scrollWidth = function(){
      var total = (7>ref.taskSequence().length) ? 7*100 : ref.taskSequence().length*100;
      return total + 'px';
    };
    self.scrollHeight = function(){
      return "120px";
    };
    self.rightArrow = new Arrow();
    self.leftArrow = new Arrow();
  };


  self.selectCassetteReagent = function(reagent_num){
    self.currentCassetteReagent(reagent_num);
    self.currentCassetteReagent.valueHasMutated();
  }

  self.reagentPopup = new function() {
    'use strict';
    
    var popup = this;
    
    // inherits Common.
    Common.apply(popup, arguments);
    
    popup.visible = ko.observable(false);
    popup.currentCassette = ko.observable(0);
    popup.currentCassetteReagent = self.currentCassetteReagent;
    popup.selectedReagents = self.selectedReagents;
    popup.cassettes = self.cassettes;
    popup.target = ko.observable();
    popup.current_task = ko.observable();

    popup.close = function() {
      popup.visible(false);
    };
    
    popup.show = function(target,current_task) {
      popup.selectedReagents.valueHasMutated();
      popup.target(target);
      popup.current_task(current_task);

      var reagentpos = popup.current_task().data.reagentpos();

      var cassette_num = Math.max(parseInt(reagentpos / 12), 0);
      var pos = reagentpos - (cassette_num*12);
      self.currentCassetteReagent(pos);
      self.currentCassetteReagent.valueHasMutated();
      popup.currentCassette(cassette_num);
      popup.visible(true);

    };




    popup.select = function(pos) {
      var currentCassette = popup.currentCassette();
      var abs_pos = pos + (currentCassette * 12);
      self.currentCassetteReagent(pos);
      self.currentCassetteReagent.valueHasMutated();

      var text = popup.cassettes()[currentCassette].reagents[pos].name().trimRight();

       //user not allowed to select reagent without name
      if(text.length === 0){
        return ;
      }


      if(self.selectedReagents()[abs_pos]["selected"]){

            if(self.selectedReagents()[abs_pos]["task"]!== popup.current_task()){
            return;
            }
            else{
            self.selectedReagents()[abs_pos]["task"]=undefined;
            self.selectedReagents()[abs_pos]["selected"]=false;
            abs_pos = -1; //clear reagent selection

            }
        }

      else{
        self.selectedReagents()[abs_pos]={"task": popup.current_task(), "selected": true};

      for(var key in self.selectedReagents()){
         if(key!=abs_pos){

           if(self.selectedReagents()[key]["task"] === popup.current_task()){
               self.selectedReagents()[key]["task"] = undefined; //clear previous reagent from current task
               self.selectedReagents()[key]["selected"]=false;
                }

            }
        }
       }

      //ok
      self.selectedReagents.valueHasMutated();
      popup.target()(abs_pos);
      //popup.visible(true);
      self.dirty(true);
    };
  };

  function withReagent(target,current_task) {
    var valid = ko.pureComputed(function() {
      return target() !== -1;
    });
    var cassette = ko.pureComputed(function() {
      return Math.max(parseInt(target() / 12) + 1, 1);
    });
    var reagent = ko.pureComputed(function() {
      return Math.max((target() % 12) + 1, 1);
    });
    return {
      name: ko.pureComputed(function() {
        if( !valid() ) {
          return "REAGENT";
        }
        else {
          return cassettes()[cassette() - 1].reagents[reagent() - 1].name();
        }
      }),
      cassette: cassette,
      reagent: reagent,
      target: target,
      valid: valid,
      showReagentPopup: function() {
        self.reagentPopup.show(target,current_task);
      }
    };
  }

  self.withReagent = withReagent;
  function displayReagent(target) {
    return ko.pureComputed(function() {
      var pos = target();
      if( pos >= 0 && pos <= 35 ) {
        return cassettes()[parseInt(pos / 12)].reagents[pos % 12].name();
      }
      else {
        return "";
      }
    });
  }

  function DragDropManager(selectedReagents){
    var self = this;
    self.restoreLocation = -1;
    //The task currently being dragged
    self.draggedTask = ko.observable(null);
    //The current action to be taken when drag ends
    self.dropAction = ko.observableArray(["restore"]);
    self.dropElement = ko.observableArray([null]);
    self.deleteArea = new DeleteArea(self);
    self.addTaskArea = new AddTaskArea(self);

    self.selectedReagents = selectedReagents;

    self.selectedOptionsDrag = new SelectedOptionsDrag(self);
    self.staticOptionsDrag = new StaticOptionsDrag(self);

    self.taskSequence = ko.observableArray([]);
    self.taskSequence.subscribe(setDirty);
    self.selectedTask = ko.pureComputed(function(){
      var task = Elixys.reduce(self.taskSequence(), null, function(accume, current, index){
        return (current.selected() ? current : accume);
      });
      return task;
    });
    self.taskPane = new TaskPane(self);
    self.unselectAll = function(){
      Elixys.forEach(self.taskSequence(), function(current, index){
        if(current.selected()){
          current.toggleSelectedOption();
        }
      });
    };
    self.toggleSelectedOption = function(task){
      var currently = task != null ? task.selected() : false;
      self.unselectAll();
      if(!currently && task != null){
        task.toggleSelectedOption();
      }
    };
    self.toggleSelectedOptionById = function(id){
      var task = Elixys.reduce(self.taskSequence(), null, function(accume, current, index){
        return (current.id == id ? current : accume);
      });
      self.toggleSelectedOption(task);
    };
    self.selectedTaskExists = function(){
      return (self.selectedTask()!=null);
    };
    self.deleteTask = function(){
      var task = self.selectedTask();

      //remove task for selected reagents dictionary
      if(task!=null){

        if(task.data.reagentpos!==undefined){

                var pos = parseInt(task.data.reagentpos());
                if(pos >=0){
                self.selectedReagents()[pos]["task"] = undefined;
                self.selectedReagents()[pos]["selected"] = false;
                }
        }
        self.selectedOptionsDrag.dragActions.taskActions.DeleteTask(task);

      }
    };
  }


  function Task(name, id, origin, idClass, classModifiers, templateName, taskType, data, pressureSelector, validatorsFn) {
    'use strict';

    var self = this;
    self.dataWithValidators = {};
    self.name = name;
    self.id = id;
    self.origin = origin;
    self.idClass = idClass;
    self.classModifiers = classModifiers;
    self.templateName = templateName;
    self.taskType = taskType;
    self.data = data;

    if( self.name == 'TRANSFER' ){
      self.availableModes = function(){
        var allModes = [];
        if( self.data.destination() !== "hplc" ){
          allModes.push( {'label': 'Trap', 'value': 'trap', 'id': 'transfer-mode-trap'} );
        }
        allModes.push( {'label':'Elute', 'value': 'elute', 'id': 'transfer-mode-elute'} );

        if( self.data.destination() === "hplc" || self.data.destination() === "collection vial"){
          allModes.push( {'label': 'Out', 'value': 'out', 'id': 'transfer-mode-out'} );
        }

        return allModes;
     }
     self.isStirable = ko.pureComputed(function(){
       return self.data.destination() !== "hplc";
     });
     if( typeof self.data.destination === "function"){ // When the StaticTask is generated; data.destination is
       self.data.destination.subscribe(function(newVal){
        if( newVal == 'hplc'){
          self.data.stir(0);
        }
       });
       if( validatorsFn ){
          if( typeof self.data.hplc.starttransferimmediatly == "undefined" ){
            self.data.hplc.starttransferimmediatly = ko.observable(false);
            self.data.hplc.starttransferimmediatly.subscribe(setDirty);
          }
          self.data.hplc.mode.subscribe(function(newVal){
            self.data.hplc.starttransferimmediatly(newVal == "automatic");
          });
       }
     }
    }
    else if( self.name == "PROMPT" ){

      if( validatorsFn ){
        if( typeof self.data.waitduration == "undefined" ){
          self.data.waitduration = ko.observable(0);
          self.data.waitduration.subscribe( setDirty );// This should be happening in the controller, not the model
        }
      }

      self.waitForUserToContinue = ko.observable( typeof self.data.waitduration == "function" && self.data.waitduration() == 0 );
      self.waitForUserToContinue.subscribe(function(val){
        if( val ){
          self.data.waitduration(0);
        }
        else{
          self.data.waitduration(1);
        }
      });
    }
    else if( self.name == "EVAPORATE" ){

      if( typeof self.data.evaporationduration == "function"){
        self.data.evaporationduration.subscribe(function(val){
          self.data.durationofstir(val-self.data.stirdelay());
        });
      }
    }
    else if( self.name == "REACT" ){
      if( typeof self.data.reactionduration == "function"){
        self.data.reactionduration.subscribe(function(val){
          self.data.durationofstir(val-self.data.stirdelay());
        });
      }
    }

    if( typeof pressureSelector === "function" ) {
      self.pressure = pressureSelector(data);
    }
    else {
      self.pressure = ko.pureComputed(function() { return 0; });
    }
    self.pressureSelector = pressureSelector;

    self.selected = ko.observable(false);
    self.deleteable = ko.observable(false);
    self.cloneable = ko.observable(false);
    self.scrolling = ko.observable(false);
    self.hidden = ko.observable(false);
    self.finished = ko.observable(false);

    self.toggleSelected = function(){
      self.selected(!self.selected());
    };
    self.toggleDeleteable = function(){
      self.deleteable(!self.deleteable());
    };
    self.toggleDeletable = function(){
      self.deleteable(!self.deleteable());
    };
    self.toggleCloneable = function(){
      self.cloneable(!self.cloneable());
    };
    self.toggleScrolling = function(){
      self.scrolling(!self.scrolling());
    };
    self.toggleHidden = function(){
      self.hidden(!self.hidden());
    };
    self.toggleFinished = function() {
      self.finished(!self.finished());
    }

    self.className = ko.computed(function(){
      var modifiers = "";
      if( self.finished() ) {
        modifiers = " finished";
      }
      else if( self.selected() ) {
        modifiers = " selected";
      }
      return "task "+ self.classModifiers + modifiers;
    });

    self.imageClass = ko.computed(function(){
      var idClass;
      if( self.finished() ) {
        idClass = self.idClass + "-finished";
      }
      else if( self.selected() ) {
        idClass = self.idClass + "-selected";
      }
      else if( self.origin === "selectedTasks" ) {
        idClass = self.idClass + "-dropped";
      }
      else {
        idClass = self.idClass;
      }
      return idClass + " image-container";
    });

    self.toggleSelectedOption = function(){
      self.toggleSelected();
      self.deleteable(self.selected());
      self.mouseDown();
    };

    self.mouseDown = function(){
      self.isDraggable = false;
      if( self.selected() ){
        setTimeout( function(){
          self.isDraggable = self.selected();
        }, 150);
      }
    }

    self.mouseUp = function(){
      self.isDraggable = false;
    }

    self.visibility = function(){
      var result = (self.hidden() ? "hidden" : "visible");
      return result;
    };

    self.task = function(){
      return self;
    };

    self.order = ko.observable(0); //todo-josh: make dynamic
    self.reagent = "";
    if( data ) {

      if( typeof data.reagentname === "function" ) {
        self.reagent = data.reagentname;
      }
      else if( data.hplc && typeof data.hplc.reagent === "function" ) {
        self.reagent = displayReagent(data.hplc.reagent);
      }
      else if( typeof data.reagentpos === "function" ) {
        self.reagent = displayReagent(data.reagentpos);

        //add task and reagentpos to global dict
      }
    }



    if( validatorsFn ) {
      var validators = validatorsFn(data);
      self.isValid = ko.pureComputed(function() {
        for( var key in validators ) {
          if( !validators[key]() ) {
            return false;
          }
        }
        return true;
      });

      for( var key in data ) {
        self.dataWithValidators[key] = data[key];
      }
      for( var key in validators ) {
        self.dataWithValidators[key] = validators[key];
      }
    }
    else {
      self.isValid = ko.pureComputed(function() { return true; });
      self.dataWithValidators = self.data;
    }

    // For tasks with reagent components
    self.withReagent = withReagent;

  }

  var TaskOrigins = {
    options: "options",
    selectedTasks: "selectedTasks",
    placeHolderTask: "placeholder"
  };

  // This is called for the default Task types.
  function StaticTaskOption(taskType, data){
    var fields = componentTypeMap[taskType];
    if( fields !== undefined ) {
      var task = new Task(fields.name, 0, "options", fields.className, "box drag", fields.templateName, taskType, data, fields.pressure);
      task.toggleCloneable();
      return task;
    }
  };

  // This is called when an Item is Dragged onto the timeline.
  function SelectedTaskOption(task){
    var fields = componentTypeMap[task.taskType];
    if( fields !== undefined ) {
      return new Task(task.name,
        task.id,
        "selectedTasks",
        task.idClass,
        "box dropped",
        task.templateName,
        task.taskType,
        Elixys.makeObservable(task.data, setDirty),
        task.pressureSelector,
        fields.validators);
    }
  };

  function PlaceHolderTask(){
    var task = new Task("", 0, "placeholder", "", "box dropped placeholder");
    task.toggleHidden();
    return task;
  };

  /*
    DeleteArea and AddTaskArea are used by the ko.bindingHandlers.droppable custom binding
    their function is to update what action needs to be executed when drag ends.
  */
  function DropAreaActions(ref, action){
      var self = this;
      self.droppedIn = false;
      self.action = action;
      self.initialize = function(element){
          ref.dropAction.remove(self.action);
          ref.dropElement.remove(element);
          self.droppedIn = false;
      };
      self.start = function(element){
          ref.dropAction.push(self.action);
          ref.dropElement.push(element);
      };
      self.end = function(element){
          if(!self.droppedIn) {
            ref.dropAction.remove(self.action);
            ref.dropElement.remove(element);
          }
      };
      self.drop = function(element){
          self.droppedIn = true;
      };
  };
  function DeleteArea(ref){
      var self = this;
      self.dropAreaActions = new DropAreaActions(ref, "delete");
      self.className = ko.observable("");
      self.initialize = function(element){
          self.dropAreaActions.initialize(element);
      };
      self.start = function(element){
          if(ref.draggedTask().deleteable()){
              self.className("hilight");
          }
          self.dropAreaActions.start(element);
      };
      self.end = function(element){
          self.className("");
          self.dropAreaActions.end(element);
      };
      self.drop = function(element){
          self.dropAreaActions.drop(element);
      };
  };
  function AddTaskArea(ref){
      var self = this;
      self.dropAreaActions = new DropAreaActions(ref, "add");
      self.initialize = function(element){
          self.dropAreaActions.initialize(element);
      };
      self.start = function(element){
          self.dropAreaActions.start(element);
      };
      self.end = function(element){
          var draggedTask = ref.draggedTask();
          self.dropAreaActions.end(element);
      };
      self.drop = function(element){
          self.dropAreaActions.drop(element);
      };
  };
  function ListOperations(){
      var self = this;
      self.InjectIntoList = function(content, val, injectPoint){
          var updated = [];
          if(injectPoint>=content.length){
              content.push(val);
              updated = content;
          }else{
              updated = Elixys.reduce(content, [], function(accume, current, index){
                  if(index==injectPoint) accume.push(val);
                  accume.push(current);
                  return accume;
              });
          }
          return updated;
      };
      self.OverWriteValue = function(lst, value, insertPoint){
          lst[insertPoint] = value;
          return lst;
      };
      self.FindIndex = function(lst, evaluator){
          var index = Elixys.reduce(lst, -1, function(accume, current, index){
              return (evaluator(current) ? index : accume);
          });
          return index;
      };
  };
  function TaskActions(ref){
      var self = this;
      self.listOperations = new ListOperations();
      self.GetNewSelectedTaskOption = function(task){
          var newtask = new SelectedTaskOption(task);
          if(task.origin === "selectedTasks") {
              newtask.toggleSelectedOption();
          }
          return newtask;
      };
      self.FindPlaceHolder = function(){
          var lst = ref.taskSequence();
          return self.listOperations.FindIndex(lst, function(n){return (n.origin === "placeholder");});
      };
      self.RemoveTask = function(task){
          ref.taskSequence.remove(task);
      };
      self.RemovePlaceHolder = function(){
          var i = self.FindPlaceHolder();
          var contents = ref.taskSequence();
          if(i!=-1){
              self.RemoveTask(contents[i]);
          }
      };
      self.DeleteTask = function(task){
      //remove task from selected reagents
        if(task.data.reagentpos!==undefined){

                var pos = parseInt(task.data.reagentpos());
                if(pos >=0){
                ref.selectedReagents()[pos]["task"] = undefined;
                ref.selectedReagents()[pos]["selected"] = false;
                }
            }

          deleteComponent(task);
          self.RemoveTask(task);
          self.RemovePlaceHolder();

          //removed operation so update orders
          updateOperationOrders();
      };
      self.RestoreTask = function(task){
          self.MoveTaskTo(task, ref.restoreLocation);
          //restored operation so update orders
          updateOperationOrders();
      };
      self.AddTask = function(task){
          var contents = ref.taskSequence();
          var i = self.FindPlaceHolder();
          var newtask = self.GetNewSelectedTaskOption(task);
          ref.unselectAll();
          newtask.toggleSelected();
          if( i === -1 ) {
            ref.taskSequence.push(newtask);
          }
          else {
            ref.taskSequence(self.listOperations.OverWriteValue(contents, newtask, i));
          }
            //added new operation so update orders
          updateOperationOrders();
      };
      self.InjectTask = function(task, index){
          ref.taskSequence(self.listOperations.InjectIntoList(ref.taskSequence(), task, index));
      };
      self.MoveTaskTo = function(task, index) {
        var oldIndex = ref.taskSequence.indexOf(task);
        var newIndex = index;
        if(oldIndex !== -1 && newIndex !== oldIndex && newIndex != -1) {
          var array = ref.taskSequence();
          array.splice(oldIndex, 1);
          array.splice(newIndex, 0, task);
          ref.taskSequence(array);
        }
        //moved operation so update orders
          updateOperationOrders();
      }
  };
  function DragActions(ref){
      var self = this;
      self.taskActions = new TaskActions(ref);
      self.scrollIntervalFunction;

      self.DragEnd = function(dd){
          $( dd.proxy ).remove();
          self.stopScrolling();
          var l = ref.dropAction().length;
          var action = ref.dropAction()[l-1];
          var task = ref.draggedTask();
          if( task !== null ) {
            if( task.origin === "selectedTasks" ) {
              if( action === "delete" ) {
                self.taskActions.DeleteTask(task);
              }
              else if( action === "restore") {
                self.taskActions.RestoreTask(task);
              }
            }
            else if( action === "add" ) {
              self.taskActions.AddTask(task, self.taskActions.FindPlaceHolder());
            }
          }
          ref.draggedTask(null);
      };
      self.ReplaceWithPlaceHolder = function(task){
          var content = Elixys.map(ref.taskSequence(), function(current, index){
              return ((current==task) ? new PlaceHolderTask() : current);
          });
          ref.restoreLocation = self.taskActions.FindPlaceHolder();
          ref.taskSequence(content);
      };
      self.slideTimeline = function( xDirection ){
        var dropContainer = document.getElementById("timelineContainer");
        if( !self.scrollIntervalFunction ){
          self.scrollIntervalFunction = setInterval(function(){
            dropContainer.scrollLeft += xDirection;
          }, 100);
        }
      };
      self.stopScrolling = function(){
        clearInterval(self.scrollIntervalFunction);
        self.scrollIntervalFunction = null;
      };
      self.slideTimelineIfNecessary = function(dd){
        var xCoord = dd.startX + dd.deltaX;
        var rightArrow = ref.taskPane.rightArrow;
        var leftArrow = ref.taskPane.leftArrow;
        var rightArrowX = rightArrow.markup.getBoundingClientRect().left;
        if( xCoord > rightArrowX && rightArrowX > 0){
          self.slideTimeline( 20 );// Slide Left
        }
        else if( xCoord < leftArrow.markup.getBoundingClientRect().right && leftArrow.visible ){
          self.slideTimeline( -20 );// Slide Right
        }
        else{
          self.stopScrolling();
        }
      }
      self.GetScrollElement = function(){
          var dropElements = ref.dropElement();
          return $(dropElements[dropElements.length-1]);
      };
      self.FindInjectionPoint = function(element, dd){
          var w = $(element).outerWidth();
          var scrollElement = $("div.drop-container");
          /*
            relativePosition is how far horizontally the current drag element is from the left edge of the scroll area
          */
          var relativePosition = dd.offsetX - scrollElement.offset().left + scrollElement.scrollLeft();
          /*
            position is the insertion point for the new element, the insertion point is calculated as follows:

            the insertion point is the number of whole widths the current drag element is from the left edge of the scroll area
            plus one if the remainder of the division is greater than one half the element width
          */
          return parseInt(relativePosition/w)+(((relativePosition%w)>(w/2)) ? 1:0);
      };
      self.AddPlaceHolder = function(element, dd){
          var position = self.FindInjectionPoint(element, dd);
          var list = ref.taskSequence;
          var l = list().length;
          var emptyTask = Elixys.reduce(list(), null, function(accume, current, index){
              return ((current.origin==TaskOrigins.placeHolderTask) ? current : accume);
          });
          if(emptyTask==null){
              emptyTask = new PlaceHolderTask();
          }else{
              //remove the emptyTask already in the list and update the content array and length
              list.remove(emptyTask);
          }
          self.taskActions.InjectTask(emptyTask, position);
      };
      self.arrowsRequired = function(){
          //var scrollElement = self.GetScrollElement();
          var scrollElement = $(".drop-container");
          var left = false;
          var right = false;
          if(scrollElement!=null) {
              var l = scrollElement.outerWidth();
              var innerL = scrollElement.children().outerWidth();
              var offset = scrollElement.scrollLeft();
              right = innerL>l+offset;
              left = scrollElement.scrollLeft()>0;
          };
          ref.taskPane.leftArrow.visible(left);
          ref.taskPane.rightArrow.visible(right);
      };
      self.UpdatePlaceHolder = function(element, dd){
          var da = ref.dropAction();
          var action = da[da.length-1];
          if(action=="add"){
              self.AddPlaceHolder(element, dd);
          }else if(action=="restore"){
              self.taskActions.RemovePlaceHolder();
          }
          self.arrowsRequired();
      };
  };
  function StaticOptionsDrag(ref){
      var self = this;
      self.dragActions = new DragActions(ref);
      self.updateDraggedTask = function(task){
          ref.draggedTask(task);
      };
      self.start = function(element, task){
          self.updateDraggedTask(task);
          return $(element)
              .clone()
              .css({
                  position: "absolute"
              })
              .addClass("dragging")
              .appendTo("body");
      };
      self.drag = function(element, task, dd){
          $( dd.proxy ).css({
              top: dd.offsetY,
              left: dd.offsetX
          });
          self.dragActions.UpdatePlaceHolder(element, dd);
          self.dragActions.slideTimelineIfNecessary( dd );
      };
      self.end = function(element, task, dd){
          self.dragActions.DragEnd(dd);
          self.dragActions.arrowsRequired();
      };

  };
  function SelectedOptionsDrag(ref){
      var self = this;
      self.dragActions = new DragActions(ref);
      self.initialScroll = 0;
      self.initialOffset = 0;
      self.scrollElement = null;
      self.updateDraggedTask = function(task){
          ref.draggedTask(task);
      };

      self.start = function(element, task, dd){
          var result = false;
          self.updateDraggedTask(task);
          //grab a reference to the container and current scroll offset value real fast
          self.scrollElement = $(element).parent().parent();
          self.initialScroll = self.scrollElement.scrollLeft();
          if(task == ref.selectedTask() && task.isDraggable ){
              result = $(element)
                  .clone()
                  .css({
                      position: "absolute"
                  })
                  .addClass("dragging")
                  .appendTo("body");
              task.hidden(true);
          }else{
              //if not draggable should be scrolling
              task.toggleScrolling();
              //make sure the task being used to manipulate scrolling is not deleteable
              if(task.deleteable()) task.toggleDeleteable();
              self.initialOffset = dd.offsetX;
              result = $(element);
          }
          return result;
      };
      self.drag = function(element, task, dd){

          if(task.scrolling()){
              self.scrollElement.scrollLeft(self.initialScroll+self.initialOffset-dd.offsetX);
              self.dragActions.arrowsRequired();
          }else{
              // Update position in list

              var position = self.dragActions.FindInjectionPoint(dd.proxy, dd);
              self.dragActions.slideTimelineIfNecessary( dd );
              self.dragActions.taskActions.MoveTaskTo(task, position);
              $( dd.proxy ).css({
                  top: dd.offsetY,
                  left: dd.offsetX
              });
          }
      };
      self.end = function(element, task, dd){
          task.isDraggable = false;
          if(task.scrolling()) {
            task.toggleScrolling();
          }
          else {
            self.dragActions.DragEnd(dd);
            task.hidden(false);
          }
          self.dragActions.arrowsRequired();

          if( !task.selected() ){
            var tasks = ref.taskSequence();
            for( var i = 0; i < tasks.length; i++){ // ensure all other tasks have been deselected.
              var loopingTask = tasks[i];
              loopingTask.selected( task === loopingTask );
            }
          }
      };
  };
  self.currentPage.subscribe(function(newVal){
    self.recentlyAttached(false);
  });
  self.recentlyAttached = ko.observable(false);
  self.hasInstructions = ko.pureComputed(function(){
    return self.currentSequence() && ( self.currentSequence().hasinstructions || self.recentlyAttached() );
  });



  self.getInstructions = function(){
    var sequenceid = self.currentSequence().sequenceid;
    Elixys.viewModels.elixysManual.view( "/instructions?sequenceid=" + sequenceid );
  }

  self.postRender = function() {
    //ToDo: make the drag drop manager allow user drag only after pressing for 1 sec or more
    var touch_element = window.document.getElementById("drag-drop-menu");
    self.dragDropManager.taskPane.rightArrow.markup =  document.getElementById( 'rightArrowPointer' );
    self.dragDropManager.taskPane.leftArrow.markup = document.getElementById( 'leftArrowPointer' );

    touch_element.oncontextmenu = function(event){
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
  }


  self.openAttachmentDialog = function(){
    Elixys.showImportSequencePopup({
      titleText: "Attach Instructions",
      importFile: function(importCtrl){
        var attachment = importCtrl.file();
        if( attachment ){
          var reader = new FileReader();
          reader.onload = (function(fileName) {
              return function(evt){
                var sequenceid = self.currentSequence().sequenceid;
                var binaryData = evt.target.result;
                Elixys.doApiCall("/add_attachment", {"add_attachment":{"sequenceid":sequenceid, "attachment": btoa(binaryData), "filename": fileName}}, function(success){

                  self.currentSequence().hasinstructions = true;
                  self.recentlyAttached(true);
                  importCtrl.notBusy(true);
                  importCtrl.buttonText("Import");
                  importCtrl.close();
                },
                function(err){
                  console.log( err );
                  importCtrl.notBusy(true);
                  importCtrl.buttonText("Import");
                  Elixys.showNotificationPopup("There was an error importing the attachment.", {
                    showCloseButton: true
                  });
                });
            }
          })(attachment.name);
        }
        reader.readAsBinaryString(attachment);
      },
      validateImport: function(importCtrl){
        if( importCtrl && importCtrl.file() && importCtrl.file().name ){
          importCtrl.name( importCtrl.file().name );
          importCtrl.notBusy(true);
          importCtrl.import_file_valid(true);
          importCtrl.import_file_valid.valueHasMutated();
        }
      }
    });
  }
}

/*
 * Running view model.
 */
function Running() {
  'use strict';
  
  var self = this;
  
  //inherits Common.
  Common.apply(self, arguments);
  
  self.name = "RUNNING";
  self.videoLeft = undefined;
  self.videoRight = undefined;
  self.isRunning = ko.observable(false);
  self.sequence = ko.observable();
  self.logged_sequence_id = ko.observable(); //this is the sequence id that is made by the server. It should copied not the original sequence
  self.elapsedTime = ko.observable(0);
  self.operations = ko.observableArray();
  self.currentOperationIndex = ko.observable(-1);
  self.timerOverridden = ko.observable(false); // The timer is currently being overridden
  self.timerOverrideReady = ko.observable(false); //only allow timer override when main operation duration starts
  self.continueRequired = ko.observable(false); //only allow continue button for external add when ready
  self.continueRequiredSet = ko.observable(false);
  self.timerWasOverridden = ko.observable(false); // The timer has, at some point, been overridden
  self.changingPressure = ko.observable(false);
  self.errorAlertSet = ko.observable(false); //User error alert window open, user has not pressed button yet
  self.hasTargetReactor = ko.observable(false);
  self.runningOperation = ko.observable(new RunningOperation());

  self.scrollWidth = ko.computed(function() {
    return self.operations().length * 100;
  });
  self.scrollLeft = ko.observable(0);
  
  self.leftArrowVisible = ko.computed(function() {
    return self.scrollLeft() > 0;
  });
  self.rightArrowVisible = ko.computed(function() {
    var containerWidth = $("#running-pane div.drop-container").width();
    // In case the container isn't visible yet
    if( containerWidth === 0 ) {
      containerWidth = 924;
    }
    var scrollWidth = self.scrollWidth();
    return scrollWidth > containerWidth && self.scrollLeft() + containerWidth < scrollWidth;
  });
  self.timeRemaining = ko.pureComputed(function(){
    return self.operationTimerSeconds() > 0;
  });

  //alternative to ko js video ip method
  self.startVideo = function(taskType, reactor, targetReactor){

      if(taskType===undefined){return ;}
      //stop video feeds from prev operation
      if(self.videoLeft !== null && self.videoLeft !== undefined){self.videoLeft.src = "";}
      if(self.videoRight !== null && self.videoRight !== undefined){self.videoRight.src = "";}

      //Get video elements on template page
      self.videoLeft = document.getElementById(taskType+"video-left");
      self.videoRight = document.getElementById(taskType+"video-right");

      //update video element source ip address to point to correct cameras
      if(self.videoLeft !== null){
        if(reactor >= 0){
        self.videoLeft.src = self.videoUrl[reactor];
        }
      }
      if(self.videoRight !== null){
        if(targetReactor >= 0){
        self.videoRight.src = self.videoUrl[targetReactor];
        }
      }

  }
  
  self.dragOperations = new (function() {
    var self1 = this;
    self1.scrollStart = 0;
    self1.offsetStart = 0;
    self1.start = function(element, task, dd) {
      self1.scrollStart = self.scrollLeft();
      self1.offsetStart = dd.offsetX;
    };
    self1.drag = function(element, task, dd) {
      var containerWidth = $("#running-pane div.drop-container").width();
      var scrollLeft = Math.min(Math.max(0, self1.scrollStart + self1.offsetStart - dd.offsetX), self.scrollWidth() - containerWidth);
      self.scrollLeft(scrollLeft);
      $("#running-pane div.drop-container").scrollLeft(scrollLeft);
    };
    self1.end = function(element, task, dd) {
    };
  })();
  
  self.getTemplateFromOperationType = (function() {
    var typeTemplateMap = {
      ADD: "running-add-template",
      EVAPORATE: "running-evaporate-template",
      TRANSFER: "running-transfer-template",
      REACT: "running-react-template",
      PROMPT: "running-prompt-template",
      TRAPISOTOPE: "running-trapisotope-template",
      ELUTEISOTOPE: "running-eluteisotope-template",
      MOVE: "running-move-template",
      EXTERNALADD: "running-externaladd-template"
    };
    
    return function(key) {
      return typeTemplateMap[key] || "blank-template";
    };
  })();
  
  self.showParameters = (function() {
    var parameterMap = {
      ADD: {
        template: "add-parameters-popup-template",
        extraClass: "add-parameter"
      },
      EVAPORATE: {
        template: "evaporate-parameters-popup-template",
        extraClass: "evaporate-parameter"
      },
      TRANSFER: {
        template: "transfer-parameters-popup-template",
        extraClass: "transfer-parameter"
      },
      REACT: {
        template: "react-parameters-popup-template",
        extraClass: "react-parameter"
      },
      PROMPT: {
        template: "prompt-parameters-popup-template",
        extraClass: "prompt-parameter"
      },
      TRAPISOTOPE: {
        template: "trap-parameters-popup-template",
        extraClass: "trap-parameter"
      },
      ELUTEISOTOPE: {
        template: "elute-parameters-popup-template",
        extraClass: "elute-parameter"
      },
      MOVE: {
        template: "move-parameters-popup-template",
        extraClass: "move-parameter"
      },
      EXTERNALADD: {
        template: "externaladd-parameters-popup-template",
        extraClass: "externaladd-parameter"
      }
    };
    
    return function(operation) {
      var fields = parameterMap[operation.taskType];
      if( fields ) {
        Elixys.showTemplatedPopup(fields.template, operation, fields.extraClass + " parameter-popup");
      }
    };
  })();
  
  self.visible = ko.computed(function() {
    return self.currentPage() === self.name;
  });


  self.cameraIdLeft = ko.observable(-1);
  self.cameraIdRight = ko.observable(-1);


  self.videoLabelLeft = ko.computed(function() {
    var camera = self.cameraIdLeft();
    if (camera >= 0) {
      return camera + 1;
    }
    return "";
  });

  self.videoUrlLeft = ko.computed(function() {
    if(self.currentPage()!==self.name){
       return "";
    }
    if(self.cameraIdLeft() < 0){
    	self.cameraIdLeft.valueHasMutated();
     }
    
    if (self.cameraIdLeft() >= 0) {
      self.cameraIdLeft.valueHasMutated();
      return self.videoUrl[self.cameraIdLeft()];
    }
    return "";
  });



  self.videoLeftPosition = ko.computed(function() {
    var position  = "-100px";

    if(self.cameraIdLeft() === 0){
        position = self.camera0_position();
    	return position;
     }

    if(self.cameraIdLeft() === 1){
        position = self.camera1_position();
    	return position;
     }

    if(self.cameraIdLeft() === 2){
        position = self.camera2_position();
    	return position;
     }


  });




  self.videoLabelRight = ko.computed(function() {
    var camera = self.cameraIdRight();
    if (camera >= 0) {
      return camera + 1;
    }
    return "";
  });

  self.videoUrlRight = ko.computed(function() {
    if(self.currentPage()!==self.name){
       return "";
    }

     if(self.cameraIdRight() < 0){
    	self.cameraIdRight.valueHasMutated();
     }
     
  
    if (self.cameraIdRight() >= 0 && self.cameraIdRight() !== self.cameraIdLeft()) {
      self.cameraIdRight.valueHasMutated();
      
      return self.videoUrl[self.cameraIdRight()];
    }
    return "";
  });


  self.videoRightPosition = ko.computed(function() {
    var position  = "-100px";

    if(self.cameraIdRight() === 0){
        position = self.camera0_position();
    	return position;
     }

    if(self.cameraIdRight() === 1){
        position = self.camera1_position();
    	return position;
     }

    if(self.cameraIdRight() === 2){
        position = self.camera2_position();
    	return position;
     }


  });

  self.reloadLeftVideo = function(){
     if(self.currentOperation()===undefined){return ;}
     var taskType = self.currentOperation().taskType;
      taskType = taskType.toLowerCase();
      self.videoLeft = document.getElementById(taskType+"video-left");
      var currentSrc = self.videoUrl[self.cameraIdLeft()];
      self.videoLeft.src = "";
      setTimeout(function(){self.videoLeft.src = currentSrc;},1000);

  }

  self.reloadRightVideo = function(){
    if(self.currentOperation()===undefined){return ;}
    var taskType = self.currentOperation().taskType;
      taskType = taskType.toLowerCase();
      self.videoRight = document.getElementById(taskType+"video-right");
      var currentSrc = self.videoUrl[self.cameraIdRight()];
      self.videoRight.src = "";
      setTimeout(function(){self.videoRight.src = currentSrc;},1000);

  }


  function disableVideo(){

    if(self.videoLeft !== null && self.videoLeft !== undefined){
       self.videoLeft.src = "";
    }

    if(self.videoRight !== null && self.videoRight !== undefined){
       self.videoRight.src = "";
    }

  }


  function abortSequence(callback) {
    return Elixys.doApiCall("/abort_sequence", {}, callback);
    self.abort_prompt = false;
  }


  function ignoreError() {
    setTimeout(self.disableErrorAlert,2000);
    return Elixys.doApiCall("/ignore_error", {ignore_error : {}}, function(){});
  }

  function retryRoutine() {
    setTimeout(self.disableErrorAlert,2000);
    return Elixys.doApiCall("/retry_routine", {retry_routine : {}}, function(){});

  }

  function acceptError() {
    setTimeout(self.disableErrorAlert,2000);
    return Elixys.doApiCall("/abort_sequence", {abort_sequence : {}}, function(){});

  }


  
  function overrideTimer(callback) {
    return Elixys.doApiCall("/override_timer", {
      sequenceid: self.sequence().sequenceid,
      componentid: self.currentOperation().id
    }, function(result) {
      callback(result["override_timer"]);
    });
  }


  //hplc position change inject
  self.changeHplcPosition_Inject = function() {
    return Elixys.doApiCall("/change_hplc_position", {
      change_hplc_position : {
      position: "inject"
      }
    },
    function(result){
      //do something
    });
  }

  //hplc position change load
  self.changeHplcPosition_Load = function() {
    return Elixys.doApiCall("/change_hplc_position", {
      change_hplc_position : {
      position: "load"
      }
    },
    function(result){
      //do something
    });
  }

  
  function continueSequence(callback) {
    return Elixys.doApiCall("/continue_sequence", {}, function(result) {
      callback(result["continue_sequence"]);
    });
  }
  
  self.startRun = function(sequence, operations, firstOperation, checklist) {
    return Elixys.sequence(function(fail) {
      return [
        function() {
          return Elixys.doApiCall("/run_sequence", {
            run_sequence: {
              sequenceid: sequence.sequenceid,
              runname: checklist.runname,
              componentid: firstOperation.id,
              checklistid: checklist.checklistid
            }
          });
        }, function(payload) {
          var result = payload["run_sequence"];
          if( result !== "ok" ) {
            return fail(result.error);
          }
          else {
            return result;
          }
        }, function() {
          self.currentOperationIndex(-1);
          self.sequence(sequence);
          self.operations(operations);
          self.elapsedTime(0);
          self.timerOverridden(false);
          self.timerWasOverridden(false);
          return pollStatus();
        }, function() {
          self.currentPage(self.name);
          self.statusInterval = window.setInterval(pollStatus, 1000);
          self.isRunning(true);
          Elixys.hideNotificationPopup();
        }
      ];
    });
  };
  
  self.overrideTimer = function() {
    self.timerOverridden(true);
    overrideTimer(function(result) {
      if( result === "ok" ) {
        self.timerOverridden(true);
        self.timerWasOverridden(true);
        self.runningOperation().notifyOverride();
      }
      else{
      self.timerOverridden(false);
      }
    });
  };


  
  self.continueSequence = function() {
    //quickly disable cont seq button so user does not try to press it again
    self.continueRequired(false);
    self.continueRequired.valueHasMutated();
    self.continueRequiredSet(true);
    self.continueRequiredSet.valueHasMutated();
    continueSequence(function(result) {
      if( result === "ok" ) {
        self.timerOverridden(false);
        self.runningOperation().notifyContinue();
      }

    });
  };
  
  self.changePressure = function(pressure) {
    Elixys.sequence(function(fail) {
      return [
        function() {
          self.changingPressure(true);
          return Elixys.doApiCall("/change_pressure", {
            change_pressure: {
              sequenceid: self.sequence().sequenceid,
              componentid: self.currentOperation().id,
              target_pressure: pressure
            }
          });
        }, function(payload) {
          var result = payload.change_pressure;
          if( result !== "ok" ) {
            return fail(result);
          }
        }
      ];
    }).fail(function(error) {
      if( typeof error === "string" ) {
        console.log("Error changing pressure: " + error);
      }
      else {
        console.log("Error changing pressure.");
        console.log(error);
      }
    }).always(function() {
      setTimeout(self.enableChangingPressure,750);
    });
  };


 self.enableChangingPressure = function(){
  self.changingPressure(false);
  self.changingPressure.valueHasMutated();
  }

  
  self.targetPressure = ko.pureComputed(function() {
    var operation = self.currentOperation();
    if( operation && operation.pressure ) {
      return operation.pressure();
    }
    else {
      return -1;
    }
  });
  
  self.incPressure = function() {
    var operation = self.currentOperation();
    var pressure = operation.pressure();
    if( pressure < 30 ) {
      operation.pressure(pressure + 0.5);
      self.changePressure(pressure + 0.5);
    }
  };
  
  self.incPressureEnabled = ko.pureComputed(function() {
    var operation = self.currentOperation();
    var pressure = operation.pressure();
    if( self.changingPressure() === false && pressure < 30 ) {
      return true;
    }
    else {
      return false;
    }
  });
  
  self.decPressure = function() {
    var operation = self.currentOperation();
    var pressure = operation.pressure();
    if( pressure > 0 ) {
      operation.pressure(pressure - 0.5);
      self.changePressure(pressure - 0.5);
    }
  };
  
  self.decPressureEnabled = ko.pureComputed(function() {
    var operation = self.currentOperation();
    var pressure = operation.pressure();
    if( self.changingPressure() === false && pressure > 0 ) {
      return true;
    }
    else {
      return false;
    }
  });

  self.toggleStirEnabled = ko.pureComputed(function(){
    return self.timerOverridden() || self.continueRequired();
  });

  self.setStirState = function( reactor, current_motor_speed ){
    var state = current_motor_speed == 0;
    Elixys.doApiCall("/set_stir_state",
                     {"set_stir_state": {'reactor' : reactor, 'state' : state}},
                     function(result){
                     },
                     function(error){
                       console.log( 'An error occured while attempting to stir');
                       console.log( error );
                     });
  }
  
  self.goToPage = function() {
    // If we're already running, then just navigate to the page
    if( self.isRunning() ) {
      self.currentPage(self.name);
    }
    else {
      Elixys.sequence(function(fail) {
        var status;
        return [
          function() {
            Elixys.showNotificationPopup("Loading...");
            return Elixys.doApiCall("/get_status", {});
          },
          function(payload) {
            var result = payload["get_status"];
            if( result.error ) {
              return fail(result.error);
            }
            else {
              status = result;
              return result;
            }
          },
          function(result) {
            var operation_status = result["operation_status"];
            if( operation_status.running ) {
              return Elixys.doApiCall("/get_sequence_and_components", {
                get_sequence_and_components: {
                  sequenceid: operation_status.sequenceid
                }
              });
            }
            else {
              return fail("No sequence is currently being run.");
            }
          },
          function(payload) {
            var result = payload["get_sequence_and_components"];
            if( result.error ) {
              return fail(result.error);
            }
            else {
              return result;
            }
          },
          function(result) {
            var sequence = result["sequence"];
            var components = result["components"];
            self.sequence(sequence);
            return Elixys.viewModels.editSequence.populateComponents(components);
          },
          function(cassettes, operations) {
            var currentOperation = status.operation_status.order - 1;
            // Mark operations we've already done as finished
            for( var i = 0; i < currentOperation; i++ ) {
              operations[i].toggleFinished();
            }
            self.currentOperationIndex(-1);
            self.operations(operations);
            self.elapsedTime(0);
            self.timerOverridden(false);
            self.timerWasOverridden(false);
            gotStatus(status);
            self.currentPage(self.name);
            self.statusInterval = window.setInterval(pollStatus, 1000);
            self.isRunning(true);
            Elixys.hideNotificationPopup();
          }
        ];
      }).fail(function(error) {
        if( typeof error === "string" ) {
          Elixys.showNotificationPopup(error, {
            showCloseButton: true
          });
        }
        else {
          Elixys.showNotificationPopup("There was an error trying to get the run status.", {
            showCloseButton: true
          });
        }
      });
    }
  };
  
  function pollStatus() {
    return Elixys.sequence(function(fail) {
      return [
        function() {
          return Elixys.doApiCall("/get_status", {});
        },
        function(payload) {
          var result = payload["get_status"];
          if( result.error ) {
            return fail(result.error);
          }
          else {
            return result;
          }
        },
        gotStatus
      ];
    });
  }
  self.prompt_if_disconnected = true;
  self.cbox_prompt_if_disconnected = true;
  function gotStatus(result) {
    var operation_status = result.operation_status;
    var system_status = result.system_status;
    var sequence_status = result.sequence_status;
    self.logged_sequence_id(operation_status['sequenceid']);

    if(operation_status.override_timer_ready === true){
      //ok to show timer override
      self.timerOverrideReady(true);
      self.timerOverrideReady.valueHasMutated()
      self.timerOverridden(false);
    }
    else{
      self.timerOverrideReady(false);
      self.timerOverrideReady.valueHasMutated()
    }
	
	if(operation_status.continue_sequence_required === true){
		self.continueRequired(true);
		//self.timerOverridden(true);
	}
	else{
		self.continueRequired(false);
	}

    if( operation_status.order  !== self.currentOperationIndex() + 1 ) {
      self.currentOperationIndex(operation_status.order - 1);
      self.newOperationStarted = true;
      self.continueRequiredSet(false); //reset
    }
    else{
      self.newOperationStarted = false;
    }
    if( sequence_status.sequence_running === false ) {
      self.currentOperationIndex(-1);
      window.clearInterval(self.statusInterval);
      self.statusInterval = undefined;
      if( self.timerWasOverridden() ) {
        saveCopy();
      }
      else {

        endRun();
      }
    }

    // Select correct reactors
    var data = self.currentOperationData();
    var taskType = undefined;
    if(self.currentOperation()!==undefined){
        taskType = self.currentOperation().taskType;
        taskType = taskType.toLowerCase();
    }

    var reactor = firstAvailable(data, ["reactor", "sourcereactor"]);
    var targetReactor = firstAvailable(data, ["targetreactor"]);
    var temperature = firstAvailable(data, ["evaporationtemperature", "reactiontemperature", "finaltemperature"]);
    if( self.timerOverridden() ) {
      //self.operationTimerSeconds(self.operationTimerSeconds() + 1);
      self.operationTimerSeconds(operation_status.time_remaining_sec);
    }
    else {

      self.operationTimerSeconds(operation_status.time_remaining_sec);
    }
    self.elapsedTime(parseInt(sequence_status.sequence_time_elapsed));
    // Readings from the server
    self.readings.pressure.current(system_status.pressure_regulators.pressure1);

    self.readings.operation_status.message(operation_status.message);

    self.readings.hplc.position(system_status.hplc.position);
    self.readings.hplc.fluid(system_status.hplc.fluid);
	self.readings.hplc.positionInject(system_status.hplc.position == "Inject");
	self.readings.hplc.positionLoad(system_status.hplc.position == "Load");
    if( reactor === 0 ) {
      self.readings.temperature.current(system_status.reactor_temperatures.reactor0);
      self.readings.activity1.reactor(system_status.radiation_activity.reactor0.activity1);
      self.readings.activity1.cartridgeA(system_status.radiation_activity.reactor0.cartridgeA);
      self.readings.activity1.cartridgeB(system_status.radiation_activity.reactor0.cartridgeB);
      self.readings.sourceMotor(system_status.motors.reactor0);
      self.cameraIdLeft (0);
      self.cameraIdLeft.valueHasMutated();
    }
    else if( reactor === 1 ) {
      self.readings.temperature.current(system_status.reactor_temperatures.reactor1);
      self.readings.activity1.reactor(system_status.radiation_activity.reactor1.activity1);
      self.readings.activity1.cartridgeA(system_status.radiation_activity.reactor1.cartridgeA);
      self.readings.activity1.cartridgeB(system_status.radiation_activity.reactor1.cartridgeB);
      self.readings.sourceMotor(system_status.motors.reactor1);
      self.cameraIdLeft(1);
      self.cameraIdLeft.valueHasMutated();
    }
    else if( reactor === 2 ) {
      self.readings.temperature.current(system_status.reactor_temperatures.reactor2);
      self.readings.activity1.reactor(system_status.radiation_activity.reactor2.activity1);
      self.readings.activity1.cartridgeA(system_status.radiation_activity.reactor2.cartridgeA);
      self.readings.activity1.cartridgeB(system_status.radiation_activity.reactor2.cartridgeB);
      self.cameraIdLeft(2);
      self.cameraIdLeft.valueHasMutated();
      self.readings.sourceMotor(system_status.motors.reactor2);
    }
    else {
      self.cameraIdLeft(-1);
      self.cameraIdLeft.valueHasMutated();
    }
    if( targetReactor === 0 ) {
      self.readings.activity2.reactor(system_status.radiation_activity.reactor0.activity1);
      self.readings.activity2.cartridgeA(system_status.radiation_activity.reactor0.cartridgeA);
      self.readings.activity2.cartridgeB(system_status.radiation_activity.reactor0.cartridgeB);
      self.readings.targetMotor(system_status.motors.reactor0);
      self.cameraIdRight(0);
      self.cameraIdLeft.valueHasMutated();

    }
    else if( targetReactor === 1 ) {
      self.readings.activity2.reactor(system_status.radiation_activity.reactor1.activity1);
      self.readings.activity2.cartridgeA(system_status.radiation_activity.reactor1.cartridgeA);
      self.readings.activity2.cartridgeB(system_status.radiation_activity.reactor1.cartridgeB);
      self.readings.targetMotor(system_status.motors.reactor1);
      self.cameraIdRight(1);
      self.cameraIdLeft.valueHasMutated();
    }
    else if( targetReactor === 2 ) {
      self.readings.activity2.reactor(system_status.radiation_activity.reactor2.activity1);
      self.readings.activity2.cartridgeA(system_status.radiation_activity.reactor2.cartridgeA);
      self.readings.activity2.cartridgeB(system_status.radiation_activity.reactor2.cartridgeB);
      self.readings.targetMotor(system_status.motors.reactor2);
      self.cameraIdRight(2);
      self.cameraIdLeft.valueHasMutated();
    }
    else {
      self.cameraIdRight(-1);
      self.cameraIdLeft.valueHasMutated();
    }
    var destination = data["destination"];
    self.readings.sourceReactor(reactor);
    self.readings.targetReactor(targetReactor);
    self.readings.hasTargetReactor(destination && destination.toUpperCase() == "REACTOR")
    self.hasTargetReactor(destination && destination.toUpperCase() == "REACTOR");

    if(self.newOperationStarted){
      self.timerOverridden(false);

      self.runningOperation().finishOperation();
      var lastOperation = self.runningOperation();

      self.runningOperation(new RunningOperation(self.currentOperation()));
      if(!lastOperation.operation && self.runningOperation().operation.name == "TRANSFER"){
        if(self.readings.operation_status.message() == "Waiting for user to inject/load"){
          self.runningOperation().notifyOverride();
        }
      }
      self.startVideo(taskType,reactor, targetReactor);
    }
    if(operation_status.user_prompt.status_code){
      self.runningOperation().setUserPrompt(operation_status.user_prompt);
    }
    else{
      self.runningOperation().setUserPrompt(null);
    }

    if(self.currentPage() !== self.name && self.cameras_disabled()){
       disableVideo();
       self.cameras_disabled(false);
    }

    if(self.currentPage() === self.name && self.cameras_enabled()){
       self.startVideo(taskType,reactor, targetReactor);
       self.cameras_enabled(false);
    }
    self.readings.temperature.target(operation_status.target_temperature);
    self.readings.pressure.target(self.targetPressure());
    self.readings.vacuum(system_status.vacuum_pump.pressure);

    //if error then show popup

    if( !system_status.synth_connection && self.prompt_if_disconnected && !self.abort_prompt){
      Elixys.showNotificationPopup("Synthesizer Board has been disconnected", {
        confirmText: "Reconnect",
        confirmCallback: function(){
          if(self.errorAlertSet()){
              setTimeout(self.errorAlert, 100);
          }
          else{
              Elixys.hideNotificationPopup();
          }
          self.prompt_if_disconnected = false;
          setTimeout(function(){
            self.prompt_if_disconnected = true;
          }, 30000);
        }
      });
    }

    if( !system_status.cbox_connection && self.cbox_prompt_if_disconnected && !self.abort_prompt){
      Elixys.showNotificationPopup("CBox has been disconnected", {
        confirmText: "Reconnect",
        confirmCallback: function(){
          if(self.errorAlertSet()){
              setTimeout(self.errorAlert, 100);
          }
          else{
              Elixys.hideNotificationPopup();
          }
          self.cbox_prompt_if_disconnected = false;
          setTimeout(function(){
            self.cbox_prompt_if_disconnected = true;
          }, 30000);
        }
      });
    }
    if( operation_status.error ){
        self.errorAlertSet(true);
        if( system_status.synth_connection && system_status.cbox_connection ){
            setTimeout(self.errorAlert, 100);
        }
    }
    else if(system_status.synth_connection && system_status.cbox_connection && !self.abort_prompt){
        Elixys.hideNotificationPopup();
    }

	
	if(self.readings.hplc.fluid() == "No Fluid") {
	    self.readings.hplc.fluid("No");
	} else {
	    self.readings.hplc.fluid("Yes");
	}
	
	if(self.readings.hplc.position() == "Load") {
	  self.readings.hplc.position_message("Hplc valve is in the load position");
	} else {
	  self.readings.hplc.position_message("Hplc valve is in the inject position");
	}
  }
  
  function firstAvailable(obj, fields) {
    for( var i = 0; i < fields.length; i++ ) {
      if( obj[fields[i]] !== undefined ) {
        return obj[fields[i]];
      }
    }
    return -1;
  }
  
  function saveCopy() {
    Elixys.showNewSequencePopup({
      titleText: "Copy Sequence",
      buttonText: "Copy",
      create: function(name, description) {
        return Elixys.sequence(function(fail) {
          return [
            function() {
              return Elixys.doApiCall("/copy_sequence_and_components", {
                copy_sequence_and_components: {
                  sequenceid: self.logged_sequence_id(),
                  name: name,
                  comment: description
                }
              });
            }, function(payload) {
              var result = payload["copy_sequence_and_components"];
              if( result.error ) {
                fail(result.error);
              }
              else {
                return result;
              }
            }
          ];
        }).always(endRun);
      },
      close: endRun
    });
  }
  self.abort_prompt = false;
  self.abortRun = function() {
    self.abort_prompt = true;
    Elixys.showNotificationPopup("Are you sure you want to abort \"" + self.sequenceName() + "\"?", {
      confirmCallback: function() {
        window.clearInterval(self.statusInterval);
        self.statusInterval = undefined;
        disableVideo();
        //Elixys.viewModels.cameraCtrl.hideCameras();
        abortSequence(saveCopy);
        self.abort_prompt = false;
      },
      confirmText: "Yes",
      cancelCallback: function() {self.abort_prompt=false;},
      cancelText: "No"
    });
  };


  //if operation status error message is true then show error

  self.errorAlert = function() {
    Elixys.showNotificationPopup(self.readings.operation_status.message(), {
      confirmCallback: function() {
        ignoreError();
      },
      confirmText: "Ignore",
      cancelCallback: function() {
          retryRoutine();
      },
      cancelText: "Retry",
      otherCallback: function(){
          acceptError();
      },
      otherText: "Abort",
      showOtherButton: true
    });

  };

  self.disableErrorAlert = function(){
    self.errorAlertSet(false);
    self.errorAlertSet.valueHasMutated();
  }
  
  function endRun() {
    disableVideo();
    Elixys.navigationDirty()(false); // If pressure is changed, that will set the dirty flag
    self.currentPage(Elixys.viewModels.logs.name);
    self.isRunning(false);
  }
  
  self.statusInterval = undefined; // Will be initialized when the run is started
 
  self.sequenceName = ko.computed(function() {
    var sequence = self.sequence();
    if( sequence && sequence.details ) {
      return sequence.details.name;
    }
    else {
      return "";
    }
  });

  self.activeTemplate = ko.pureComputed(function() {
    var operation = self.currentOperation();

    if( operation !== undefined ) {
      var template = self.getTemplateFromOperationType(operation.taskType);
      return template;
    }
    else {
      //Elixys.viewModels.cameraCtrl.hideCameras();
      return "blank-template";
    }
  });

  self.hasSequence = ko.computed(function() {
    return self.sequence() !== undefined;
  });
  
  function timeDisplay(target) {
    return function() {
      var time = Math.max(target(), 0);
      
      function asDigit(t) {
        var t2 = parseInt(t);
        if( t2 < 10 ) {
          return "0" + t2;
        }
        else {
          return t2.toString();
        }
      }
      
      var hours = asDigit((time/60)/60);
      var minutes = asDigit((time/60)%60);
      var seconds = asDigit(time%60);
      return hours + ":" + minutes + ":" + seconds;
    };
  }
  
  self.elapsedTimeDisplay = ko.computed(timeDisplay(self.elapsedTime));
  
  self.modeDisplay = function(mode) {
    if( mode === "elute" ) {
      return "Elute";
    }
    else if( mode === "trap" ) {
      return "Trap";
    }
    else {
      return "Out of System";
    }
  };
  
  self.currentOperationIndex = ko.observable(-1);
  
  self.currentOperation = ko.computed(function() {
    var index = self.currentOperationIndex();
    if( index !== -1 ) {
      return self.operations()[index];
    }
    else {
      return undefined;
    }
  });
  // Before change
  self.currentOperation.subscribe(function(operation) {
    if( operation !== undefined ) {
      operation.selected(false);
      operation.finished(true);
    }
  }, null, "beforeChange");
  // After change
  self.currentOperation.subscribe(function(operation) {
    if( operation !== undefined ) {
      operation.selected(true);
    }
  });
  
  self.currentOperationData = ko.computed(function() {
    var operation = self.currentOperation();
    if( operation !== undefined ) {
      if( operation.data !== undefined ) {
        return Elixys.unmakeObservable(operation.data);
      }
    }
    return {};
  });
  
  self.operationTimerSeconds = ko.observable(30);

  self.operationTimer = ko.computed(timeDisplay(self.operationTimerSeconds));
  
  self.readings = {
    operation_status: {
    message: displayText("status"),

    },
    hplc: {
    position: displayText("Inject"),
    position_message: displayText(""),
    fluid: displayText("No Fluid"),
	positionInject: displayBool(false),
	positionLoad: displayBool(false)
    },
    pressure: {
      current: displayRoundingDown(18, 1),
      target: displayRoundingDown(30, 1)
    },
    temperature: {
      current: displayRoundingDown(163, 0),
      target: displayRoundingDown(170, 0)
    },
    vacuum: displayRoundingDown(30, 1),
    activity1: {
      reactor: displayRoundingDown(36.82, 2),
      cartridgeA: displayRoundingDown(18.90, 2),
      cartridgeB: displayRoundingDown(22.42, 2)
    },
    activity2: {
      reactor: displayRoundingDown(36.82, 2),
      cartridgeA: displayRoundingDown(18.90, 2),
      cartridgeB: displayRoundingDown(22.42, 2)
    },
    sourceMotor: ko.observable(0),
    targetMotor: ko.observable(0),
    sourceReactor: ko.observable(0),
    targetReactor: ko.observable(0),
    hasTargetReactor: ko.observable(false)
  };

  self.reactorIdLeft = ko.computed(function() {
    var operation = self.currentOperation();
    if( operation !== undefined ) {
      if( operation.data !== undefined ) {
        return Elixys.unmakeObservable(operation.data);
      }
    }
    return {};
  });


  //true / false
  function displayBool(bool){
  return withDisplayFn(function(value) {
      if( value !== undefined ) {
        return value;
      }
      else {
        return false;
      }
    }, bool);
  }


  function displayText(text){
  return withDisplayFn(function(value) {
      if( value !== undefined ) {
        return value;
      }
      else {
        return "status";
      }
    }, text);
  }

  function displayRoundingDown(start, sigFigs) {
    return withDisplayFn(function(value) {
      if( value !== undefined ) {
        return value.toFixed(sigFigs);
      }
      else {
        return -1;
      }
    }, start);
  }
  
  function withDisplayFn(f, start) {
    var value = ko.observable(start);
    function readVal() {
      return f(value());
    }
    function writeVal(newValue) {
      value(newValue);
    }
    return ko.computed({
      read: readVal,
      write: writeVal
    });
  }

  function RunningOperation(operation){
    var self = this;
    this.operation = operation;
    this.showInjectLoad = ko.observable(false);
    this.pressureModifiable = ko.observable(false);
    this.userPrompt = ko.observable();

    this.finishOperation = function(){
    }

    this.setUserPrompt = function(prompt){
      this.userPrompt(prompt);
    }

    this.userResponse = function(response){
      var data = {status_code: self.userPrompt().status_code, response: response};
      $.ajax("/user_response", {
        method: "POST",
        data: JSON.stringify(data),
        contentType: "application/json",
        error: function(jqxhr, textStatus, errorThrown){
          console.log("error");
          console.log( jqxhr );
        },
        success: function(data, textStatus, jqxhr){
          self.userPrompt(null);
        }
      });
    }

    if( this.operation ){
      if( this.operation.name == "TRANSFER" ){
        this.notifyContinue = function(){
          var hplcManual = this.operation.data.destination() =='hplc' && this.operation.data.hplc.mode() == "manual"
          this.showInjectLoad(hplcManual);
          this.pressureModifiable(hplcManual);
        }

        this.notifyOverride = function(){
          this.showInjectLoad(this.operation.data.destination() =='hplc');
          this.pressureModifiable(true);
        }
      }
      else{
        this.notifyContinue = function(){

        }
        this.notifyOverride = function(){

        }
      }
    }
  }
}

function PreRunChecklist() {
  'use strict';
  
  var self = this;
  self.name = "PRE-RUN CHECKLIST";
  
  // inherits Common.
  Common.apply(self, arguments);

//video cameras

self.cameraId_0 = ko.observable(-1);
self.resetMessage_0 = ko.observable("RESET FEED 1");

self.cameraId_1 = ko.observable(-1);
self.resetMessage_1 = ko.observable("RESET FEED 2");

self.cameraId_2 = ko.observable(-1);
self.resetMessage_2 = ko.observable("RESET FEED 3");


  self.videoUrl_0 = ko.computed(function() {
    if(self.currentPage() === self.name){
       if(self.cameraId_0()===undefined){self.cameraId_0(0);}
    self.cameraId_0.valueHasMutated();
    }
    else{
    self.cameraId_0(-1);
    self.cameraId_0.valueHasMutated();
    }
    if (self.cameraId_0() >= 0) {
      
      return self.videoUrl[self.cameraId_0()];
    }
    return "";
  });


self.videoUrl_1 = ko.computed(function() {
    if(self.currentPage() === self.name){
    if(self.cameraId_1()===undefined){self.cameraId_1(1);}
    self.cameraId_1.valueHasMutated();
    }
    else{
    self.cameraId_1(-1);
    self.cameraId_1.valueHasMutated();
    }
    if (self.cameraId_1() >= 0) {
      
      return self.videoUrl[self.cameraId_1()];
    }
    return "";
  });


self.videoUrl_2 = ko.computed(function() {
    if(self.currentPage() === self.name){

    if(self.cameraId_2()===undefined){self.cameraId_2(2);}
    self.cameraId_2.valueHasMutated();
    }
    else{
    self.cameraId_2(-1);
    self.cameraId_2.valueHasMutated();
    }
    if (self.cameraId_2() >= 0) {
      
      return self.videoUrl[self.cameraId_2()];
    }
    return "";
  });


 self.postRender = function() {
     if(self.currentPage() === self.name){
  	self.cameraId_0(0);
  	self.cameraId_0.valueHasMutated();
  	self.cameraId_1(1);
  	self.cameraId_1.valueHasMutated();
  	self.cameraId_2(2);
  	self.cameraId_2.valueHasMutated();
     }

  }



self.resetVideo_0 = function() {
    var id = 0;
    if(self.currentPage()===self.name){
    self.disableVideo(id);
    return Elixys.doApiCall("/video_reset", {video_reset : {"camera_id": id}}, function(){setTimeout(self.enableVideo,1500,id);});

    }

  };

self.resetVideo_1 = function() {
    var id = 1;
    if(self.currentPage()===self.name){
    self.disableVideo(id);
    return Elixys.doApiCall("/video_reset", {video_reset : {"camera_id": id}}, function(){setTimeout(self.enableVideo,1500,id);});

    }

  };


self.resetVideo_2 = function() {

    var id = 2;
    if(self.currentPage()===self.name){
    self.disableVideo(id);
    return Elixys.doApiCall("/video_reset", {video_reset : {"camera_id": id}}, function(){setTimeout(self.enableVideo,1500,id);});
    }

  };


self.disableVideo = function(id){


   if(id===0){
      self.cameraId_0(-1);
      self.cameraId_0.valueHasMutated();
      self.resetMessage_0("RESETTING...");
   }

   if(id===1){

      self.cameraId_1(-1);
      self.cameraId_1.valueHasMutated();
      self.resetMessage_1("RESETTING...");
   }


   if(id===2){
      
      self.cameraId_2(-1);
      self.cameraId_2.valueHasMutated();
      self.resetMessage_2("RESETTING...");
   }
};

self.enableVideo = function(id){


  if(id===0){
      self.cameraId_0(0);
      self.cameraId_0.valueHasMutated();
      self.resetMessage_0("RESET FEED 1");
   }

   if(id===1){
      self.cameraId_1(1);
      self.cameraId_1.valueHasMutated();
      self.resetMessage_1("RESET FEED 2");
   }


   if(id===2){

      self.cameraId_2(2);
      self.cameraId_2.valueHasMutated();
      self.resetMessage_2("RESET FEED 3");
   }
};


//end video cameras
  
  self.processCassettes = function(cassettes, operations, startingOperation) {
    var reagentsResult = [];
    var cassettesResult = [];
    cassettes.forEach(function(cassette, cassetteIndex) {
      var hasReagents = false;
      cassette.reagents.forEach(function(reagent, reagentIndex) {
        var name = reagent.name();
        var description = reagent.description();
        if(name && name !== "") {
          reagentsResult.push(new Reagent(name, cassetteIndex+1, reagentIndex+1, description));
          hasReagents = true;
        }
      });
      if( hasReagents ) {
        cassettesResult.push(new Cassette(cassetteIndex+1, cassette));
      }
    });
    self.reagents(reagentsResult);
    self.cassettes(cassettesResult);
    self.operations = operations;
    self.startingOperation = startingOperation;
    self.currentPage(self.name);
    Elixys.sequence(function(fail) {
      var sequenceid = self.currentSequence().sequenceid;
      return [
        function() {
          Elixys.showNotificationPopup("Loading...");
          return Elixys.doApiCall("/get_last_logged_checklist", {
            get_last_logged_checklist: {
              parentsequenceid: sequenceid
            }
          });
        },
        function(payload) {
          if( payload.error ) {
            return fail(payload.error);
          }
          else {
            return payload.get_last_logged_checklist;
          }
        },
        function(old_checklist) {
          if( old_checklist.error ) {
            // Error here means we don't have a previous checklist, just return to continue.
            return;
          }
          else {
            self.reagents().forEach(function(reagent) {
              var reg = old_checklist["cassette" + reagent.cassette].reagents[reagent.position-1];
              reagent.description(reg.description);
              reagent.lotNumber(reg.lotnumber);
            });
          }
        },
        function() {
          return Elixys.doApiCall("/add_checklist", {
            add_checklist: {
              parentsequenceid: sequenceid
            }
          });
        },
        function(payload) {
          if( payload.error ) {
            return fail(payload.error);
          }
          else {
            return payload.add_checklist;
          }
        },
        function(checklist) {
          self.checklist = checklist;
          Elixys.hideNotificationPopup();
        }
      ];
    }).fail(function(error) {
      if( typeof error === "string" ) {
        Elixys.showNotificationPopup("Error: " + error, {
          showCloseButton: true
        });
      }
      else {
        Elixys.showNotificationPopup("An error has occurred.", {
          showCloseButton: true
        });
      }
    });
  };
  
  self.reagents = ko.observableArray([]);
  self.cassettes = ko.observableArray([]);
  self.operations = [];
  self.checklist = {};
  self.startingOperation = undefined; // Will be set from the edit sequence screen
  
  function Reagent(name, cassette, position, description) {
    var self = this;
    self.name = name;
    self.cassette = cassette;
    self.position = position;
    self.lotNumber = ko.observable("");
    self.description = ko.observable(description);
    self.checked = ko.observable(false);
    self.markedInvalid = ko.observable(false);
  }
  
  function Cassette(number, details) {
    var self = this;
    self.number = number;
    self.details = details;
    self.lotNumber = ko.observable("");
    self.checked = ko.observable("");
    self.markedInvalid = ko.observable(false);
  }
  
  function Checkbox() {
    var self = this;
    self.checked = ko.observable(false);
    self.markedInvalid = ko.observable(false);
  }
  
  self.visible = ko.computed(function () {
    return self.currentPage() === self.name;
  });
  self.visible.subscribe(function(newValue) {
    if( newValue ) {
      self.runName("");
      self.runDescription("");
      self.steps.forEach(function(checkbox) {
        checkbox.checked(false);
      });
      // Clear invalid fields
      self.runNameInvalid(false);
      self.reagents().forEach(function(reagent) {
        reagent.markedInvalid(false);
      });
      self.cassettes().forEach(function(cassette) {
        cassette.markedInvalid(false);
      });
      self.steps.forEach(function(checkbox) {
        checkbox.markedInvalid(false);
      });
    }
  });
  self.visible.subscribe(function(newValue) {
    if( newValue ) {
      $("div.pre-run-checklist").scrollTop(0);
    }
  }, null, "beforeChange");
  
  function createChecklist() {
    var sequenceid = self.currentSequence().sequenceid;
    Elixys.doApiCall("/add_checklist", {
      "add_checklist": {
        "parentsequenceid": sequenceid
      }
    }, function( result ) {
      self.checklist = result["add_checklist"];
    });
  }
  
  // Fields for section 1
  self.runName = ko.observable("");
  self.runNameInvalid = ko.observable(false);
  self.runDescription = ko.observable("");
  
  // Steps for section 4
  self.steps = [
    new Checkbox(),
    new Checkbox(),
    new Checkbox(),
    new Checkbox(),
    new Checkbox(),
    new Checkbox()
  ];
  
  // Buttons
  self.back = function() {
    self.currentPage(Elixys.viewModels.editSequence.name);
  };
  
  self.continueButton = function() {
    var invalid = false;
    // Check fields
    if( self.runName() === "" ) {
      self.runNameInvalid(true);
      invalid = true;
    }
    self.reagents().forEach(function(reagent) {
      if( reagent.checked() === false ) {
        reagent.markedInvalid(true);
        invalid = true;
      }
    });
    self.cassettes().forEach(function(cassette) {
      if( cassette.checked() === false ) {
        cassette.markedInvalid(true);
        invalid = true;
      }
    });
    self.steps.forEach(function(checkbox) {
      if( checkbox.checked() === false ) {
        checkbox.markedInvalid(true);
        invalid = true;
      }
    });
    // Validation errors
    if( invalid === true ) {
      Elixys.showNotificationPopup("Please ensure that a run name has been provided and that all checkboxes have been checked.",
        { showCloseButton: true });
    }
    // Prompt user to continue
    else {
      Elixys.showNotificationPopup("Begin running this sequence?", {
        confirmCallback: function() {
          // Stall slightly so the popup can get closed before we reopen it
          window.setTimeout(function() {
            Elixys.sequence(function(fail) {
              return [
                function() {
                  Elixys.showNotificationPopup("Starting run...");
                  self.reagents().forEach(function(reagent) {
                    var reg = self.checklist["cassette" + reagent.cassette].reagents[reagent.position-1];
                    reg.name = reagent.name || "";
                    reg.description = reagent.description();
                    reg.lotnumber = reagent.lotNumber() || 0;
                  });
                  self.checklist.runname = self.runName();
                  self.checklist.rundescription = self.runDescription();
                  self.checklist.valid = true;
                  return Elixys.doApiCall("/save_checklist", {
                    save_checklist: self.checklist
                  });
                }, function(payload) {
                  var result = payload["save_checklist"];
                  if( result.error ) {
                    return fail(result.error);
                  }
                  else {
                    return result;
                  }
                }, function() {
                  return Elixys.viewModels.running.startRun(self.currentSequence(), self.operations, self.startingOperation, self.checklist);
                }
              ];
            }).fail(function(error) {
              var errorString;
              if( typeof error === "string" ) {
                errorString = "Error starting run: " + error;
              }
              else {
                errorString = "Error starting run.";
              }
              Elixys.showNotificationPopup(errorString, {
                showCloseButton: true
              });
            });
          }, 10);
        },
        confirmText: "Run"
      });
    }
  };
  
  self.selectAll = function() {
    self.reagents().forEach(function(reagent) {
      reagent.checked(true);
    });
    self.cassettes().forEach(function(cassette) {
      cassette.checked(true);
    });
    self.steps.forEach(function(checkbox) {
      checkbox.checked(true);
    });
  };
  
  self.clearAll = function() {
    self.runName("");
    self.runDescription("");
    self.reagents().forEach(function(reagent) {
      reagent.checked(false);
      reagent.lotNumber("");
      reagent.description("");
    });
    self.cassettes().forEach(function(cassette) {
      cassette.lotNumber("");
      cassette.checked(false);
    });
    self.steps.forEach(function(checkbox) {
      checkbox.checked(false);
    });
  };
  
}

function NewSequencePopup() {
  'use strict';
  
  var self = this;
  
  // inherits Common.
  Common.apply(self, arguments);
  
  self.visible = ko.observable(false);
  self.name = ko.observable("");
  self.description = ko.observable("");
  self.notBusy = ko.observable(true);
  self.titleText = ko.observable("");
  self.buttonText = ko.observable("");
  
  self.enabled = ko.computed(function() {
    return self.notBusy() && self.name() !== "" && self.description() !== "";
  });
  
  function defaultHandler() {};
  self.createCallback = defaultHandler;
  self.closeCallback = defaultHandler;
  
  self.create = function() {
    self.notBusy(false);
    self.buttonText("Creating...");
    var result = self.createCallback(self.name(), self.description());
    // Can defer
    if( result && typeof result.then === "function" ) {
      result.then(cleanup);
      result.fail(function(error) {
        if( typeof error === "string" ) {
          self.buttonText("Create");
          Elixys.showNotificationPopup("Error: " + error, {
            showCloseButton: true
          });
        }
        else {
          self.buttonText("Create");
          Elixys.showNotificationPopup("There was an error saving the sequence.", {
            showCloseButton: true
          });
        }
        self.notBusy(true);
      });
    }
    else {
      cleanup();
    }
    
    function cleanup() {
      self.visible(false);
      clear();
    }
  };
  
  self.close = function() {
    if( self.notBusy() ) {
      var result = self.closeCallback();
      // Can defer
      if( result && typeof result.then === "function" ) {
        result.then(cleanup);
      }
      else {
        cleanup();
      }
    }
      
    function cleanup() {
      self.visible(false);
      clear();
    };
  }
  
  self.popup = function(options) {
    if( typeof options.create === "function" ) {
      self.createCallback = options.create;
    }
    else {
      self.createCallback = defaultHandler;
    }
    if( typeof options.close === "function" ) {
      self.closeCallback = options.close;
    }
    else {
      self.closeCallback = defaultHandler;
    }
    if( options.titleText ) {
      self.titleText(options.titleText);
    }
    else {
      self.titleText("New Sequence");
    }
    if( options.buttonText ) {
      self.buttonText(options.buttonText);
    }
    else {
      self.buttonText("Create");
    }
    self.visible(true);
  };
  
  function clear() {
    self.name("");
    self.description("");
    self.notBusy(true);
  }
}

function ImportSequencePopup() {
  'use strict';
  
  var self = this;
  
  // inherits Common.
  Common.apply(self, arguments);
  
  self.visible = ko.observable(false);
  self.name = ko.observable("");
  self.description = ko.observable("");
  self.currentImportName = ko.observable("");
  self.import_file_valid = ko.observable(false);
  self.sequence_data = undefined;
  self.notBusy = ko.observable(true);
  self.titleText = ko.observable("");
  self.buttonText = ko.observable("");
  self.validateImport = ko.observable();
  self.importFile = ko.observable();
  
  self.enabled = ko.computed(function() {
    return self.notBusy() && self.name() !== "" && self.import_file_valid();
  });

  function defaultHandler() {};

  self.closeCallback = defaultHandler;

  self.file = function(){
    var file_input = window.document.getElementById("import-sequence-input");
    var seq_file = file_input.files[0];
    return seq_file;
  }
  
  self.create = function() {
    self.notBusy(false);
    self.buttonText("Importing...");
    self.importFile()(self);
  };

  self.close = function() {
    if( self.notBusy() ) {
      var result = self.closeCallback();
      // Can defer
      if( result && typeof result.then === "function" ) {
        result.then(cleanup);
      }
      else {
        cleanup();
      }
    }
      
    function cleanup() {
      self.visible(false);
      self.clear();
    };
  }
  
  self.popup = function(options) {
    self.loadDefaults();

    if( typeof options.close === "function" ) {
      self.closeCallback = options.close;
    }

    if( options.titleText ) {
      self.titleText(options.titleText);
    }

    if( options.buttonText ) {
      self.buttonText(options.buttonText);
    }

    if( options.importFile && typeof options.importFile === "function"){
      self.importFile(options.importFile);
    }

    if( options.validateImport && typeof options.validateImport == "function"){
      self.validateImport( options.validateImport );
    }

    self.visible(true);
  };

  self.loadDefaults = function(){
    self.closeCallback = defaultHandler;
    self.titleText("Import Sequence");
    self.buttonText("Import");

    self.importFile(function(){
      console.log("The importFile function must be defined by the developer");
    });
    self.validateImport(function(){
    console.log("The validateImport function must be defined by the developer");
    console.log( "Within the function you must set the \"currentImportName\", \"name\", " +
                 "and may validate/invalidate \"import_file_valid\"");

    });

    self.name("");
    self.description("");
    self.notBusy(true);
  }

  self.clear = function(){
    self.name("");
    self.description("");
    var file_input = window.document.getElementById("import-sequence-input");
    file_input.type = "text";
    file_input.type = "file";
    self.notBusy(true);
  }
}

function TemplatedPopup() {
  'use strict';
  
  var self = this;
  self.run_note = ko.observable(" ");
  self.visible = ko.observable(false);
  self.templateAndData = ko.observable({name: "blank-template", data: {}});
  self.extraClass = ko.observable("");
  
  self.close = function() {
    self.visible(false);
  };
  
  self.show = function(template, data, extraClass) {

    self.templateAndData({name: template, data: data});
    self.get_message();//get current run note
    if( extraClass ) {
      self.extraClass(extraClass);
    }
    else {
      self.extraClass("");
    }
    self.visible(true);
  };


  self.save_message = function(){

  saveMessage();
  self.visible(false);

  }

  function saveMessage() {
    //this function saves the message to the logged sequence component, not the original componet
    //though we are sending the original component id in the GUI, the server knows to save to the logged one
    var message = self.run_note()
    var componentid = self.templateAndData().data.id;

    if(componentid===null || componentid===undefined){return ;}

    return Elixys.doApiCall("/save_message", {save_message: {message: message, componentid:componentid}},
    function(result){
          var data = result["save_message"];
          var message = data["message"];
          self.run_note(message);
          self.run_note.valueHasMutated();
          }
    );

  }


   self.get_message = function(){
    getMessage();
   }

   function getMessage() {

    var componentid = self.templateAndData().data.id;
    if(componentid===null || componentid===undefined){return ;}
    return Elixys.doApiCall("/get_message", {get_message: {componentid:componentid}},
    function(result){
          var data = result["get_message"];
          var message = data["message"];
          self.run_note(message);
          self.run_note.valueHasMutated();
          }
    );

  }



}


function TwoButtonPopup(){
  'use strict';

  var self = this;
  self.visible = ko.observable(false);
  self.titleText = ko.observable("");
  self.btnBText = ko.observable("");
  self.btnAText = ko.observable("");

  // inherits Common.
  Common.apply(self, arguments);

  self.popup = function(options) {
    self.loadDefaults();
    if(options.titleText){
      self.titleText(options.titleText);
    }
    if(options.btnAText){
      self.btnAText(options.btnAText);
    }
    if(options.btnBText){
      self.btnBText(options.btnBText);
    }
    if(options.btnAClick){
      self.btnAOperation = options.btnAClick;
    }
    if(options.btnBClick){
      self.btnBOperation = options.btnBClick;
    }
    self.sequence_id = options.sequence_id;
    self.visible(true);
  }

  self.close = function(){
    self.visible(false);
  }

  self.loadDefaults = function(){
    self.titleText("Export Sequence");
    self.btnAText("ELIXYS NETWORK");
    self.btnBText("COMPUTER");
    self.btnAOperation = self.exportToNetwork;
    self.btnBOperation = self.exportToComputer;
  }

  self.exportToNetwork = function(){
    $.ajax("/network/user", {
      method: "GET",
      success: function(res){
        if( res == "" ){
          Elixys.showNetworkLoginPopup({
            "signinSuccess": self.doExport
          });
        }
        else{
          self.doExport();
        }
        self.close();
      }
    });
  }
  
  self.doExport = function(popup){
    Elixys.doApiCall("/network/sequence/export", {"sequenceid": self.sequence_id}, function(res){
      console.log(res);
    },
    function(err){
      console.log( err );
    });
  }

  self.exportToComputer = function(popup){
    var link = document.createElement("a");
    link.href = "/export_sequence?sequenceid=" + self.sequence_id;
    link.click();
    self.close();
  }

  self.btnAClick = function(){
    self.btnAOperation(self);
  }

  self.btnBClick = function(){
    self.btnBOperation(self);
  }

}